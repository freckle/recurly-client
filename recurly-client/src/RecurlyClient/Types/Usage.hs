{-# LANGUAGE MultiWayIf #-}
-- CHANGE WITH CAUTION: This is a generated code file generated by https://github.com/Haskell-OpenAPI-Code-Generator/Haskell-OpenAPI-Client-Code-Generator.
{-# LANGUAGE OverloadedStrings #-}

-- | Contains the types generated from the schema Usage
module RecurlyClient.Types.Usage where

import qualified Control.Monad.Fail
import qualified Data.Aeson
import qualified Data.Aeson as Data.Aeson.Encoding.Internal
import qualified Data.Aeson as Data.Aeson.Types
import qualified Data.Aeson as Data.Aeson.Types.FromJSON
import qualified Data.Aeson as Data.Aeson.Types.Internal
import qualified Data.Aeson as Data.Aeson.Types.ToJSON
import qualified Data.ByteString
import qualified Data.ByteString as Data.ByteString.Internal
import qualified Data.Foldable
import qualified Data.Functor
import qualified Data.Maybe
import qualified Data.Scientific
import qualified Data.Text
import qualified Data.Text as Data.Text.Internal
import qualified Data.Time.Calendar as Data.Time.Calendar.Days
import qualified Data.Time.LocalTime as Data.Time.LocalTime.Internal.ZonedTime
import qualified GHC.Base
import qualified GHC.Classes
import qualified GHC.Int
import qualified GHC.Show
import qualified GHC.Types
import qualified RecurlyClient.Common
import RecurlyClient.TypeAlias
import {-# SOURCE #-} RecurlyClient.Types.SubscriptionAddOnPercentageTier
import {-# SOURCE #-} RecurlyClient.Types.SubscriptionAddOnTier
import qualified Prelude as GHC.Integer.Type
import qualified Prelude as GHC.Maybe

-- | Defines the object schema located at @components.schemas.Usage@ in the specification.
data Usage = Usage
    { usageAmount :: (GHC.Maybe.Maybe GHC.Types.Float)
    -- ^ amount: The amount of usage. Can be positive, negative, or 0. If the Decimal Quantity feature is enabled, this value will be rounded to nine decimal places.  Otherwise, all digits after the decimal will be stripped. If the usage-based add-on is billed with a percentage, your usage should be a monetary amount formatted in cents (e.g., \$5.00 is \"500\").
    , usageBilled_at :: (GHC.Maybe.Maybe RecurlyClient.Common.JsonDateTime)
    -- ^ billed_at: When the usage record was billed on an invoice.
    , usageCreated_at :: (GHC.Maybe.Maybe RecurlyClient.Common.JsonDateTime)
    -- ^ created_at: When the usage record was created in Recurly.
    , usageId :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
    -- ^ id
    , usageMeasured_unit_id :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
    -- ^ measured_unit_id: The ID of the measured unit associated with the add-on the usage record is for.
    , usageMerchant_tag :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
    -- ^ merchant_tag: Custom field for recording the id in your own system associated with the usage, so you can provide auditable usage displays to your customers using a GET on this endpoint.
    , usageObject :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
    -- ^ object
    , usagePercentage_tiers :: (GHC.Maybe.Maybe [SubscriptionAddOnPercentageTier])
    -- ^ percentage_tiers: The percentage tiers of the subscription based on the usage_timestamp. If tier_type = flat, percentage_tiers = []. This feature is currently in development and requires approval and enablement, please contact support.
    , usageRecording_timestamp :: (GHC.Maybe.Maybe RecurlyClient.Common.JsonDateTime)
    -- ^ recording_timestamp: When the usage was recorded in your system.
    , usageTier_type :: (GHC.Maybe.Maybe UsageTier_type)
    -- ^ tier_type: The pricing model for the add-on.  For more information,
    -- [click here](https:\/\/docs.recurly.com\/docs\/billing-models\#section-quantity-based). See our
    -- [Guide](https:\/\/recurly.com\/developers\/guides\/item-addon-guide.html) for an overview of how
    -- to configure quantity-based pricing models.
    , usageTiers :: (GHC.Maybe.Maybe [SubscriptionAddOnTier])
    -- ^ tiers: The tiers and prices of the subscription based on the usage_timestamp. If tier_type = flat, tiers = []
    , usageUnit_amount :: (GHC.Maybe.Maybe GHC.Types.Float)
    -- ^ unit_amount
    , usageUnit_amount_decimal :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
    -- ^ unit_amount_decimal: Unit price that can optionally support a sub-cent value.
    --
    -- Constraints:
    --
    -- * Maxium  of 1000000.0
    -- * Minimum  of 0.0
    , usageUpdated_at :: (GHC.Maybe.Maybe RecurlyClient.Common.JsonDateTime)
    -- ^ updated_at: When the usage record was billed on an invoice.
    , usageUsage_percentage :: (GHC.Maybe.Maybe GHC.Types.Float)
    -- ^ usage_percentage: The percentage taken of the monetary amount of usage tracked. This can be up to 4 decimal places. A value between 0.0 and 100.0.
    , usageUsage_timestamp :: (GHC.Maybe.Maybe RecurlyClient.Common.JsonDateTime)
    -- ^ usage_timestamp: When the usage actually happened. This will define the line item dates this usage is billed under and is important for revenue recognition.
    , usageUsage_type :: (GHC.Maybe.Maybe UsageUsage_type)
    -- ^ usage_type: Type of usage, returns usage type if \`add_on_type\` is \`usage\`.
    }
    deriving
        ( GHC.Show.Show
        , GHC.Classes.Eq
        )

instance Data.Aeson.Types.ToJSON.ToJSON Usage where
    toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("amount" Data.Aeson.Types.ToJSON..=)) (usageAmount obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("billed_at" Data.Aeson.Types.ToJSON..=)) (usageBilled_at obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("created_at" Data.Aeson.Types.ToJSON..=)) (usageCreated_at obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("id" Data.Aeson.Types.ToJSON..=)) (usageId obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("measured_unit_id" Data.Aeson.Types.ToJSON..=)) (usageMeasured_unit_id obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("merchant_tag" Data.Aeson.Types.ToJSON..=)) (usageMerchant_tag obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("object" Data.Aeson.Types.ToJSON..=)) (usageObject obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("percentage_tiers" Data.Aeson.Types.ToJSON..=)) (usagePercentage_tiers obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("recording_timestamp" Data.Aeson.Types.ToJSON..=)) (usageRecording_timestamp obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("tier_type" Data.Aeson.Types.ToJSON..=)) (usageTier_type obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("tiers" Data.Aeson.Types.ToJSON..=)) (usageTiers obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("unit_amount" Data.Aeson.Types.ToJSON..=)) (usageUnit_amount obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("unit_amount_decimal" Data.Aeson.Types.ToJSON..=)) (usageUnit_amount_decimal obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("updated_at" Data.Aeson.Types.ToJSON..=)) (usageUpdated_at obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("usage_percentage" Data.Aeson.Types.ToJSON..=)) (usageUsage_percentage obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("usage_timestamp" Data.Aeson.Types.ToJSON..=)) (usageUsage_timestamp obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("usage_type" Data.Aeson.Types.ToJSON..=)) (usageUsage_type obj) : GHC.Base.mempty))
    toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("amount" Data.Aeson.Types.ToJSON..=)) (usageAmount obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("billed_at" Data.Aeson.Types.ToJSON..=)) (usageBilled_at obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("created_at" Data.Aeson.Types.ToJSON..=)) (usageCreated_at obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("id" Data.Aeson.Types.ToJSON..=)) (usageId obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("measured_unit_id" Data.Aeson.Types.ToJSON..=)) (usageMeasured_unit_id obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("merchant_tag" Data.Aeson.Types.ToJSON..=)) (usageMerchant_tag obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("object" Data.Aeson.Types.ToJSON..=)) (usageObject obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("percentage_tiers" Data.Aeson.Types.ToJSON..=)) (usagePercentage_tiers obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("recording_timestamp" Data.Aeson.Types.ToJSON..=)) (usageRecording_timestamp obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("tier_type" Data.Aeson.Types.ToJSON..=)) (usageTier_type obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("tiers" Data.Aeson.Types.ToJSON..=)) (usageTiers obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("unit_amount" Data.Aeson.Types.ToJSON..=)) (usageUnit_amount obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("unit_amount_decimal" Data.Aeson.Types.ToJSON..=)) (usageUnit_amount_decimal obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("updated_at" Data.Aeson.Types.ToJSON..=)) (usageUpdated_at obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("usage_percentage" Data.Aeson.Types.ToJSON..=)) (usageUsage_percentage obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("usage_timestamp" Data.Aeson.Types.ToJSON..=)) (usageUsage_timestamp obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("usage_type" Data.Aeson.Types.ToJSON..=)) (usageUsage_type obj) : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON Usage where
    parseJSON = Data.Aeson.Types.FromJSON.withObject "Usage" (\obj -> ((((((((((((((((GHC.Base.pure Usage GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "amount")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "billed_at")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "created_at")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "measured_unit_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "merchant_tag")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "object")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "percentage_tiers")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "recording_timestamp")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "tier_type")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "tiers")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "unit_amount")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "unit_amount_decimal")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "updated_at")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "usage_percentage")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "usage_timestamp")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "usage_type"))

-- | Create a new 'Usage' with all required fields.
mkUsage :: Usage
mkUsage =
    Usage
        { usageAmount = GHC.Maybe.Nothing
        , usageBilled_at = GHC.Maybe.Nothing
        , usageCreated_at = GHC.Maybe.Nothing
        , usageId = GHC.Maybe.Nothing
        , usageMeasured_unit_id = GHC.Maybe.Nothing
        , usageMerchant_tag = GHC.Maybe.Nothing
        , usageObject = GHC.Maybe.Nothing
        , usagePercentage_tiers = GHC.Maybe.Nothing
        , usageRecording_timestamp = GHC.Maybe.Nothing
        , usageTier_type = GHC.Maybe.Nothing
        , usageTiers = GHC.Maybe.Nothing
        , usageUnit_amount = GHC.Maybe.Nothing
        , usageUnit_amount_decimal = GHC.Maybe.Nothing
        , usageUpdated_at = GHC.Maybe.Nothing
        , usageUsage_percentage = GHC.Maybe.Nothing
        , usageUsage_timestamp = GHC.Maybe.Nothing
        , usageUsage_type = GHC.Maybe.Nothing
        }

{- | Defines the enum schema located at @components.schemas.Usage.properties.tier_type@ in the specification.

The pricing model for the add-on.  For more information,
[click here](https:\/\/docs.recurly.com\/docs\/billing-models\#section-quantity-based). See our
[Guide](https:\/\/recurly.com\/developers\/guides\/item-addon-guide.html) for an overview of how
to configure quantity-based pricing models.
-}
data UsageTier_type
    = -- | This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
      UsageTier_typeOther Data.Aeson.Types.Internal.Value
    | -- | This constructor can be used to send values to the server which are not present in the specification yet.
      UsageTier_typeTyped Data.Text.Internal.Text
    | -- | Represents the JSON value @"flat"@
      UsageTier_typeEnumFlat
    | -- | Represents the JSON value @"tiered"@
      UsageTier_typeEnumTiered
    | -- | Represents the JSON value @"stairstep"@
      UsageTier_typeEnumStairstep
    | -- | Represents the JSON value @"volume"@
      UsageTier_typeEnumVolume
    deriving (GHC.Show.Show, GHC.Classes.Eq)

instance Data.Aeson.Types.ToJSON.ToJSON UsageTier_type where
    toJSON (UsageTier_typeOther val) = val
    toJSON (UsageTier_typeTyped val) = Data.Aeson.Types.ToJSON.toJSON val
    toJSON (UsageTier_typeEnumFlat) = "flat"
    toJSON (UsageTier_typeEnumTiered) = "tiered"
    toJSON (UsageTier_typeEnumStairstep) = "stairstep"
    toJSON (UsageTier_typeEnumVolume) = "volume"
instance Data.Aeson.Types.FromJSON.FromJSON UsageTier_type where
    parseJSON val =
        GHC.Base.pure
            ( if
                | val GHC.Classes.== "flat" -> UsageTier_typeEnumFlat
                | val GHC.Classes.== "tiered" -> UsageTier_typeEnumTiered
                | val GHC.Classes.== "stairstep" -> UsageTier_typeEnumStairstep
                | val GHC.Classes.== "volume" -> UsageTier_typeEnumVolume
                | GHC.Base.otherwise -> UsageTier_typeOther val
            )

{- | Defines the enum schema located at @components.schemas.Usage.properties.usage_type@ in the specification.

Type of usage, returns usage type if \`add_on_type\` is \`usage\`.
-}
data UsageUsage_type
    = -- | This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
      UsageUsage_typeOther Data.Aeson.Types.Internal.Value
    | -- | This constructor can be used to send values to the server which are not present in the specification yet.
      UsageUsage_typeTyped Data.Text.Internal.Text
    | -- | Represents the JSON value @"price"@
      UsageUsage_typeEnumPrice
    | -- | Represents the JSON value @"percentage"@
      UsageUsage_typeEnumPercentage
    deriving (GHC.Show.Show, GHC.Classes.Eq)

instance Data.Aeson.Types.ToJSON.ToJSON UsageUsage_type where
    toJSON (UsageUsage_typeOther val) = val
    toJSON (UsageUsage_typeTyped val) = Data.Aeson.Types.ToJSON.toJSON val
    toJSON (UsageUsage_typeEnumPrice) = "price"
    toJSON (UsageUsage_typeEnumPercentage) = "percentage"
instance Data.Aeson.Types.FromJSON.FromJSON UsageUsage_type where
    parseJSON val =
        GHC.Base.pure
            ( if
                | val GHC.Classes.== "price" -> UsageUsage_typeEnumPrice
                | val GHC.Classes.== "percentage" -> UsageUsage_typeEnumPercentage
                | GHC.Base.otherwise -> UsageUsage_typeOther val
            )
