{-# LANGUAGE MultiWayIf #-}
-- CHANGE WITH CAUTION: This is a generated code file generated by https://github.com/Haskell-OpenAPI-Code-Generator/Haskell-OpenAPI-Client-Code-Generator.
{-# LANGUAGE OverloadedStrings #-}

-- | Contains the types generated from the schema SubscriptionAddOnUpdate
module RecurlyClient.Types.SubscriptionAddOnUpdate where

import qualified Control.Monad.Fail
import qualified Data.Aeson
import qualified Data.Aeson as Data.Aeson.Encoding.Internal
import qualified Data.Aeson as Data.Aeson.Types
import qualified Data.Aeson as Data.Aeson.Types.FromJSON
import qualified Data.Aeson as Data.Aeson.Types.Internal
import qualified Data.Aeson as Data.Aeson.Types.ToJSON
import qualified Data.ByteString
import qualified Data.ByteString as Data.ByteString.Internal
import qualified Data.Foldable
import qualified Data.Functor
import qualified Data.Maybe
import qualified Data.Scientific
import qualified Data.Text
import qualified Data.Text as Data.Text.Internal
import qualified Data.Time.Calendar as Data.Time.Calendar.Days
import qualified Data.Time.LocalTime as Data.Time.LocalTime.Internal.ZonedTime
import qualified GHC.Base
import qualified GHC.Classes
import qualified GHC.Int
import qualified GHC.Show
import qualified GHC.Types
import qualified RecurlyClient.Common
import RecurlyClient.TypeAlias
import {-# SOURCE #-} RecurlyClient.Types.SubscriptionAddOnPercentageTier
import {-# SOURCE #-} RecurlyClient.Types.SubscriptionAddOnTier
import qualified Prelude as GHC.Integer.Type
import qualified Prelude as GHC.Maybe

-- | Defines the object schema located at @components.schemas.SubscriptionAddOnUpdate@ in the specification.
data SubscriptionAddOnUpdate = SubscriptionAddOnUpdate
    { subscriptionAddOnUpdateAdd_on_source :: (GHC.Maybe.Maybe SubscriptionAddOnUpdateAdd_on_source)
    -- ^ add_on_source: Used to determine where the associated add-on data is pulled from. If this value is set to
    -- \`plan_add_on\` or left blank, then add-on data will be pulled from the plan\'s add-ons. If the associated
    -- \`plan\` has \`allow_any_item_on_subscriptions\` set to \`true\` and this field is set to \`item\`, then
    -- the associated add-on data will be pulled from the site\'s item catalog.
    , subscriptionAddOnUpdateCode :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
    -- ^ code: If a code is provided without an id, the subscription add-on attributes
    -- will be set to the current value for those attributes on the plan add-on
    -- unless provided in the request. If \`add_on_source\` is set to \`plan_add_on\`
    -- or left blank, then plan\'s add-on \`code\` should be used. If \`add_on_source\`
    -- is set to \`item\`, then the \`code\` from the associated item should be used.
    --
    --
    -- Constraints:
    --
    -- * Maximum length of 50
    , subscriptionAddOnUpdateId :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
    -- ^ id: When an id is provided, the existing subscription add-on attributes will
    -- persist unless overridden in the request.
    --
    --
    -- Constraints:
    --
    -- * Maximum length of 13
    , subscriptionAddOnUpdatePercentage_tiers :: (GHC.Maybe.Maybe (GHC.Base.NonEmpty SubscriptionAddOnPercentageTier))
    -- ^ percentage_tiers: If percentage tiers are provided in the request, all existing percentage tiers on the Subscription Add-on will be
    -- removed and replaced by the percentage tiers in the request. Use only if add_on.tier_type is tiered or volume and
    -- add_on.usage_type is percentage. There must be one tier without an \`ending_amount\` value which represents the
    -- final tier. This feature is currently in development and requires approval and enablement, please contact support.
    --
    --
    -- Constraints:
    --
    -- * Must have a minimum of 1 items
    , subscriptionAddOnUpdateQuantity :: (GHC.Maybe.Maybe GHC.Types.Int)
    -- ^ quantity
    --
    -- Constraints:
    --
    -- * Minimum  of 0.0
    , subscriptionAddOnUpdateRevenue_schedule_type :: (GHC.Maybe.Maybe SubscriptionAddOnUpdateRevenue_schedule_type)
    -- ^ revenue_schedule_type
    , subscriptionAddOnUpdateTiers :: (GHC.Maybe.Maybe (GHC.Base.NonEmpty SubscriptionAddOnTier))
    -- ^ tiers: If the plan add-on\'s \`tier_type\` is \`flat\`, then \`tiers\` must be absent. The \`tiers\` object
    -- must include one to many tiers with \`ending_quantity\` and \`unit_amount\`.
    -- There must be one tier without an \`ending_quantity\` value which represents the final tier.
    --
    --
    -- Constraints:
    --
    -- * Must have a minimum of 1 items
    , subscriptionAddOnUpdateUnit_amount :: (GHC.Maybe.Maybe GHC.Types.Float)
    -- ^ unit_amount: Allows up to 2 decimal places. Optionally, override the add-on\'s default unit amount.
    -- If the plan add-on\'s \`tier_type\` is \`tiered\`, \`volume\`, or \`stairstep\`, then \`unit_amount\` cannot be provided.
    --
    --
    -- Constraints:
    --
    -- * Maxium  of 1000000.0
    -- * Minimum  of 0.0
    , subscriptionAddOnUpdateUnit_amount_decimal :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
    -- ^ unit_amount_decimal: Allows up to 9 decimal places. Optionally, override the add-on\'s default unit amount.
    -- If the plan add-on\'s \`tier_type\` is \`tiered\`, \`volume\`, or \`stairstep\`, then \`unit_amount_decimal\` cannot be provided.
    -- Only supported when the plan add-on\'s \`add_on_type\` = \`usage\`.
    -- If \`unit_amount_decimal\` is provided, \`unit_amount\` cannot be provided.
    , subscriptionAddOnUpdateUsage_percentage :: (GHC.Maybe.Maybe GHC.Types.Float)
    -- ^ usage_percentage: The percentage taken of the monetary amount of usage tracked. This can be up to 4 decimal places. A value between 0.0 and 100.0. Required if add_on_type is usage and usage_type is percentage.
    }
    deriving
        ( GHC.Show.Show
        , GHC.Classes.Eq
        )

instance Data.Aeson.Types.ToJSON.ToJSON SubscriptionAddOnUpdate where
    toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("add_on_source" Data.Aeson.Types.ToJSON..=)) (subscriptionAddOnUpdateAdd_on_source obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("code" Data.Aeson.Types.ToJSON..=)) (subscriptionAddOnUpdateCode obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("id" Data.Aeson.Types.ToJSON..=)) (subscriptionAddOnUpdateId obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("percentage_tiers" Data.Aeson.Types.ToJSON..=)) (subscriptionAddOnUpdatePercentage_tiers obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("quantity" Data.Aeson.Types.ToJSON..=)) (subscriptionAddOnUpdateQuantity obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("revenue_schedule_type" Data.Aeson.Types.ToJSON..=)) (subscriptionAddOnUpdateRevenue_schedule_type obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("tiers" Data.Aeson.Types.ToJSON..=)) (subscriptionAddOnUpdateTiers obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("unit_amount" Data.Aeson.Types.ToJSON..=)) (subscriptionAddOnUpdateUnit_amount obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("unit_amount_decimal" Data.Aeson.Types.ToJSON..=)) (subscriptionAddOnUpdateUnit_amount_decimal obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("usage_percentage" Data.Aeson.Types.ToJSON..=)) (subscriptionAddOnUpdateUsage_percentage obj) : GHC.Base.mempty))
    toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("add_on_source" Data.Aeson.Types.ToJSON..=)) (subscriptionAddOnUpdateAdd_on_source obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("code" Data.Aeson.Types.ToJSON..=)) (subscriptionAddOnUpdateCode obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("id" Data.Aeson.Types.ToJSON..=)) (subscriptionAddOnUpdateId obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("percentage_tiers" Data.Aeson.Types.ToJSON..=)) (subscriptionAddOnUpdatePercentage_tiers obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("quantity" Data.Aeson.Types.ToJSON..=)) (subscriptionAddOnUpdateQuantity obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("revenue_schedule_type" Data.Aeson.Types.ToJSON..=)) (subscriptionAddOnUpdateRevenue_schedule_type obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("tiers" Data.Aeson.Types.ToJSON..=)) (subscriptionAddOnUpdateTiers obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("unit_amount" Data.Aeson.Types.ToJSON..=)) (subscriptionAddOnUpdateUnit_amount obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("unit_amount_decimal" Data.Aeson.Types.ToJSON..=)) (subscriptionAddOnUpdateUnit_amount_decimal obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("usage_percentage" Data.Aeson.Types.ToJSON..=)) (subscriptionAddOnUpdateUsage_percentage obj) : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON SubscriptionAddOnUpdate where
    parseJSON = Data.Aeson.Types.FromJSON.withObject "SubscriptionAddOnUpdate" (\obj -> (((((((((GHC.Base.pure SubscriptionAddOnUpdate GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "add_on_source")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "code")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "percentage_tiers")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "quantity")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "revenue_schedule_type")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "tiers")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "unit_amount")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "unit_amount_decimal")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "usage_percentage"))

-- | Create a new 'SubscriptionAddOnUpdate' with all required fields.
mkSubscriptionAddOnUpdate :: SubscriptionAddOnUpdate
mkSubscriptionAddOnUpdate =
    SubscriptionAddOnUpdate
        { subscriptionAddOnUpdateAdd_on_source = GHC.Maybe.Nothing
        , subscriptionAddOnUpdateCode = GHC.Maybe.Nothing
        , subscriptionAddOnUpdateId = GHC.Maybe.Nothing
        , subscriptionAddOnUpdatePercentage_tiers = GHC.Maybe.Nothing
        , subscriptionAddOnUpdateQuantity = GHC.Maybe.Nothing
        , subscriptionAddOnUpdateRevenue_schedule_type = GHC.Maybe.Nothing
        , subscriptionAddOnUpdateTiers = GHC.Maybe.Nothing
        , subscriptionAddOnUpdateUnit_amount = GHC.Maybe.Nothing
        , subscriptionAddOnUpdateUnit_amount_decimal = GHC.Maybe.Nothing
        , subscriptionAddOnUpdateUsage_percentage = GHC.Maybe.Nothing
        }

{- | Defines the enum schema located at @components.schemas.SubscriptionAddOnUpdate.properties.add_on_source@ in the specification.

Used to determine where the associated add-on data is pulled from. If this value is set to
\`plan_add_on\` or left blank, then add-on data will be pulled from the plan\'s add-ons. If the associated
\`plan\` has \`allow_any_item_on_subscriptions\` set to \`true\` and this field is set to \`item\`, then
the associated add-on data will be pulled from the site\'s item catalog.
-}
data SubscriptionAddOnUpdateAdd_on_source
    = -- | This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
      SubscriptionAddOnUpdateAdd_on_sourceOther Data.Aeson.Types.Internal.Value
    | -- | This constructor can be used to send values to the server which are not present in the specification yet.
      SubscriptionAddOnUpdateAdd_on_sourceTyped Data.Text.Internal.Text
    | -- | Represents the JSON value @"plan_add_on"@
      SubscriptionAddOnUpdateAdd_on_sourceEnumPlan_add_on
    | -- | Represents the JSON value @"item"@
      SubscriptionAddOnUpdateAdd_on_sourceEnumItem
    deriving (GHC.Show.Show, GHC.Classes.Eq)

instance Data.Aeson.Types.ToJSON.ToJSON SubscriptionAddOnUpdateAdd_on_source where
    toJSON (SubscriptionAddOnUpdateAdd_on_sourceOther val) = val
    toJSON (SubscriptionAddOnUpdateAdd_on_sourceTyped val) = Data.Aeson.Types.ToJSON.toJSON val
    toJSON (SubscriptionAddOnUpdateAdd_on_sourceEnumPlan_add_on) = "plan_add_on"
    toJSON (SubscriptionAddOnUpdateAdd_on_sourceEnumItem) = "item"
instance Data.Aeson.Types.FromJSON.FromJSON SubscriptionAddOnUpdateAdd_on_source where
    parseJSON val =
        GHC.Base.pure
            ( if
                | val GHC.Classes.== "plan_add_on" -> SubscriptionAddOnUpdateAdd_on_sourceEnumPlan_add_on
                | val GHC.Classes.== "item" -> SubscriptionAddOnUpdateAdd_on_sourceEnumItem
                | GHC.Base.otherwise -> SubscriptionAddOnUpdateAdd_on_sourceOther val
            )

-- | Defines the enum schema located at @components.schemas.SubscriptionAddOnUpdate.properties.revenue_schedule_type@ in the specification.
data SubscriptionAddOnUpdateRevenue_schedule_type
    = -- | This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
      SubscriptionAddOnUpdateRevenue_schedule_typeOther Data.Aeson.Types.Internal.Value
    | -- | This constructor can be used to send values to the server which are not present in the specification yet.
      SubscriptionAddOnUpdateRevenue_schedule_typeTyped Data.Text.Internal.Text
    | -- | Represents the JSON value @"at_range_end"@
      SubscriptionAddOnUpdateRevenue_schedule_typeEnumAt_range_end
    | -- | Represents the JSON value @"at_range_start"@
      SubscriptionAddOnUpdateRevenue_schedule_typeEnumAt_range_start
    | -- | Represents the JSON value @"evenly"@
      SubscriptionAddOnUpdateRevenue_schedule_typeEnumEvenly
    | -- | Represents the JSON value @"never"@
      SubscriptionAddOnUpdateRevenue_schedule_typeEnumNever
    deriving (GHC.Show.Show, GHC.Classes.Eq)

instance Data.Aeson.Types.ToJSON.ToJSON SubscriptionAddOnUpdateRevenue_schedule_type where
    toJSON (SubscriptionAddOnUpdateRevenue_schedule_typeOther val) = val
    toJSON (SubscriptionAddOnUpdateRevenue_schedule_typeTyped val) = Data.Aeson.Types.ToJSON.toJSON val
    toJSON (SubscriptionAddOnUpdateRevenue_schedule_typeEnumAt_range_end) = "at_range_end"
    toJSON (SubscriptionAddOnUpdateRevenue_schedule_typeEnumAt_range_start) = "at_range_start"
    toJSON (SubscriptionAddOnUpdateRevenue_schedule_typeEnumEvenly) = "evenly"
    toJSON (SubscriptionAddOnUpdateRevenue_schedule_typeEnumNever) = "never"
instance Data.Aeson.Types.FromJSON.FromJSON SubscriptionAddOnUpdateRevenue_schedule_type where
    parseJSON val =
        GHC.Base.pure
            ( if
                | val GHC.Classes.== "at_range_end" -> SubscriptionAddOnUpdateRevenue_schedule_typeEnumAt_range_end
                | val GHC.Classes.== "at_range_start" -> SubscriptionAddOnUpdateRevenue_schedule_typeEnumAt_range_start
                | val GHC.Classes.== "evenly" -> SubscriptionAddOnUpdateRevenue_schedule_typeEnumEvenly
                | val GHC.Classes.== "never" -> SubscriptionAddOnUpdateRevenue_schedule_typeEnumNever
                | GHC.Base.otherwise -> SubscriptionAddOnUpdateRevenue_schedule_typeOther val
            )
