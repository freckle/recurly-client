{
  "openapi": "3.0.0",
  "info": {
    "title": "Recurly V3 API",
    "description": "# Getting Started\n\n## Versioning\nThe V3 API is versioned to allow stability for integrators and\nflexibility for Recurly to continue making improvements.\n\nThe versions follow a format that incorporates the approximate date the\nchanges were released in a YYYY-MM-DD format, e.g. `v2021-02-25`.\n\n> *WARNING*: Specifying a version is required to get a successful response.\n\nEach request should specify a version using the `Accept` header:\n* `Accept: application/vnd.recurly.v2021-02-25`\n* `Accept: application/vnd.recurly.v2021-02-25+json`\n\nAll responses will include a `Recurly-Version` header with the API version\nused to process the request:\n```\nRecurly-Version: recurly.v2021-02-25\n```\n\nRecurly's client libraries correspond with API versions as listed below.\n\n<table>\n  <tr>\n    <th>API Version</th>\n    <th>Client Library Version</th>\n  </tr>\n  <tr>\n    <td>v2021-02-25</td>\n    <td>4.x</td>\n  </tr>\n  <tr>\n    <td>v2019-10-10</td>\n    <td>3.x</td>\n  </tr>\n</table>\n\nClient library releases:\n\n* [Node.js](https://github.com/recurly/recurly-client-node/releases)\n* [Python](https://github.com/recurly/recurly-client-python/releases)\n* [.NET](https://github.com/recurly/recurly-client-dotnet/releases)\n* [Ruby](https://github.com/recurly/recurly-client-ruby/releases)\n* [Java](https://github.com/recurly/recurly-client-java/releases)\n* [PHP](https://github.com/recurly/recurly-client-php/releases)\n* [Go](https://github.com/recurly/recurly-client-go/releases)\n\nClient libraries follow semantic versioning. For example, [Ruby client library\nversion 3.18.1](https://github.com/recurly/recurly-client-ruby/releases/tag/3.18.1)\nrepresents major version `3`, minor version `18` with patch `1`.\n\nWe encourage you to update to the latest version of the API and corresponding client library,\nas most recent versions are more performant than their predecessors. See the\n[changelog](https://recurly.com/developers/api/changelog.html) for a comprehensive list of changes\nintroduced in the latest API version.\n\n### Default Versions\nSpecifying a version is required to get a successful response. If you wish to\nreceive the latest version and are willing to accept the risk of breaking changes,\nyou may specify a version of `latest`.\n\nThe following media types will default the newest version of\nthe API:\n\n* `application/vnd.recurly.latest`\n* `application/vnd.recurly.latest+json`\n\n### Deprecation\nResponses for a deprecated version request will return two headers:\n```\nRecurly-Deprecated: TRUE\nRecurly-Sunset-Date: 2017-06-01T00:00:00+00:00\n```\nThe sunset date is an ISO-8601 formatted date time after which the version\nwill no longer be accessible.\n\n### Unsupported Versions\nA request for an unsupported version will return a status code of 406 and\nthe body will include a list of supported versions:\n```\n{\n  \"error\": {\n    \"type\": \"invalid_api_version\",\n    \"message\": \"That accept header isn't in the format we use to specify an API version. Try one of these instead:\",\n    \"acceptable_accept_headers\": [\n      \"application/vnd.recurly.v2016-03-01\",\n      \"application/vnd.recurly.v2016-04-27\",\n      \"application/vnd.recurly.v2016-07-27\",\n      \"application/vnd.recurly.v2016-12-15\",\n      \"application/vnd.recurly.v2017-01-12\",\n      \"application/vnd.recurly.v2017-09-30\",\n      \"application/vnd.recurly.v2018-01-24\",\n      \"application/vnd.recurly.v2018-05-10\",\n      \"application/vnd.recurly.v2018-06-06\",\n      \"application/vnd.recurly.v2018-08-09\",\n      \"application/vnd.recurly.v2019-10-10\",\n      \"application/vnd.recurly.v2021-02-25\"\n    ]\n  }\n}\n```\n\n## Error Messages\nError messages sent via the Recurly API are generally directed at\ndevelopers and those who are familiar with API technology. When using the\nAPI and passing error messages to target systems, be mindful that\nthese messages may not make sense in the context of the target system.\nPlease consider changing these messages in the target system to be better\nsuited to the audience of the system.\n\nPlease see [transaction error codes](https://recurly.com/developers/pages/api-transaction-errors.html) for more details.\n\n## Pagination\n### Response Schema\nEvery GET listing endpoint returns a response with the same schema:\n\n```\n{\n  \"object\":   \"list\",         // Always \"list\"\n  \"has_more\": true,           // false if this is the last page of data\n  \"next\":     \"https://...\",  // A URL pointing to the next page of data\n  \"data\":     []              // The data for this page as an array\n}\n```\n\nTo page through every record, your code should continually call the URL\nat `next` until `has_more` is `false`.\n\n### Query Parameters\nMost GET listing endpoints take query parameters that allow filtering\nand sorting the results. Some endpoints have additional parameters, which are\ndocumented on the respective endpoints, but most support the\nfollowing parameters:\n\n* `ids`: A comma separated list of ids to match.\n* `limit`: The number of records to return per page.\n* `order`: The sort order of records.\n* `sort`: The date field to use in sorting.\n* `begin_time`: The start datetime to filter (ISO 8601).\n* `end_time`: The end datetime to filter (ISO 8601).\n\n### Counting with HEAD\nEvery GET listing endpoint also supports the HEAD HTTP method. Making a\nhead request to the endpoint results in an empty body and an additional\n`Recurly-Total-Records` header. This is a count of the total number of records\nthat the endpoint will return, taking into account the current filtering query\nparameters.\n\n## Limits\nIn order to provide a fast response time to all our customers, we may rate\nlimit excessive requests. By default, new Recurly sites have the following\nAPI rate limits:\n\n* Sandbox sites: 400 requests/min. All requests count towards the rate limit.\n* Production sites: 1,000 requests/min. Only GET requests count towards the rate limit.\n\nOnce your site moves into production mode, Recurly will only rate limit\nGET requests. New subscriptions, account modifications, and other requests\nusing POST, PUT, or DELETE methods will not count against your rate limit.\n\nThe rate limit is calculated over a sliding 5 minute window. This means a\nproduction site could make 4,000 requests within one minute and not hit\nthe rate limit so long as the site made less than 1,000 requests during\nthe prior 4 minutes.\n\nIf an API request exceeds the rate limit, the API will return a\n`429 Too Many Requests` HTTP status. If your business needs a higher\nlimit, please contact support.\n\nThe rate limit applied to your client can be determined with the\n`X-RateLimit-Limit` header, and the number of remaining requests is sent\nin the `X-RateLimit-Remaining` header. Finally, the `X-RateLimit-Reset`\nheader contains an integer value representing the time, measured in\nseconds since the UNIX Epoch, at which the request count will be reset.\n\n## Change Log\n\nA list of changes for this version can be found [in the changelog](https://recurly.com/developers/api/changelog.html#v2021-02-25---current-ga-version).\n",
    "version": "v2021-02-25"
  },
  "security": [
    {
      "api_key": []
    }
  ],
  "x-tagGroups": [
    {
      "name": "Customers",
      "tags": [
        "account",
        "note",
        "account_acquisition",
        "billing_info",
        "billing_infos",
        "subscription",
        "subscription_change",
        "shipping_address",
        "purchase",
        "usage",
        "automated_exports",
        "gift_cards"
      ]
    },
    {
      "name": "App Management",
      "tags": [
        "external_subscriptions",
        "external_invoices",
        "external_products",
        "external_accounts",
        "external_product_references",
        "external_payment_phases"
      ]
    },
    {
      "name": "Products and Promotions",
      "tags": [
        "item",
        "plan",
        "add-on",
        "measured_unit",
        "coupon",
        "coupon_redemption",
        "unique_coupon_code"
      ]
    },
    {
      "name": "Invoices and Payments",
      "tags": [
        "invoice",
        "line_item",
        "credit_payment",
        "transaction"
      ]
    },
    {
      "name": "Configuration",
      "tags": [
        "site",
        "custom_field_definition",
        "shipping_method",
        "dunning_campaigns",
        "business_entities",
        "general_ledger_account",
        "performance_obligations"
      ]
    }
  ],
  "tags": [
    {
      "name": "site",
      "x-displayName": "Site"
    },
    {
      "name": "custom_field_definition",
      "x-displayName": "Custom Field Definition",
      "description": "Describes the fields that can be used as custom fields on accounts, items, line-items (one time charges), plans, or subscriptions."
    },
    {
      "name": "item",
      "x-displayName": "Item",
      "description": "For merchants who sell the same things to many customers, documenting those offerings in a catalog allows for faster charge creation, easier management of offerings, and analytics about your offerings across all sales channels. Because your offerings can be physical, digital, or service-oriented, Recurly collectively calls these offerings \"Items\".\n\nRecurly's item catalog requires the Credit Invoices feature to be enabled."
    },
    {
      "name": "plan",
      "x-displayName": "Plan",
      "description": "A plan tells Recurly how often and how much to charge your customers. Plans can be created with free trials, optional products (called add-ons), setup fees, and more."
    },
    {
      "name": "add-on",
      "x-displayName": "Add-on",
      "description": "An add-on is a charge billed each billing period in addition to a subscriptionâ€™s base charge. Each plan may have one or more add-ons associated with it."
    },
    {
      "name": "measured_unit",
      "x-displayName": "Measured Unit",
      "description": "A measured unit describes a usage-based add-on's usage. If different usage-based add-ons share the same measured unit, you can report on customer usage for those add-ons at the aggregated measured unit level."
    },
    {
      "name": "account",
      "x-displayName": "Account",
      "description": "Accounts are core to managing your customers inside of Recurly. The account object stores the entire Recurly history of your customer and acts as the entry point for working with a customer's billing information, subscription data, transactions, invoices and more."
    },
    {
      "name": "note",
      "x-displayName": "Account Note",
      "description": "Account notes allow your team to leave notes on an account to add context, e.g. the reason for a refund, customer requests, and/or complaints. These notes are internal and not exposed to your customers."
    },
    {
      "name": "account_acquisition",
      "x-displayName": "Account Acquisition Info",
      "description": "Recurly offers the ability to record marketing data on customer accounts to match this data with revenue and billing data events in Recurly."
    },
    {
      "name": "billing_info",
      "x-displayName": "Billing Info",
      "description": "Without the premium Wallet feature, an account can only have one stored payment method at a time. Examples include credit cards, PayPal, or bank accounts. Billing info is filled out by the customer upon purchase or when they update their information."
    },
    {
      "name": "billing_infos",
      "x-displayName": "Billing Infos",
      "description": "If the premium Wallet feature is enabled, an account can have multiple payment methods stored. Examples include credit cards, PayPal, or bank accounts. Primary or backup billing infos can be designated from these endpoints."
    },
    {
      "name": "subscription",
      "x-displayName": "Subscription",
      "description": "Subscriptions are created when your customers subscribe to one of your plans. The customer's subscription tells Recurly when and how much to bill the customer."
    },
    {
      "name": "subscription_change",
      "x-displayName": "Subscription Change",
      "description": "Subscription changes alter subscription in a way that might affect the invoiced amount, such as changing the plan, add-ons, quantities, or shipping address. Changes can be made immediately in the current billing cycle or scheduled to take place at the next renewal."
    },
    {
      "name": "shipping_address",
      "x-displayName": "Shipping Address",
      "description": "Shipping addresses are tied to a customer's account. Each account can have up to 20 different shipping addresses, and if you have enabled multiple subscriptions per account, you can associate different shipping addresses to each subscription."
    },
    {
      "name": "invoice",
      "x-displayName": "Invoice",
      "description": "An invoice relates charges, credits, and payments together. When a subscription is created or renewed or a charge is created on the account, Recurly will sum the charges, discount or tax as appropriate, and send the invoice out for collection."
    },
    {
      "name": "line_item",
      "x-displayName": "Line Item",
      "description": "Line items are the charges and credits on your customer's invoices."
    },
    {
      "name": "credit_payment",
      "x-displayName": "Credit Payment"
    },
    {
      "name": "purchase",
      "x-displayName": "Purchase",
      "description": "A purchase is a checkout containing at least one or more subscriptions or one-time charges (line items) and supports both coupon and gift card redemptions. All items purchased will be on one invoice and paid for with one transaction. The purchases endpoint can also be used to immediately create a credit invoice on an account, when Credit Invoices is enabled on your site."
    },
    {
      "name": "usage",
      "x-displayName": "Usage",
      "description": "Send Recurly your customer usage and we will automatically bill them in arrears at the end of the billing cycle. For more info on usage-based billing, [click here](https://docs.recurly.com/docs/usage-based-billing)."
    },
    {
      "name": "transaction",
      "x-displayName": "Transaction",
      "description": "Purchasing information is sent to your payment gateway in an action called a transaction. This includes the customer's billing information and the amount of money to be charged, voided, or refunded."
    },
    {
      "name": "coupon",
      "x-displayName": "Coupon",
      "description": "Coupons can either be single codes that easily allow mass distribution by many customers or bulk coupons that can generate many unique coupons that can allow for individual delivery and tracking."
    },
    {
      "name": "coupon_redemption",
      "x-displayName": "Coupon Redemption",
      "description": "Coupon redemptions are created when a coupon is applied to an account or subscription. This allows you to track your promotions."
    },
    {
      "name": "unique_coupon_code",
      "x-displayName": "Unique Coupon Code",
      "description": "Unique coupon codes are generated from bulk coupons."
    },
    {
      "name": "shipping_method",
      "x-displayName": "Shipping Method",
      "description": "Shipping methods offered to send products to customers."
    },
    {
      "name": "automated_exports",
      "x-displayName": "Automated Exports",
      "description": "Automated exports of customer data."
    },
    {
      "name": "dunning_campaigns",
      "x-displayName": "Dunning Campaigns",
      "description": "Settings used when attempting to dun customers whose payments are declined."
    },
    {
      "name": "external_subscriptions",
      "x-displayName": "External Subscription",
      "description": "A subscription from an external resource that is not managed by the Recurly platform and instead is managed by third-party platforms like Apple App Store and Google Play Store."
    },
    {
      "name": "external_invoices",
      "x-displayName": "External Invoice",
      "description": "An invoice from an external resource that is not managed by the Recurly platform and instead is managed by third-party platforms like Apple App Store and Google Play Store."
    },
    {
      "name": "external_products",
      "x-displayName": "External Product",
      "description": "A product from an external resource that is not managed by the Recurly platform and instead is managed by third-party platforms like Apple App Store and Google Play Store."
    },
    {
      "name": "external_product_references",
      "x-displayName": "External Product Reference",
      "description": "Associates an external product to a corresponding resource on an external platform like the Apple App Store or Google Play Store."
    },
    {
      "name": "external_payment_phases",
      "x-displayName": "External Payment Phase",
      "description": "Details of payments in the lifecycle of a subscription from an external resource that is not managed by the Recurly platform, e.g. App Store or Google Play Store."
    },
    {
      "name": "gift_cards",
      "x-displayName": "Gift Cards",
      "description": "Add gift card purchases to your checkout and allow gift card recipients to redeem the gift card for credit towards any of your products."
    },
    {
      "name": "external_accounts",
      "x-displayName": "External Account",
      "description": "An account from an external resource that is not managed by the Recurly platform and instead is managed by third-party platforms like Apple App Store and Google Play Store."
    },
    {
      "name": "business_entities",
      "x-displayName": "Business Entities",
      "description": "Describes the business address that will be used for invoices and taxes depending on settings and subscriber location."
    },
    {
      "name": "general_ledger_account",
      "x-displayName": "General Ledger Account",
      "description": "A general ledger account is an account of record used to sort, store\nand summarize a company's transactions. Recurly supports the balance\nsheet (Liability) account and income (Revenue) account to be attached\nto business entities, plans, or at the item level.\n\nWhen invoices are created, system can default to the accounts based\non the GL Accounts attached at the plan/item level. The accounts can\nbe defaulted from the business entity level as well.\n\nThese accounts will be used in the Revenue Recognition module to create\nthe revenue journals that can be posted into Merchant GL system.\n\nRevenue and Liability accounts can defined in the system using this\nAPI or via the General Ledger Accounting page in the Admin UI and then\nused at the plan/item level.\n\nRecurly allows merchants to default the accounts at the following levels:\n- Business Entities (default)\n- Plans\n    - Base Price\n    - Setup Fee\n    - Add-ons\n- Items\n- Charges\n- Gift Cards\n- Shipping Methods\n- Credits\n\nIf you are interested in Recurly Revenue Recognition features, please\ncontact a Recurly customer service representative.\n"
    },
    {
      "name": "performance_obligations",
      "x-displayName": "Performance Obligations",
      "description": "A performance obligation is a promise to provide a distinct good or\nservice or a series of distinct goods or services as defined by the revenue standard.\nPerformance obligations are completed and revenue is recognized either at a point in\ntime or over a period of time, depending on the type of obligation.\n- Point in time  a company has to go through the criteria and determine if a performance\nobligation is satisfied over time. If it does not meet those criteria, then the performance\nobligation is satisfied and revenue recognized at the point in time when control of the good\nor service is transferred to the customer.\n- Over a period of time  a performance obligation is satisfied and revenue is recognized over\ntime if at least one of the following are met:\n  - The customer receives and consumes the benefits of the goods or services as they are provided\n  by the entity (routine, recurring services like a cleaning service are an example of a series of\n  services that are substantially the same and have the same pattern of transfer)\n"
    }
  ],
  "paths": {
    "/sites": {
      "get": {
        "operationId": "list_sites",
        "summary": "List sites",
        "description": "This route is most useful for finding a site's ID for subsequent requests.\n\nSee the [Pagination Guide](/developers/guides/pagination.html) to learn how to use pagination in the API and Client Libraries.\n",
        "tags": [
          "site"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/ids"
          },
          {
            "$ref": "#/components/parameters/limit"
          },
          {
            "$ref": "#/components/parameters/order"
          },
          {
            "$ref": "#/components/parameters/sort_dates"
          },
          {
            "$ref": "#/components/parameters/filter_state"
          }
        ],
        "responses": {
          "200": {
            "description": "A list of sites.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SiteList"
                }
              }
            }
          },
          "400": {
            "description": "Invalid or unpermitted parameter.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": [
          {
            "lang": "Node.js",
            "source": "const sites = client.listSites({ params: { limit: 200 } })\n\nfor await (const site of sites.each()) {\n  console.log(site.subdomain)\n}\n"
          },
          {
            "lang": "Python",
            "source": "params = {\"limit\": 200}\nsites = client.list_sites(params=params).items()\nfor site in sites:\n    print(site.subdomain)\n"
          },
          {
            "lang": ".NET",
            "source": "var optionalParams = new ListSitesParams()\n{\n    Limit = 200\n};\nvar sites = client.ListSites(optionalParams);\nforeach(Site site in sites)\n{\n    Console.WriteLine(site.Subdomain);\n}\n"
          },
          {
            "lang": "Ruby",
            "source": "params = {\n  limit: 200\n}\nsites = @client.list_sites(params: params)\nsites.each do |site|\n  puts \"Site: #{site.subdomain}\"\nend\n"
          },
          {
            "lang": "Java",
            "source": "QueryParams params = new QueryParams();\nparams.setLimit(200); // Pull 200 records at a time\nfinal Pager<Site> sites = client.listSites(params);\n\nfor (Site site : sites) {\n    System.out.println(site.getSubdomain());\n}\n"
          },
          {
            "lang": "PHP",
            "source": "$options = [\n  'params' => [\n    'limit' => 200\n  ]\n];\n$sites = $client->listSites($options);\n\nforeach($sites as $site) {\n  echo 'Site: ' . $site->getSubdomain() . PHP_EOL;\n}\n"
          },
          {
            "lang": "Go",
            "source": "listParams := &recurly.ListSitesParams{\n\tSort:  recurly.String(\"created_at\"),\n\tOrder: recurly.String(\"asc\"),\n\tLimit: recurly.Int(200),\n}\n\nsites, err := client.ListSites(listParams)\nif err != nil {\n\tfmt.Println(\"Unexpected error: %v\", err)\n\treturn\n}\n\nfor sites.HasMore() {\n\terr := sites.Fetch()\n\tif e, ok := err.(*recurly.Error); ok {\n\t\tfmt.Printf(\"Failed to retrieve next page: %v\", e)\n\t\tbreak\n\t}\n\tfor i, site := range sites.Data() {\n\t\tfmt.Printf(\"Site %3d: %s, %s\\n\",\n\t\t\ti,\n\t\t\tsite.Id,\n\t\t\tsite.Subdomain,\n\t\t)\n\t}\n}"
          }
        ]
      }
    },
    "/sites/{site_id}": {
      "get": {
        "operationId": "get_site",
        "summary": "Fetch a site",
        "tags": [
          "site"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/site_id"
          }
        ],
        "responses": {
          "200": {
            "description": "A site.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Site"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": [
          {
            "lang": "Node.js",
            "source": "try {\n  const site = await client.getSite(siteId)\n  console.log('Fetched site: ', site)\n} catch (err) {\n  if (err instanceof recurly.errors.NotFoundError) {\n    // If the request was not found, you may want to alert the user or\n    // just return null\n    console.log('Resource Not Found')\n  } else {\n    // If we don't know what to do with the err, we should\n    // probably re-raise and let our web framework and logger handle it\n    console.log('Unknown Error: ', err)\n  }\n}\n"
          },
          {
            "lang": "Python",
            "source": "try:\n    site = client.get_site(site_id)\n    print(\"Got Site %s\" % site)\nexcept recurly.errors.NotFoundError:\n    # If the resource was not found, you may want to alert the user or\n    # just return nil\n    print(\"Resource Not Found\")\n"
          },
          {
            "lang": ".NET",
            "source": "try\n{\n    Site site = client.GetSite(siteId);\n    Console.WriteLine($\"Fetched site {site.Id}\");\n}\ncatch (Recurly.Errors.NotFound ex)\n{\n    // If the resource was not found\n    // we may want to alert the user or just return null\n    Console.WriteLine($\"Resource Not Found: {ex.Error.Message}\");\n}\ncatch (Recurly.Errors.ApiError ex)\n{\n    // Use ApiError to catch a generic error from the API\n    Console.WriteLine($\"Unexpected Recurly Error: {ex.Error.Message}\");\n}\n"
          },
          {
            "lang": "Ruby",
            "source": "begin\n  site = @client.get_site(site_id: site_id)\n  puts \"Got Site #{site}\"\nrescue Recurly::Errors::NotFoundError\n  # If the resource was not found, you may want to alert the user or\n  # just return nil\n  puts \"Resource Not Found\"\nend\n"
          },
          {
            "lang": "Java",
            "source": "try {\n    final Site site = client.getSite(siteId);\n    System.out.println(\"Fetched site: \" + site.getId());\n  } catch (NotFoundException e) {\n    // If the resource was not found\n    // we may want to alert the user or just return null\n    System.out.println(\"Resource Not Found: \" + e.getError().getMessage());\n} catch (ApiException e) {\n    // Use ApiException to catch a generic error from the API\n    System.out.println(\"Unexpected Recurly Error: \" + e.getError().getMessage());\n}\n"
          },
          {
            "lang": "PHP",
            "source": "try {\n    $site = $client->getSite($site_id);\n\n    echo 'Got Site:' . PHP_EOL;\n    var_dump($site);\n} catch (\\Recurly\\Errors\\NotFound $e) {\n    // Could not find the resource, you may want to inform the user\n    // or just return a NULL\n    echo 'Could not find resource.' . PHP_EOL;\n    var_dump($e);\n} catch (\\Recurly\\RecurlyError $e) {\n    // Something bad happened... tell the user so that they can fix it?\n    echo 'Some unexpected Recurly error happened. Try again later.' . PHP_EOL;\n}\n"
          },
          {
            "lang": "Go",
            "source": "site, err := client.GetSite(siteID)\nif e, ok := err.(*recurly.Error); ok {\n\tif e.Type == recurly.ErrorTypeNotFound {\n\t\tfmt.Printf(\"Resource not found: %v\", e)\n\t\treturn nil, err\n\t}\n\tfmt.Printf(\"Unexpected Recurly error: %v\", e)\n\treturn nil, err\n}\nfmt.Printf(\"Fetched Site: %s\", site.Id)"
          }
        ]
      }
    },
    "/accounts": {
      "get": {
        "tags": [
          "account"
        ],
        "operationId": "list_accounts",
        "summary": "List a site's accounts",
        "description": "See the [Pagination Guide](/developers/guides/pagination.html) to learn how to use pagination in the API and Client Libraries.",
        "parameters": [
          {
            "$ref": "#/components/parameters/ids"
          },
          {
            "$ref": "#/components/parameters/limit"
          },
          {
            "$ref": "#/components/parameters/order"
          },
          {
            "$ref": "#/components/parameters/sort_dates"
          },
          {
            "$ref": "#/components/parameters/filter_begin_time"
          },
          {
            "$ref": "#/components/parameters/filter_end_time"
          },
          {
            "$ref": "#/components/parameters/filter_account_email"
          },
          {
            "$ref": "#/components/parameters/filter_account_subscriber"
          },
          {
            "$ref": "#/components/parameters/filter_account_past_due"
          }
        ],
        "responses": {
          "200": {
            "description": "A list of the site's accounts.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AccountList"
                }
              }
            }
          },
          "400": {
            "description": "Invalid or unpermitted parameter.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": [
          {
            "lang": "Node.js",
            "source": "const accounts = client.listAccounts({ params: { limit: 200 } })\n\nfor await (const account of accounts.each()) {\n  console.log(account.code)\n}\n"
          },
          {
            "lang": "Python",
            "source": "params = {\"limit\": 200}\naccounts = client.list_accounts(params=params).items()\nfor account in accounts:\n    print(account.code)\n"
          },
          {
            "lang": ".NET",
            "source": "var optionalParams = new ListAccountsParams()\n{\n    Limit = 200\n};\nvar accounts = client.ListAccounts(optionalParams);\nforeach(Account account in accounts)\n{\n    Console.WriteLine(account.Code);\n}\n"
          },
          {
            "lang": "Ruby",
            "source": "params = {\n  limit: 200\n}\naccounts = @client.list_accounts(params: params)\naccounts.each do |account|\n  puts \"Account: #{account.code}\"\nend\n"
          },
          {
            "lang": "Java",
            "source": "QueryParams params = new QueryParams();\nparams.setLimit(200); // Pull 200 records at a time\nPager<Account> accounts = client.listAccounts(params);\n\nfor (Account acct : accounts) {\n    System.out.println(acct.getCode());\n}\n"
          },
          {
            "lang": "PHP",
            "source": "$options = [\n  'params' => [\n    'limit' => 200\n  ]\n];\n$accounts = $client->listAccounts($options);\n\nforeach($accounts as $account) {\n  echo 'Account code: ' . $account->getCode() . PHP_EOL;\n}\n"
          },
          {
            "lang": "Go",
            "source": "listParams := &recurly.ListAccountsParams{\n\tSort:  recurly.String(\"created_at\"),\n\tOrder: recurly.String(\"desc\"),\n\tLimit: recurly.Int(200),\n}\naccounts, err := client.ListAccounts(listParams)\nif err != nil {\n\tfmt.Println(\"Unexpected error: %v\", err)\n\treturn\n}\n\nfor accounts.HasMore() {\n\terr := accounts.Fetch()\n\tif e, ok := err.(*recurly.Error); ok {\n\t\tfmt.Printf(\"Failed to retrieve next page: %v\", e)\n\t\tbreak\n\t}\n\tfor i, account := range accounts.Data() {\n\t\tfmt.Printf(\"Account %3d: %s, %s\\n\",\n\t\t\ti,\n\t\t\taccount.Id,\n\t\t\taccount.Code,\n\t\t)\n\t}\n}"
          }
        ]
      },
      "post": {
        "tags": [
          "account"
        ],
        "operationId": "create_account",
        "summary": "Create an account",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AccountCreate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "An account.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Account"
                }
              }
            }
          },
          "400": {
            "description": "Bad request, perhaps invalid JSON?",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "422": {
            "description": "Invalid parameters or an error running the billing info verification transaction.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": [
          {
            "lang": "Node.js",
            "source": "try {\n  const accountCreate = {\n    code: accountCode,\n    firstName: 'Benjamin',\n    lastName: 'Du Monde',\n    preferredTimeZone: 'America/Chicago',\n    address: {\n      street1: '900 Camp St',\n      city: 'New Orleans',\n      region: 'LA',\n      postalCode: '70115',\n      country: 'US'\n    }\n  }\n  const account = await client.createAccount(accountCreate)\n  console.log('Created Account: ', account.code)\n} catch (err) {\n  if (err instanceof recurly.errors.ValidationError) {\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in err.params\n    console.log('Failed validation', err.params)\n  } else {\n    // If we don't know what to do with the err, we should\n    // probably re-raise and let our web framework and logger handle it\n    console.log('Unknown Error: ', err)\n  }\n}\n"
          },
          {
            "lang": "Python",
            "source": "try:\n    account_create = {\n        \"code\": account_code,\n        \"first_name\": \"Benjamin\",\n        \"last_name\": \"Du Monde\",\n        \"preferred_time_zone\": \"America/Chicago\",\n        \"acquisition\": {\n            \"campaign\": \"podcast-marketing\",\n            \"channel\": \"social_media\",\n            \"subchannel\": \"twitter\",\n            \"cost\": {\"currency\": \"USD\", \"amount\": 0.50},\n        },\n        \"shipping_addresses\": [\n            {\n                \"nickname\": \"Home\",\n                \"street1\": \"1 Tchoupitoulas St\",\n                \"city\": \"New Orleans\",\n                \"region\": \"LA\",\n                \"country\": \"US\",\n                \"postal_code\": \"70115\",\n                \"first_name\": \"Aaron\",\n                \"last_name\": \"Du Monde\",\n            }\n        ],\n    }\n    account = client.create_account(account_create)\n    print(\"Created Account %s\" % account)\nexcept recurly.errors.ValidationError as e:\n    # If the request was invalid, you may want to tell your user\n    # why. You can find the invalid params and reasons in e.error.params\n    print(\"ValidationError: %s\" % e.error.message)\n    print(e.error.params)\n"
          },
          {
            "lang": ".NET",
            "source": "try\n{\n    var accountReq = new AccountCreate()\n    {\n        Code = accountCode,\n        FirstName = \"Benjamin\",\n        LastName = \"Du Monde\",\n        PreferredTimeZone = \"America/Chicago\",\n        Address = new Address()\n        {\n            City = \"New Orleans\",\n            Region = \"LA\",\n            Country = \"US\",\n            PostalCode = \"70115\",\n            Street1 = \"900 Camp St.\"\n        }\n    };\n    Account account = client.CreateAccount(accountReq);\n    Console.WriteLine($\"Created account {account.Code}\");\n}\ncatch (Recurly.Errors.Validation ex)\n{\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in ex.Error.Params\n    Console.WriteLine($\"Failed validation: {ex.Error.Message}\");\n}\ncatch (Recurly.Errors.ApiError ex)\n{\n    // Use ApiError to catch a generic error from the API\n    Console.WriteLine($\"Unexpected Recurly Error: {ex.Error.Message}\");\n}\n"
          },
          {
            "lang": "Ruby",
            "source": "begin\n  account_create = {\n    code: account_code,\n    first_name: \"Benjamin\",\n    last_name: \"Du Monde\",\n    preferred_time_zone: \"America/Chicago\",\n    acquisition: {\n      campaign: \"podcast-marketing\",\n      channel: \"social_media\",\n      subchannel: \"twitter\",\n      cost: {\n        currency: \"USD\",\n        amount: 0.50\n      }\n    },\n    shipping_addresses: [\n      {\n        nickname: \"Home\",\n        street1: \"1 Tchoupitoulas St\",\n        city: \"New Orleans\",\n        region: \"LA\",\n        country: \"US\",\n        postal_code: \"70115\",\n        first_name: \"Benjamin\",\n        last_name: \"Du Monde\"\n      }\n    ]\n  }\n  account = @client.create_account(body: account_create)\n  puts \"Created Account #{account}\"\nrescue Recurly::Errors::ValidationError => e\n  # If the request was invalid, you may want to tell your user\n  # why. You can find the invalid params and reasons in e.recurly_error.params\n  puts \"ValidationError: #{e.recurly_error.params}\"\nend\n"
          },
          {
            "lang": "Java",
            "source": "try {\n    AccountCreate accountReq = new AccountCreate();\n    Address address = new Address();\n\n    accountReq.setCode(accountCode);\n    accountReq.setFirstName(\"Aaron\");\n    accountReq.setLastName(\"Du Monde\");\n    accountReq.setPreferredTimeZone(\"America/Chicago\");\n\n    address.setStreet1(\"900 Camp St.\");\n    address.setCity(\"New Orleans\");\n    address.setRegion(\"LA\");\n    address.setCountry(\"US\");\n    address.setPostalCode(\"70115\");\n\n    accountReq.setAddress(address);\n\n    Account account = client.createAccount(accountReq);\n    System.out.println(\"Created account \" + account.getCode());\n} catch (ValidationException e) {\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in e.getError().getParams()\n    System.out.println(\"Failed validation: \" + e.getError().getMessage());\n} catch (ApiException e) {\n    // Use ApiException to catch a generic error from the API\n    System.out.println(\"Unexpected Recurly Error: \" + e.getError().getMessage());\n}\n"
          },
          {
            "lang": "PHP",
            "source": "try {\n    $account_create = [\n        \"code\" => $account_code,\n        \"first_name\" => \"Douglas\",\n        \"last_name\" => \"DuMonde\",\n        \"preferred_time_zone\" => \"America/Chicago\",\n        \"shipping_addresses\" => [\n            [\n                \"first_name\" => \"Douglas\",\n                \"last_name\" => \"DuMonde\",\n                \"nickname\" => \"nola\",\n                \"street1\" => \"1 Tchoupitoulas\",\n                \"city\" => \"New Orleans\",\n                \"postal_code\" => \"70130\",\n                \"country\" => \"US\"\n            ]\n        ]\n    ];\n\n    $account = $client->createAccount($account_create);\n\n    echo 'Created Account:' . PHP_EOL;\n    var_dump($account);\n} catch (\\Recurly\\Errors\\Validation $e) {\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in err.params\n    var_dump($e);\n} catch (\\Recurly\\RecurlyError $e) {\n    // If we don't know what to do with the err, we should\n    // probably re-raise and let our web framework and logger handle it\n    var_dump($e);\n}\n"
          },
          {
            "lang": "Go",
            "source": "accountReq := &recurly.AccountCreate{\n\tCode:      &accountCode,\n\tFirstName: recurly.String(\"Isaac\"),\n\tLastName:  recurly.String(\"Du Monde\"),\n\tEmail:     recurly.String(\"isaac@example.com\"),\n\tPreferredTimeZone: recurly.String(\"America/Los_Angeles\"),\n\tBillingInfo: &recurly.BillingInfoCreate{\n\t\tFirstName: recurly.String(\"Isaac\"),\n\t\tLastName:  recurly.String(\"Du Monde\"),\n\t\tAddress: &recurly.AddressCreate{\n\t\t\tPhone:      recurly.String(\"415-555-5555\"),\n\t\t\tStreet1:    recurly.String(\"400 Alabama St.\"),\n\t\t\tCity:       recurly.String(\"San Francisco\"),\n\t\t\tPostalCode: recurly.String(\"94110\"),\n\t\t\tCountry:    recurly.String(\"US\"),\n\t\t\tRegion:     recurly.String(\"CA\"),\n\t\t},\n\t\tNumber: recurly.String(\"4111111111111111\"),\n\t\tMonth:  recurly.String(\"12\"),\n\t\tYear:   recurly.String(\"30\"),\n\t\tCvv:    recurly.String(\"123\"),\n\t},\n}\n\naccount, err := client.CreateAccount(accountReq)\nif e, ok := err.(*recurly.Error); ok {\n\tif e.Type == recurly.ErrorTypeValidation {\n\t\tfmt.Printf(\"Failed validation: %v\", e)\n\t\treturn nil, err\n\t}\n\tfmt.Printf(\"Unexpected Recurly error: %v\", e)\n\treturn nil, err\n}\nfmt.Printf(\"Created Account: %s\", account.Id)"
          }
        ]
      }
    },
    "/accounts/{account_id}": {
      "parameters": [
        {
          "$ref": "#/components/parameters/account_id"
        }
      ],
      "get": {
        "tags": [
          "account"
        ],
        "operationId": "get_account",
        "summary": "Fetch an account",
        "responses": {
          "200": {
            "description": "An account.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Account"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": [
          {
            "lang": "Node.js",
            "source": "try {\n  const account = await client.getAccount(accountId)\n  console.log('Fetched account: ', account.code)\n} catch (err) {\n  if (err instanceof recurly.errors.NotFoundError) {\n    // If the request was not found, you may want to alert the user or\n    // just return null\n    console.log('Resource Not Found')\n  } else {\n    // If we don't know what to do with the err, we should\n    // probably re-raise and let our web framework and logger handle it\n    console.log('Unknown Error: ', err)\n  }\n}\n"
          },
          {
            "lang": "Python",
            "source": "try:\n    account = client.get_account(account_id)\n    print(\"Got Account %s\" % account)\nexcept recurly.errors.NotFoundError:\n    # If the resource was not found, you may want to alert the user or\n    # just return nil\n    print(\"Resource Not Found\")\n"
          },
          {
            "lang": ".NET",
            "source": "try\n{\n    Account account = client.GetAccount(accountId);\n    Console.WriteLine($\"Fetched account {account.Code}\");\n}\ncatch (Recurly.Errors.NotFound ex)\n{\n    // If the resource was not found\n    // we may want to alert the user or just return null\n    Console.WriteLine($\"Resource Not Found: {ex.Error.Message}\");\n}\ncatch (Recurly.Errors.ApiError ex)\n{\n    // Use ApiError to catch a generic error from the API\n    Console.WriteLine($\"Unexpected Recurly Error: {ex.Error.Message}\");\n}\n"
          },
          {
            "lang": "Ruby",
            "source": "begin\n  account = @client.get_account(account_id: account_id)\n  puts \"Got Account #{account}\"\nrescue Recurly::Errors::NotFoundError\n  # If the resource was not found, you may want to alert the user or\n  # just return nil\n  puts \"Resource Not Found\"\nend\n"
          },
          {
            "lang": "Java",
            "source": "try {\n    final Account account = client.getAccount(accountId);\n    System.out.println(\"Fetched account: \" + account.getCode());\n} catch (NotFoundException e) {\n    // If the resource was not found\n    // we may want to alert the user or just return null\n    System.out.println(\"Resource Not Found: \" + e.getError().getMessage());\n} catch (ApiException e) {\n    // Use ApiException to catch a generic error from the API\n    System.out.println(\"Unexpected Recurly Error: \" + e.getError().getMessage());\n}\n"
          },
          {
            "lang": "PHP",
            "source": "try {\n    $account = $client->getAccount($account_id);\n\n    echo 'Got Account:' . PHP_EOL;\n    var_dump($account);\n} catch (\\Recurly\\Errors\\NotFound $e) {\n    // Could not find the resource, you may want to inform the user\n    // or just return a NULL\n    echo 'Could not find resource.' . PHP_EOL;\n    var_dump($e);\n} catch (\\Recurly\\RecurlyError $e) {\n    // Something bad happened... tell the user so that they can fix it?\n    echo 'Some unexpected Recurly error happened. Try again later.' . PHP_EOL;\n}\n"
          },
          {
            "lang": "Go",
            "source": "account, err := client.GetAccount(accountID)\nif e, ok := err.(*recurly.Error); ok {\n\tif e.Type == recurly.ErrorTypeNotFound {\n\t\tfmt.Printf(\"Resource not found: %v\", e)\n\t\treturn nil, err\n\t}\n\tfmt.Printf(\"Unexpected Recurly error: %v\", e)\n\treturn nil, err\n}\nfmt.Println(\"Fetched Account \", account.Id)"
          }
        ]
      },
      "put": {
        "tags": [
          "account"
        ],
        "operationId": "update_account",
        "summary": "Update an account",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AccountUpdate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "An account.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Account"
                }
              }
            }
          },
          "400": {
            "description": "Bad request, perhaps invalid JSON?",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site or account ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "422": {
            "description": "Invalid parameters or an error running the billing info verification transaction.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorMayHaveTransaction"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": [
          {
            "lang": "Node.js",
            "source": "try {\n  const accountUpdate = {\n    firstName: 'Aaron',\n    lastName: 'Du Monde'\n  }\n  const account = await client.updateAccount(accountId, accountUpdate)\n  console.log('Updated account: ', account)\n} catch (err) {\n  if (err instanceof recurly.errors.ValidationError) {\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in err.params\n    console.log('Failed validation', err.params)\n  } else {\n    // If we don't know what to do with the err, we should\n    // probably re-raise and let our web framework and logger handle it\n    console.log('Unknown Error: ', err)\n  }\n}\n"
          },
          {
            "lang": "Python",
            "source": "try:\n    account_update = {\"first_name\": \"Aaron\", \"last_name\": \"Du Monde\"}\n    account = client.update_account(account_id, account_update)\n    print(\"Updated Account %s\" % account)\nexcept recurly.errors.ValidationError as e:\n    # If the request was invalid, you may want to tell your user\n    # why. You can find the invalid params and reasons in e.error.params\n    print(\"ValidationError: %s\" % e.error.message)\n    print(e.error.params)\n"
          },
          {
            "lang": ".NET",
            "source": "try\n{\n    var accountReq = new AccountUpdate() {\n        FirstName = \"Aaron\",\n        LastName = \"Du Monde\"\n    };\n    Account account = client.UpdateAccount(accountId, accountReq);\n    Console.WriteLine(account.FirstName);\n    Console.WriteLine(account.LastName);\n}\ncatch (Recurly.Errors.Validation ex)\n{\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in ex.Error.Params\n    Console.WriteLine($\"Failed validation: {ex.Error.Message}\");\n}\ncatch (Recurly.Errors.ApiError ex)\n{\n    // Use ApiError to catch a generic error from the API\n    Console.WriteLine($\"Unexpected Recurly Error: {ex.Error.Message}\");\n}\n"
          },
          {
            "lang": "Ruby",
            "source": "begin\n  account_update = {\n    first_name: \"Aaron\",\n    last_name: \"Du Monde\",\n  }\n  account = @client.update_account(\n    account_id: account_id,\n    body: account_update\n  )\n  puts \"Updated Account #{account}\"\nrescue Recurly::Errors::ValidationError => e\n  # If the request was invalid, you may want to tell your user\n  # why. You can find the invalid params and reasons in e.recurly_error.params\n  puts \"ValidationError: #{e.recurly_error.params}\"\nend\n"
          },
          {
            "lang": "Java",
            "source": "try {\n    final AccountUpdate accountUpdate = new AccountUpdate();\n    accountUpdate.setFirstName(\"Aaron\");\n    accountUpdate.setLastName(\"Du Monde\");\n\n    final Account account = client.updateAccount(accountId, accountUpdate);\n    System.out.println(\"Updated account: \" + account.getCode());\n    System.out.println(account.getFirstName());\n    System.out.println(account.getLastName());\n} catch (ValidationException e) {\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in e.getError().getParams()\n    System.out.println(\"Failed validation: \" + e.getError().getMessage());\n} catch (ApiException e) {\n    // Use ApiException to catch a generic error from the API\n    System.out.println(\"Unexpected Recurly Error: \" + e.getError().getMessage());\n}\n"
          },
          {
            "lang": "PHP",
            "source": "try {\n    $account_update = [\n        \"first_name\" => \"Douglas\",\n        \"last_name\" => \"Du Monde\",\n    ];\n\n    $account = $client->updateAccount($account_id, $account_update);\n\n    echo 'Updated Account:' . PHP_EOL;\n    var_dump($account);\n} catch (\\Recurly\\Errors\\Validation $e) {\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in err.params\n    var_dump($e);\n} catch (\\Recurly\\RecurlyError $e) {\n    // If we don't know what to do with the err, we should\n    // probably re-raise and let our web framework and logger handle it\n    var_dump($e);\n}\n"
          },
          {
            "lang": "Go",
            "source": "updateReq := &recurly.AccountUpdate{\n\tFirstName: recurly.String(\"Joanna\"),\n\tLastName:  recurly.String(\"DuMonde\"),\n}\naccount, err := client.UpdateAccount(accountID, updateReq)\nif e, ok := err.(*recurly.Error); ok {\n\tif e.Type == recurly.ErrorTypeValidation {\n\t\tfmt.Printf(\"Failed validation: %v\", e)\n\t\treturn nil, err\n\t}\n\tfmt.Printf(\"Unexpected Recurly error: %v\", e)\n\treturn nil, err\n}\nfmt.Printf(\"Updated Account: %s\", account.Id)"
          }
        ]
      },
      "delete": {
        "tags": [
          "account"
        ],
        "operationId": "deactivate_account",
        "summary": "Deactivate an account",
        "description": "Deactivating an account permanently deletes its billing information and cancels any active subscriptions (canceled subscriptions will remain active until the end of the current billing cycle before expiring). We recommend closing accounts only when all business is concluded with a customer.",
        "responses": {
          "200": {
            "description": "An account.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Account"
                }
              }
            }
          },
          "422": {
            "description": "Account may already be inactive.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": [
          {
            "lang": "Node.js",
            "source": "try {\n  const account = await client.deactivateAccount(accountId)\n  console.log('Deleted account: ', account.code)\n} catch (err) {\n  if (err && err.type === 'not-found') {\n    // If the request was not found, you may want to alert the user or\n    // just return null\n    console.log('Resource Not Found')\n  }\n  // If we don't know what to do with the err, we should\n  // probably re-raise and let our web framework and logger handle it\n  throw err\n}\n"
          },
          {
            "lang": "Python",
            "source": "try:\n    account = client.deactivate_account(account_id)\n    print(\"Deactivated Account %s\" % account)\nexcept recurly.errors.NotFoundError:\n    # If the resource was not found, you may want to alert the user or\n    # just return nil\n    print(\"Resource Not Found\")\n"
          },
          {
            "lang": ".NET",
            "source": "try\n{\n    Account account = client.DeactivateAccount(accountId);\n    Console.WriteLine($\"Deactivated account {account.Code}\");\n}\ncatch (Recurly.Errors.Validation ex)\n{\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in ex.Error.Params\n    Console.WriteLine($\"Failed validation: {ex.Error.Message}\");\n}\ncatch (Recurly.Errors.ApiError ex)\n{\n    // Use ApiError to catch a generic error from the API\n    Console.WriteLine($\"Unexpected Recurly Error: {ex.Error.Message}\");\n}\n"
          },
          {
            "lang": "Ruby",
            "source": "begin\n  account = @client.deactivate_account(account_id: account_id)\n  puts \"Deactivated Account #{account}\"\nrescue Recurly::Errors::NotFoundError\n  # If the resource was not found, you may want to alert the user or\n  # just return nil\n  puts \"Resource Not Found\"\nend\n"
          },
          {
            "lang": "Java",
            "source": "try {\n    Account account = client.deactivateAccount(accountId);\n    System.out.println(\"deactivated account \" + account.getCode());\n} catch (ValidationException e) {\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in e.getError().getParams()\n    System.out.println(\"Failed validation: \" + e.getError().getMessage());\n} catch (ApiException e) {\n    // Use ApiException to catch a generic error from the API\n    System.out.println(\"Unexpected Recurly Error: \" + e.getError().getMessage());\n}\n"
          },
          {
            "lang": "PHP",
            "source": "try {\n    $account = $client->deactivateAccount($account_id);\n\n    echo 'Deactivated Account:' . PHP_EOL;\n    var_dump($account);\n} catch (\\Recurly\\Errors\\NotFound $e) {\n    // Could not find the resource, you may want to inform the user\n    // or just return a NULL\n    echo 'Could not find resource.' . PHP_EOL;\n    var_dump($e);\n} catch (\\Recurly\\RecurlyError $e) {\n    // Something bad happened... tell the user so that they can fix it?\n    echo 'Some unexpected Recurly error happened. Try again later.' . PHP_EOL;\n}\n"
          },
          {
            "lang": "Go",
            "source": "account, err := client.DeactivateAccount(accountID)\nif e, ok := err.(*recurly.Error); ok {\n\tif e.Type == recurly.ErrorTypeNotFound {\n\t\tfmt.Printf(\"Resource not found: %v\", e)\n\t\treturn nil, err\n\t}\n\tfmt.Printf(\"Unexpected Recurly error: %v\", e)\n\treturn nil, err\n}\nfmt.Printf(\"Deactivated Account: %s\", account.Id)"
          }
        ]
      }
    },
    "/accounts/{account_id}/acquisition": {
      "parameters": [
        {
          "$ref": "#/components/parameters/account_id"
        }
      ],
      "get": {
        "tags": [
          "account_acquisition"
        ],
        "operationId": "get_account_acquisition",
        "summary": "Fetch an account's acquisition data",
        "responses": {
          "200": {
            "description": "An account's acquisition data.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AccountAcquisition"
                }
              }
            }
          },
          "404": {
            "description": "Account has no acquisition data, or incorrect site or account ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": [
          {
            "lang": "Node.js",
            "source": "try {\n  const acquisition = await client.getAccountAcquisition(accountId)\n  console.log('Fetched account acquisition: ', acquisition.id)\n} catch (err) {\n  if (err instanceof recurly.errors.NotFoundError) {\n    // If the request was not found, you may want to alert the user or\n    // just return null\n    console.log('Resource Not Found')\n  } else {\n    // If we don't know what to do with the err, we should\n    // probably re-raise and let our web framework and logger handle it\n    console.log('Unknown Error: ', err)\n  }\n}\n"
          },
          {
            "lang": "Python",
            "source": "try:\n    acquisition = client.get_account_acquisition(account_id)\n    print(\"Got AccountAcquisition %s\" % acquisition)\nexcept recurly.errors.NotFoundError:\n    # If the resource was not found, you may want to alert the user or\n    # just return nil\n    print(\"Resource Not Found\")\n"
          },
          {
            "lang": ".NET",
            "source": "try\n{\n    AccountAcquisition acquisition = client.GetAccountAcquisition(accountId);\n    Console.WriteLine($\"Fetched account acquisition {acquisition.Id}\");\n}\ncatch (Recurly.Errors.NotFound ex)\n{\n    // If the resource was not found\n    // we may want to alert the user or just return null\n    Console.WriteLine($\"Resource Not Found: {ex.Error.Message}\");\n}\ncatch (Recurly.Errors.ApiError ex)\n{\n    // Use ApiError to catch a generic error from the API\n    Console.WriteLine($\"Unexpected Recurly Error: {ex.Error.Message}\");\n}\n"
          },
          {
            "lang": "Ruby",
            "source": "begin\n  @client.get_account_acquisition(account_id: account_id)\n  puts \"Got AccountAcquisition\"\nrescue Recurly::Errors::NotFoundError\n  # If the resource was not found, you may want to alert the user or\n  # just return nil\n  puts \"Resource Not Found\"\nend\n"
          },
          {
            "lang": "Java",
            "source": "try {\n    final AccountAcquisition acquisition = client.getAccountAcquisition(accountId);\n    System.out.println(\"Fetched account acquisition \" + acquisition.getId());\n} catch (NotFoundException e) {\n    // If the resource was not found\n    // we may want to alert the user or just return null\n    System.out.println(\"Resource Not Found: \" + e.getError().getMessage());\n} catch (ApiException e) {\n    // Use ApiException to catch a generic error from the API\n    System.out.println(\"Unexpected Recurly Error: \" + e.getError().getMessage());\n}\n"
          },
          {
            "lang": "PHP",
            "source": "try {\n    $acquisition = $client->getAccountAcquisition($account_id);\n\n    echo 'Got Account Acquisition:' . PHP_EOL;\n    var_dump($acquisition);\n} catch (\\Recurly\\Errors\\NotFound $e) {\n    // Could not find the resource, you may want to inform the user\n    // or just return a NULL\n    echo 'Could not find resource.' . PHP_EOL;\n    var_dump($e);\n} catch (\\Recurly\\RecurlyError $e) {\n    // Something bad happened... tell the user so that they can fix it?\n    echo 'Some unexpected Recurly error happened. Try again later.' . PHP_EOL;\n}\n"
          },
          {
            "lang": "Go",
            "source": "accountAcq, err := client.GetAccountAcquisition(accountID)\nif e, ok := err.(*recurly.Error); ok {\n\tif e.Type == recurly.ErrorTypeNotFound {\n\t\tfmt.Printf(\"Resource not found: %v\", e)\n\t\treturn nil, err\n\t}\n\tfmt.Printf(\"Unexpected Recurly error: %v\", e)\n\treturn nil, err\n}\nfmt.Printf(\"Fetched Account Acquisition: %v\", accountAcq.Id)"
          }
        ]
      },
      "put": {
        "tags": [
          "account_acquisition"
        ],
        "operationId": "update_account_acquisition",
        "summary": "Update an account's acquisition data",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AccountAcquisitionUpdate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "An account's updated acquisition data.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AccountAcquisition"
                }
              }
            }
          },
          "400": {
            "description": "Bad request; perhaps missing or invalid parameters.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site or account ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "422": {
            "description": "A validation error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": [
          {
            "lang": "Node.js",
            "source": "try {\n  const acquisitionUpdate = {\n    campaign: \"big-event-campaign\",\n    channel: \"social_media\",\n    subchannel: \"twitter\"\n  }\n  const accountAcquisition = await client.updateAccountAcquisition(accountId, acquisitionUpdate)\n  console.log('Edited Account Acquisition: ', accountAcquisition)\n} catch (err) {\n  if (err instanceof recurly.errors.ValidationError) {\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in err.params\n    console.log('Failed validation', err.params)\n  } else {\n    // If we don't know what to do with the err, we should\n    // probably re-raise and let our web framework and logger handle it\n    console.log('Unknown Error: ', err)\n  }\n}\n"
          },
          {
            "lang": "Python",
            "source": "try:\n    acquisition_update = {\n        \"campaign\": \"podcast-marketing\",\n        \"channel\": \"social_media\",\n        \"subchannel\": \"twitter\",\n        \"cost\": {\"currency\": \"USD\", \"amount\": 0.50},\n    }\n    acquisition = client.update_account_acquisition(account_id, acquisition_update)\n    print(\"Updated AccountAcquisition %s\" % acquisition)\nexcept recurly.errors.ValidationError as e:\n    # If the request was invalid, you may want to tell your user\n    # why. You can find the invalid params and reasons in e.error.params\n    print(\"ValidationError: %s\" % e.error.message)\n    print(e.error.params)\n"
          },
          {
            "lang": ".NET",
            "source": "try\n{\n    var acquisitionReq = new AccountAcquisitionUpdate()\n    {\n        Campaign = \"big-event-campaign\",\n        Channel = Channel.SocialMedia,\n        Subchannel = \"twitter\"\n    };\n    AccountAcquisition accountAcquisition = client.UpdateAccountAcquisition(accountId, acquisitionReq);\n    Console.WriteLine(accountAcquisition);\n}\ncatch (Recurly.Errors.Validation ex)\n{\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in ex.Error.Params\n    Console.WriteLine($\"Failed validation: {ex.Error.Message}\");\n}\ncatch (Recurly.Errors.ApiError ex)\n{\n    // Use ApiError to catch a generic error from the API\n    Console.WriteLine($\"Unexpected Recurly Error: {ex.Error.Message}\");\n}\n"
          },
          {
            "lang": "Ruby",
            "source": "begin\n  acquisition_update = {\n    campaign: \"podcast-marketing\",\n    channel: \"social_media\",\n    subchannel: \"twitter\",\n    cost: {\n      currency: \"USD\",\n      amount: 0.50\n    }\n  }\n  acquisition = @client.update_account_acquisition(\n    account_id: account_id,\n    body: acquisition_update\n  )\n  puts \"Updated AccountAcqusition #{acquisition}\"\nrescue Recurly::Errors::ValidationError => e\n  # If the request was invalid, you may want to tell your user\n  # why. You can find the invalid params and reasons in e.recurly_error.params\n  puts \"ValidationError: #{e.recurly_error.params}\"\nend\n"
          },
          {
            "lang": "Java",
            "source": "try {\n    final AccountAcquisitionUpdate acqUpdate = new AccountAcquisitionUpdate();\n    acqUpdate.setCampaign(\"big-event-campaign\");\n    acqUpdate.setChannel(Constants.Channel.SOCIAL_MEDIA);\n    acqUpdate.setSubchannel(\"twitter\");\n\n    final AccountAcquisition accountAcquisition = client.updateAccountAcquisition(accountId, acqUpdate);\n    System.out.println(accountAcquisition);\n} catch (ValidationException e) {\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in e.getError().getParams()\n    System.out.println(\"Failed validation: \" + e.getError().getMessage());\n} catch (ApiException e) {\n    // Use ApiException to catch a generic error from the API\n    System.out.println(\"Unexpected Recurly Error: \" + e.getError().getMessage());\n}\n"
          },
          {
            "lang": "PHP",
            "source": "try {\n    $acquisition_update = [\n        \"campaign\" => \"big-event-campaign\",\n        \"channel\" => \"social_media\",\n        \"subchannel\" => \"twitter\"\n    ];\n    $acquisition = $client->updateAccountAcquisition($account_id, $acquisition_update);\n\n    echo 'Updated AccountAcquisition:' . PHP_EOL;\n    var_dump($acquisition);\n} catch (\\Recurly\\Errors\\Validation $e) {\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in err.params\n    var_dump($e);\n} catch (\\Recurly\\RecurlyError $e) {\n    // If we don't know what to do with the err, we should\n    // probably re-raise and let our web framework and logger handle it\n    var_dump($e);\n}\n"
          },
          {
            "lang": "Go",
            "source": "updateReq := &recurly.AccountAcquisitionUpdate{\n\tCampaign:   recurly.String(\"big-event-campaign\"),\n\tChannel:    recurly.String(\"social_media\"),\n\tSubchannel: recurly.String(\"twitter\"),\n}\naccount, err := client.UpdateAccountAcquisition(accountID, updateReq)\nif e, ok := err.(*recurly.Error); ok {\n\tif e.Type == recurly.ErrorTypeValidation {\n\t\tfmt.Printf(\"Failed validation: %v\", e)\n\t\treturn nil, err\n\t}\n\tfmt.Printf(\"Unexpected Recurly error: %v\", e)\n\treturn nil, err\n}\nfmt.Printf(\"Updated Account Acquisition: %s\", account.Id)"
          }
        ]
      },
      "delete": {
        "tags": [
          "account_acquisition"
        ],
        "operationId": "remove_account_acquisition",
        "summary": "Remove an account's acquisition data",
        "responses": {
          "204": {
            "description": "Acquisition data was succesfully deleted."
          },
          "404": {
            "description": "Incorrect site or account ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": [
          {
            "lang": "Node.js",
            "source": "try {\n  await client.removeAccountAcquisition(accountId)\n  console.log('Removed account acquisition from account: ', accountId)\n} catch (err) {\n  if (err instanceof recurly.errors.NotFoundError) {\n    // If the request was not found, you may want to alert the user or\n    // just return null\n    console.log('Resource Not Found')\n  } else {\n    // If we don't know what to do with the err, we should\n    // probably re-raise and let our web framework and logger handle it\n    console.log('Unknown Error: ', err)\n  }\n}\n"
          },
          {
            "lang": "Python",
            "source": "try:\n    client.remove_account_acquisition(account_id)\n    print(\"Removed AccountAcquisition for Account id=%s\" % account_id)\nexcept recurly.errors.NotFoundError:\n    # If the resource was not found, you may want to alert the user or\n    # just return nil\n    print(\"Resource Not Found\")\n"
          },
          {
            "lang": ".NET",
            "source": "try\n{\n    client.RemoveAccountAcquisition(accountId);\n    Console.WriteLine($\"Removed account acquisition from account {accountId}\");\n}\ncatch (Recurly.Errors.Validation ex)\n{\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in ex.Error.Params\n    Console.WriteLine($\"Failed validation: {ex.Error.Message}\");\n}\ncatch (Recurly.Errors.ApiError ex)\n{\n    // Use ApiError to catch a generic error from the API\n    Console.WriteLine($\"Unexpected Recurly Error: {ex.Error.Message}\");\n}\n"
          },
          {
            "lang": "Ruby",
            "source": "begin\n  acquisition = @client.remove_account_acquisition(account_id: account_id)\n  puts \"Removed AccountAcqusition #{acquisition}\"\nrescue Recurly::Errors::NotFoundError\n  # If the resource was not found, you may want to alert the user or\n  # just return nil\n  puts \"Resource Not Found\"\nend\n"
          },
          {
            "lang": "Java",
            "source": "try {\n    client.removeAccountAcquisition(accountId);\n    System.out.println(\"Removed account acquisition from account \" + accountId);\n} catch (ValidationException e) {\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in e.getError().getParams()\n    System.out.println(\"Failed validation: \" + e.getError().getMessage());\n} catch (ApiException e) {\n    // Use ApiException to catch a generic error from the API\n    System.out.println(\"Unexpected Recurly Error: \" + e.getError().getMessage());\n}\n"
          },
          {
            "lang": "PHP",
            "source": "try {\n    $client->removeAccountAcquisition($account_id);\n    echo \"Removed Account Acquisition:\" . PHP_EOL;\n} catch (\\Recurly\\Errors\\Validation $e) {\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in err.params\n    var_dump($e);\n} catch (\\Recurly\\RecurlyError $e) {\n    // If we don't know what to do with the err, we should\n    // probably re-raise and let our web framework and logger handle it\n    var_dump($e);\n}"
          },
          {
            "lang": "Go",
            "source": "client.RemoveAccountAcquisition(accountID)\nif e, ok := err.(*recurly.Error); ok {\n\tif e.Type == recurly.ErrorTypeNotFound {\n\t\tfmt.Printf(\"Resource not found: %v\", e)\n\t\treturn nil, err\n\t}\n\tfmt.Printf(\"Unexpected Recurly error: %v\", e)\n\treturn nil, err\n}\nfmt.Printf(\"Removed Account Acquisition: %s\", accountAcquisition.Id)"
          }
        ]
      }
    },
    "/accounts/{account_id}/reactivate": {
      "parameters": [
        {
          "$ref": "#/components/parameters/account_id"
        }
      ],
      "put": {
        "tags": [
          "account"
        ],
        "operationId": "reactivate_account",
        "summary": "Reactivate an inactive account",
        "description": "Reactivating an account will restore its history but the customer will need to provide new billing information to continue billing.",
        "responses": {
          "200": {
            "description": "An account.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Account"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site or account ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "422": {
            "description": "Account is already active.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": [
          {
            "lang": "Node.js",
            "source": "try {\n  const account = await client.reactivateAccount(accountId)\n  console.log('Reactivated account: ', account.code)\n} catch (err) {\n  if (err && err.type === 'not_found') {\n    // If the request was not found, you may want to alert the user or\n    // just return null\n    console.log('Resource Not Found')\n  }\n  // If we don't know what to do with the err, we should\n  // probably re-raise and let our web framework and logger handle it\n  throw err\n}\n"
          },
          {
            "lang": "Python",
            "source": "try:\n    account = client.reactivate_account(account_id)\n    print(\"Reactivated Account %s\" % account)\nexcept recurly.errors.NotFoundError:\n    # If the resource was not found, you may want to alert the user or\n    # just return nil\n    print(\"Resource Not Found\")\n"
          },
          {
            "lang": ".NET",
            "source": "try\n{\n    Account account = client.ReactivateAccount(accountId);\n    Console.WriteLine($\"Reactivated account {account.Code}\");\n}\ncatch (Recurly.Errors.Validation ex)\n{\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in ex.Error.Params\n    Console.WriteLine($\"Failed validation: {ex.Error.Message}\");\n}\ncatch (Recurly.Errors.ApiError ex)\n{\n    // Use ApiError to catch a generic error from the API\n    Console.WriteLine($\"Unexpected Recurly Error: {ex.Error.Message}\");\n}\n"
          },
          {
            "lang": "Ruby",
            "source": "begin\n  account = @client.reactivate_account(account_id: account_id)\n  puts \"Reactivated account #{account}\"\nrescue Recurly::Errors::NotFoundError\n  # If the resource was not found, you may want to alert the user or\n  # just return nil\n  puts \"Resource Not Found\"\nend\n"
          },
          {
            "lang": "Java",
            "source": "try {\n    final Account account = client.reactivateAccount(accountId);\n    System.out.println(\"Reactivated account: \" + account.getCode());\n} catch (ValidationException e) {\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in e.getError().getParams()\n    System.out.println(\"Failed validation: \" + e.getError().getMessage());\n} catch (ApiException e) {\n    // Use ApiException to catch a generic error from the API\n    System.out.println(\"Unexpected Recurly Error: \" + e.getError().getMessage());\n}\n"
          },
          {
            "lang": "PHP",
            "source": "try {\n    $account = $client->reactivateAccount($account_id);\n\n    echo 'Reactivated Account:' . PHP_EOL;\n    var_dump($account);\n} catch (\\Recurly\\Errors\\NotFound $e) {\n    // Could not find the resource, you may want to inform the user\n    // or just return a NULL\n    echo 'Could not find resource.' . PHP_EOL;\n    var_dump($e);\n} catch (\\Recurly\\RecurlyError $e) {\n    // Something bad happened... tell the user so that they can fix it?\n    echo 'Some unexpected Recurly error happened. Try again later.' . PHP_EOL;\n}\n"
          },
          {
            "lang": "Go",
            "source": "account, err := client.ReactivateAccount(accountID)\nif e, ok := err.(*recurly.Error); ok {\n\tif e.Type == recurly.ErrorTypeValidation {\n\t\tfmt.Printf(\"Failed validation: %v\", e)\n\t\treturn nil, err\n\t}\n\tfmt.Printf(\"Unexpected Recurly error: %v\", e)\n\treturn nil, err\n}\nfmt.Printf(\"Reactivated Account: %s\", account.Id)"
          }
        ]
      }
    },
    "/accounts/{account_id}/balance": {
      "parameters": [
        {
          "$ref": "#/components/parameters/account_id"
        }
      ],
      "get": {
        "tags": [
          "account"
        ],
        "operationId": "get_account_balance",
        "summary": "Fetch an account's balance and past due status",
        "responses": {
          "200": {
            "description": "An account's balance.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AccountBalance"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site or account ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": [
          {
            "lang": "Node.js",
            "source": "try {\n  const balance = await client.getAccountBalance(accountId)\n  console.log('Fetched account balance: ', balance.balances)\n} catch (err) {\n  if (err instanceof recurly.errors.NotFoundError) {\n    // If the request was not found, you may want to alert the user or\n    // just return null\n    console.log('Resource Not Found')\n  } else {\n    // If we don't know what to do with the err, we should\n    // probably re-raise and let our web framework and logger handle it\n    console.log('Unknown Error: ', err)\n  }\n}\n"
          },
          {
            "lang": "Python",
            "source": "try:\n    balance = client.get_account_balance(account_id)\n    print(\"Got AccountBalance %s\" % balance)\nexcept recurly.errors.NotFoundError:\n    # If the resource was not found, you may want to alert the user or\n    # just return nil\n    print(\"Resource Not Found\")\n"
          },
          {
            "lang": ".NET",
            "source": "try\n{\n    AccountBalance balance = client.GetAccountBalance(accountId);\n    Console.WriteLine($\"Fetched account balance {balance.Balances}\");\n}\ncatch (Recurly.Errors.NotFound ex)\n{\n    // If the resource was not found\n    // we may want to alert the user or just return null\n    Console.WriteLine($\"Resource Not Found: {ex.Error.Message}\");\n}\ncatch (Recurly.Errors.ApiError ex)\n{\n    // Use ApiError to catch a generic error from the API\n    Console.WriteLine($\"Unexpected Recurly Error: {ex.Error.Message}\");\n}\n"
          },
          {
            "lang": "Ruby",
            "source": "begin\n  balance = @client.get_account_balance(account_id: account_id)\n  puts \"Got AccountBalance #{balance}\"\nrescue Recurly::Errors::NotFoundError\n  # If the resource was not found, you may want to alert the user or\n  # just return nil\n  puts \"Resource Not Found\"\nend\n"
          },
          {
            "lang": "Java",
            "source": "try {\n    final AccountBalance balance = client.getAccountBalance(accountId);\n    System.out.println(\"Fetched account balance \" + balance.getBalances());\n} catch (NotFoundException e) {\n    // If the resource was not found\n    // we may want to alert the user or just return null\n    System.out.println(\"Resource Not Found: \" + e.getError().getMessage());\n} catch (ApiException e) {\n    // Use ApiException to catch a generic error from the API\n    System.out.println(\"Unexpected Recurly Error: \" + e.getError().getMessage());\n}\n"
          },
          {
            "lang": "PHP",
            "source": "try {\n    $balance = $client->getAccountBalance($account_id);\n\n    echo 'Got Account Balance:' . PHP_EOL;\n    var_dump($balance);\n} catch (\\Recurly\\Errors\\NotFound $e) {\n    // Could not find the resource, you may want to inform the user\n    // or just return a NULL\n    echo 'Could not find resource.' . PHP_EOL;\n    var_dump($e);\n} catch (\\Recurly\\RecurlyError $e) {\n    // Something bad happened... tell the user so that they can fix it?\n    echo 'Some unexpected Recurly error happened. Try again later.' . PHP_EOL;\n}\n"
          },
          {
            "lang": "Go",
            "source": "accountBalance, err := client.GetAccountBalance(accountID)\nif e, ok := err.(*recurly.Error); ok {\n\tif e.Type == recurly.ErrorTypeNotFound {\n\t\tfmt.Printf(\"Resource not found: %v\", e)\n\t\treturn nil, err\n\t}\n\tfmt.Printf(\"Unexpected Recurly error: %v\", e)\n\treturn nil, err\n}\nfmt.Printf(\"Fetched Account Balance: %v\", accountBalance)"
          }
        ]
      }
    },
    "/accounts/{account_id}/billing_info": {
      "get": {
        "tags": [
          "billing_info"
        ],
        "operationId": "get_billing_info",
        "summary": "Fetch an account's billing information",
        "parameters": [
          {
            "$ref": "#/components/parameters/account_id"
          }
        ],
        "responses": {
          "200": {
            "description": "An account's billing information.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BillingInfo"
                }
              }
            }
          },
          "404": {
            "description": "Account has no billing information, or incorrect site or account ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": [
          {
            "lang": "Node.js",
            "source": "try {\n  const billingInfo = await client.getBillingInfo(accountId)\n  console.log('Fetched Billing Info: ', billingInfo.id)\n} catch (err) {\n  if (err instanceof recurly.errors.NotFoundError) {\n    // If the request was not found, you may want to alert the user or\n    // just return null\n    console.log('Resource Not Found')\n  } else {\n    // If we don't know what to do with the err, we should\n    // probably re-raise and let our web framework and logger handle it\n    console.log('Unknown Error: ', err)\n  }\n}\n"
          },
          {
            "lang": "Python",
            "source": "try:\n    binfo = client.get_billing_info(account_id)\n    print(\"Got BillingInfo %s\" % binfo)\nexcept recurly.errors.NotFoundError:\n    # If the resource was not found, you may want to alert the user or\n    # just return nil\n    print(\"Resource Not Found\")\n"
          },
          {
            "lang": ".NET",
            "source": "try\n{\n    BillingInfo billingInfo = client.GetBillingInfo(accountId);\n    Console.WriteLine($\"Fetched billing info {billingInfo.Id}\");\n}\ncatch (Recurly.Errors.NotFound ex)\n{\n    // If the resource was not found\n    // we may want to alert the user or just return null\n    Console.WriteLine($\"Resource Not Found: {ex.Error.Message}\");\n}\ncatch (Recurly.Errors.ApiError ex)\n{\n    // Use ApiError to catch a generic error from the API\n    Console.WriteLine($\"Unexpected Recurly Error: {ex.Error.Message}\");\n}\n"
          },
          {
            "lang": "Ruby",
            "source": "begin\n  billing = @client.get_billing_info(account_id: account_id)\n  puts \"Got BillingInfo #{billing}\"\nrescue Recurly::Errors::NotFoundError\n  # If the resource was not found, you may want to alert the user or\n  # just return nil\n  puts \"Resource Not Found\"\nend\n"
          },
          {
            "lang": "Java",
            "source": "try {\n    final BillingInfo billingInfo = client.getBillingInfo(accountId);\n    System.out.println(\"Fetched billing info \" + billingInfo.getId());\n} catch (NotFoundException e) {\n    // If the resource was not found\n    // we may want to alert the user or just return null\n    System.out.println(\"Resource Not Found: \" + e.getError().getMessage());\n} catch (ApiException e) {\n    // Use ApiException to catch a generic error from the API\n    System.out.println(\"Unexpected Recurly Error: \" + e.getError().getMessage());\n}\n"
          },
          {
            "lang": "PHP",
            "source": "try {\n    $binfo = $client->getBillingInfo($account_id);\n\n    echo 'Got BillingInfo:' . PHP_EOL;\n    var_dump($binfo);\n} catch (\\Recurly\\Errors\\NotFound $e) {\n    // Could not find the resource, you may want to inform the user\n    // or just return a NULL\n    echo 'Could not find resource.' . PHP_EOL;\n    var_dump($e);\n} catch (\\Recurly\\RecurlyError $e) {\n    // Something bad happened... tell the user so that they can fix it?\n    echo 'Some unexpected Recurly error happened. Try again later.' . PHP_EOL;\n}\n"
          },
          {
            "lang": "Go",
            "source": "billingInfo, err := client.GetBillingInfo(accountID)\nif e, ok := err.(*recurly.Error); ok {\n\tif e.Type == recurly.ErrorTypeNotFound {\n\t\tfmt.Printf(\"Resource not found: %v\", e)\n\t\treturn nil, err\n\t}\n\tfmt.Printf(\"Unexpected Recurly error: %v\", e)\n\treturn nil, err\n}\n\nfmt.Printf(\"Fetched Billing Info: %v\", billingInfo)"
          }
        ]
      },
      "put": {
        "tags": [
          "billing_info"
        ],
        "operationId": "update_billing_info",
        "summary": "Set an account's billing information",
        "description": "If you're using Recurly.js to securely submit data from webforms without sending it through your server,\nyou can associate the billing information with an account by passing in the `token_id`. The only other\nfields permitted with `token_id` are `primary_payment_method` and/or `backup_payment_method`.\n\nFor credit card payments you'll need the following required fields:\n\n- first_name\n- last_name\n- number\n- month\n- year\n\nFor external (not Recurly.js) tokenized payments you'll need the following required fields:\n\n- first_name\n- last_name\n- gateway_token\n- gateway_code\n",
        "parameters": [
          {
            "$ref": "#/components/parameters/account_id"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/BillingInfoCreate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Updated billing information.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BillingInfo"
                }
              }
            }
          },
          "400": {
            "description": "Bad request, perhaps invalid JSON?",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site or account ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "422": {
            "description": "Invalid billing information, or error running the verification transaction.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorMayHaveTransaction"
                }
              }
            }
          }
        },
        "x-code-samples": [
          {
            "lang": "Node.js",
            "source": "try {\n  const billingInfoUpdate = {\n    firstName: 'Aaron',\n    lastName: 'Du Monde',\n  }\n  const billingInfo = await client.updateBillingInfo(accountId, billingInfoUpdate)\n  console.log('Updated billing info: ', billingInfo.id)\n} catch (err) {\n  if (err instanceof recurly.errors.ValidationError) {\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in err.params\n    console.log('Failed validation', err.params)\n  } else {\n    // If we don't know what to do with the err, we should\n    // probably re-raise and let our web framework and logger handle it\n    console.log('Unknown Error: ', err)\n  }\n}\n"
          },
          {
            "lang": "Python",
            "source": "try:\n    billing_update = {\"first_name\": \"Aaron\", \"last_name\": \"Du Monde\"}\n    billing = client.update_billing_info(account_id, billing_update)\n    print(\"Updated BillingInfo %s\" % billing)\nexcept recurly.errors.ValidationError as e:\n    # If the request was invalid, you may want to tell your user\n    # why. You can find the invalid params and reasons in e.error.params\n    print(\"ValidationError: %s\" % e.error.message)\n    print(e.error.params)\n"
          },
          {
            "lang": ".NET",
            "source": "try\n{\n    var billingReq = new BillingInfoCreate() {\n        FirstName = \"Benjamin\",\n        LastName = \"Du Monde\"\n    };\n    BillingInfo billingInfo = client.UpdateBillingInfo(accountId, billingReq);\n    Console.WriteLine($\"Updated billing info {billingInfo.Id}\");\n}\ncatch (Recurly.Errors.Validation ex)\n{\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in ex.Error.Params\n    Console.WriteLine($\"Failed validation: {ex.Error.Message}\");\n}\ncatch (Recurly.Errors.ApiError ex)\n{\n    // Use ApiError to catch a generic error from the API\n    Console.WriteLine($\"Unexpected Recurly Error: {ex.Error.Message}\");\n}\n"
          },
          {
            "lang": "Ruby",
            "source": "begin\n  billing_update = {\n    first_name: \"Aaron\",\n    last_name: \"Du Monde\",\n  }\n  billing = @client.update_billing_info(\n    account_id: account_id,\n    body: billing_update\n  )\n  puts \"Updated BillingInfo #{billing}\"\nrescue Recurly::Errors::ValidationError => e\n  # If the request was invalid, you may want to tell your user\n  # why. You can find the invalid params and reasons in e.recurly_error.params\n  puts \"ValidationError: #{e.recurly_error.params}\"\nend\n"
          },
          {
            "lang": "Java",
            "source": "try {\n    final BillingInfoCreate billingUpdate = new BillingInfoCreate();\n    billingUpdate.setFirstName(\"Aaron\");\n    billingUpdate.setLastName(\"Du Monde\");\n\n    final BillingInfo billingInfo = client.updateBillingInfo(accountId, billingUpdate);\n    System.out.println(\"Updated billing info \" + billingInfo.getId());\n} catch (ValidationException e) {\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in e.getError().getParams()\n    System.out.println(\"Failed validation: \" + e.getError().getMessage());\n} catch (ApiException e) {\n    // Use ApiException to catch a generic error from the API\n    System.out.println(\"Unexpected Recurly Error: \" + e.getError().getMessage());\n}\n"
          },
          {
            "lang": "PHP",
            "source": "try {\n    $binfo_update = [\n        \"first_name\" => \"Douglas\",\n        \"last_name\" => \"Du Monde\",\n    ];\n    $binfo = $client->updateBillingInfo($account_id, $binfo_update);\n\n    echo 'Updated BillingInfo:' . PHP_EOL;\n    var_dump($binfo);\n} catch (\\Recurly\\Errors\\Validation $e) {\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in err.params\n    var_dump($e);\n} catch (\\Recurly\\RecurlyError $e) {\n    // If we don't know what to do with the err, we should\n    // probably re-raise and let our web framework and logger handle it\n    var_dump($e);\n}\n"
          },
          {
            "lang": "Go",
            "source": "updateReq := &recurly.BillingInfoCreate{\n\tFirstName: recurly.String(\"Joanna\"),\n\tLastName:  recurly.String(\"DuMonde\"),\n}\nbillingInfo, err := client.UpdateBillingInfo(accountID, updateReq)\nif e, ok := err.(*recurly.Error); ok {\n\tif e.Type == recurly.ErrorTypeValidation {\n\t\tfmt.Printf(\"Failed validation: %v\", e)\n\t\treturn nil, err\n\t}\n\tfmt.Printf(\"Unexpected Recurly error: %v\", e)\n\treturn nil, err\n}\nfmt.Printf(\"Updated Billing Info: %s\", billingInfo)"
          }
        ]
      },
      "delete": {
        "tags": [
          "billing_info"
        ],
        "operationId": "remove_billing_info",
        "summary": "Remove an account's billing information",
        "parameters": [
          {
            "$ref": "#/components/parameters/account_id"
          }
        ],
        "description": "You may remove any stored billing information for an account. If the account has a subscription, the renewal will go into dunning unless the billing information is updated before the renewal occurs.",
        "responses": {
          "204": {
            "description": "Billing information deleted"
          },
          "404": {
            "description": "Account has no billing information, or incorrect site or account ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": [
          {
            "lang": "Node.js",
            "source": "try {\n  client.removeBillingInfo(accountId)\n  console.log('Removed billing info from account: ', accountId)\n} catch (err) {\n  if (err instanceof recurly.errors.NotFoundError) {\n    // If the request was not found, you may want to alert the user or\n    // just return null\n    console.log('Resource Not Found')\n  } else {\n    // If we don't know what to do with the err, we should\n    // probably re-raise and let our web framework and logger handle it\n    console.log('Unknown Error: ', err)\n  }\n}\n"
          },
          {
            "lang": "Python",
            "source": "try:\n    client.remove_billing_info(account_id)\n    print(\"Removed BillingInfo for Account id=%s\" % account_id)\nexcept recurly.errors.NotFoundError:\n    # If the resource was not found, you may want to alert the user or\n    # just return nil\n    print(\"Resource Not Found\")\n"
          },
          {
            "lang": ".NET",
            "source": "try\n{\n    client.RemoveBillingInfo(accountId);\n    Console.WriteLine($\"Removed billing info from account {accountId}\");\n}\ncatch (Recurly.Errors.Validation ex)\n{\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in ex.Error.Params\n    Console.WriteLine($\"Failed validation: {ex.Error.Message}\");\n}\ncatch (Recurly.Errors.ApiError ex)\n{\n    // Use ApiError to catch a generic error from the API\n    Console.WriteLine($\"Unexpected Recurly Error: {ex.Error.Message}\");\n}\n"
          },
          {
            "lang": "Ruby",
            "source": "begin\n  @client.remove_billing_info(account_id: account_id)\n  puts \"Removed BillingInfo #{account_id}\"\nrescue Recurly::Errors::NotFoundError\n  # If the resource was not found, you may want to alert the user or\n  # just return nil\n  puts \"Resource Not Found\"\nend\n"
          },
          {
            "lang": "Java",
            "source": "try {\n    client.removeBillingInfo(accountId);\n    System.out.println(\"Removed billing info from account \" + accountId);\n} catch (ValidationException e) {\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in e.getError().getParams()\n    System.out.println(\"Failed validation: \" + e.getError().getMessage());\n} catch (ApiException e) {\n    // Use ApiException to catch a generic error from the API\n    System.out.println(\"Unexpected Recurly Error: \" + e.getError().getMessage());\n}\n"
          },
          {
            "lang": "PHP",
            "source": "try {\n    $client->removeBillingInfo($account_id);\n    echo \"Removed Billing Info: \" . $account_id . PHP_EOL;\n} catch (\\Recurly\\Errors\\Validation $e) {\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in err.params\n    var_dump($e);\n} catch (\\Recurly\\RecurlyError $e) {\n    // If we don't know what to do with the err, we should\n    // probably re-raise and let our web framework and logger handle it\n    var_dump($e);\n}"
          },
          {
            "lang": "Go",
            "source": "billingInfo, err := client.RemoveBillingInfo(accountID)\nif e, ok := err.(*recurly.Error); ok {\n\tif e.Type == recurly.ErrorTypeNotFound {\n\t\tfmt.Printf(\"Resource not found: %v\", e)\n\t\treturn nil, err\n\t}\n\tfmt.Printf(\"Unexpected Recurly error: %v\", e)\n\treturn nil, err\n}\n\nfmt.Printf(\"Removed Billing Info: %v\", billingInfo)"
          }
        ]
      }
    },
    "/accounts/{account_id}/billing_info/verify": {
      "post": {
        "tags": [
          "billing_info"
        ],
        "operationId": "verify_billing_info",
        "summary": "Verify an account's credit card billing information",
        "parameters": [
          {
            "$ref": "#/components/parameters/account_id"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/BillingInfoVerify"
              }
            }
          },
          "required": false
        },
        "responses": {
          "200": {
            "description": "Transaction information from verify.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Transaction"
                }
              }
            }
          },
          "404": {
            "description": "Account has no billing information, or incorrect site or account ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "422": {
            "description": "Invalid billing information, or error running the verification transaction.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorMayHaveTransaction"
                }
              }
            }
          }
        },
        "x-code-samples": [
          {
            "lang": "Node.js",
            "source": "try {\n  const transaction = await client.verifyBillingInfo(accountId)\n  console.log('Fetched Transaction: ', transaction.id)\n} catch (err) {\n  if (err instanceof recurly.errors.NotFoundError) {\n    // If the request was not found, you may want to alert the user or\n    // just return null\n    console.log('Resource Not Found')\n  } else {\n    // If we don't know what to do with the err, we should\n    // probably re-raise and let our web framework and logger handle it\n    console.log('Unknown Error: ', err)\n  }\n}\n"
          },
          {
            "lang": "Python",
            "source": "try:\n    transaction = client.verify_billing_info(account_id)\n    print(\"Got Transaction %s\" % transaction)\nexcept recurly.errors.NotFoundError:\n    # If the resource was not found, you may want to alert the user or\n    # just return nil\n    print(\"Resource Not Found\")\n"
          },
          {
            "lang": ".NET",
            "source": "try\n{\n    Transaction transaction = client.VerifyBillingInfo(accountId);\n    Console.WriteLine($\"Fetched transaction {transaction.Id}\");\n}\ncatch (Recurly.Errors.NotFound ex)\n{\n    // If the resource was not found\n    // we may want to alert the user or just return null\n    Console.WriteLine($\"Resource Not Found: {ex.Error.Message}\");\n}\ncatch (Recurly.Errors.ApiError ex)\n{\n    // Use ApiError to catch a generic error from the API\n    Console.WriteLine($\"Unexpected Recurly Error: {ex.Error.Message}\");\n}\n"
          },
          {
            "lang": "Ruby",
            "source": "begin\n  transaction = @client.verify_billing_info(account_id: account_id)\n  puts \"Got Transaction #{transaction}\"\nrescue Recurly::Errors::NotFoundError\n  # If the resource was not found, you may want to alert the user or\n  # just return nil\n  puts \"Resource Not Found\"\nend\n"
          },
          {
            "lang": "Java",
            "source": "try {\n    final Transaction transaction = client.verifyBillingInfo(accountId);\n    System.out.println(\"Fetched transaction \" + transaction.getId());\n} catch (NotFoundException e) {\n    // If the resource was not found\n    // we may want to alert the user or just return null\n    System.out.println(\"Resource Not Found: \" + e.getError().getMessage());\n} catch (ApiException e) {\n    // Use ApiException to catch a generic error from the API\n    System.out.println(\"Unexpected Recurly Error: \" + e.getError().getMessage());\n}\n"
          },
          {
            "lang": "PHP",
            "source": "try {\n    $transaction = $client->verifyBillingInfo($account_id);\n\n    echo 'Got Transaction:' . PHP_EOL;\n    var_dump($transaction);\n} catch (\\Recurly\\Errors\\NotFound $e) {\n    // Could not find the resource, you may want to inform the user\n    // or just return a NULL\n    echo 'Could not find resource.' . PHP_EOL;\n    var_dump($e);\n} catch (\\Recurly\\RecurlyError $e) {\n    // Something bad happened... tell the user so that they can fix it?\n    echo 'Some unexpected Recurly error happened. Try again later.' . PHP_EOL;\n}\n"
          },
          {
            "lang": "Go",
            "source": "verifyBillingInfoParams := &recurly.VerifyBillingInfoParams{}\ntransaction, err := client.VerifyBillingInfo(accountID, verifyBillingInfoParams)\nif e, ok := err.(*recurly.Error); ok {\n\tif e.Type == recurly.ErrorTypeNotFound {\n\t\tfmt.Printf(\"Resource not found: %v\", e)\n\t\treturn nil, err\n\t}\n\tfmt.Printf(\"Unexpected Recurly error: %v\", e)\n\treturn nil, err\n}\n\nfmt.Printf(\"Fetched Transaction: %v\", transaction)"
          }
        ]
      }
    },
    "/accounts/{account_id}/billing_info/verify_cvv": {
      "post": {
        "tags": [
          "billing_info"
        ],
        "operationId": "verify_billing_info_cvv",
        "summary": "Verify an account's credit card billing cvv",
        "parameters": [
          {
            "$ref": "#/components/parameters/account_id"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/BillingInfoVerifyCVV"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Transaction information from verify.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Transaction"
                }
              }
            }
          },
          "429": {
            "description": "Over limit error. A credit card can only be checked 3 times in 24 hours.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "422": {
            "description": "Invalid billing information, or error running the verification transaction.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorMayHaveTransaction"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": []
      }
    },
    "/accounts/{account_id}/billing_infos": {
      "get": {
        "tags": [
          "billing_infos"
        ],
        "operationId": "list_billing_infos",
        "summary": "Get the list of billing information associated with an account",
        "description": "See the [Pagination Guide](/developers/guides/pagination.html) to learn how to use pagination in the API and Client Libraries.",
        "parameters": [
          {
            "$ref": "#/components/parameters/account_id"
          },
          {
            "$ref": "#/components/parameters/ids"
          },
          {
            "$ref": "#/components/parameters/sort_dates"
          },
          {
            "$ref": "#/components/parameters/filter_begin_time"
          },
          {
            "$ref": "#/components/parameters/filter_end_time"
          }
        ],
        "responses": {
          "200": {
            "description": "A list of the the billing information for an account's",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BillingInfoList"
                }
              }
            }
          },
          "400": {
            "description": "Invalid or unpermitted parameter",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site or account",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": []
      },
      "post": {
        "tags": [
          "billing_infos"
        ],
        "operationId": "create_billing_info",
        "summary": "Add new billing information on an account",
        "description": "If you're using Recurly.js to securely submit data from webforms without sending it through your server,\nyou can associate the billing information with an account by passing in the `token_id`. The only other\nfields permitted with `token_id` are `primary_payment_method` and/or `backup_payment_method`.\n\nFor credit card payments you'll need the following required fields:\n\n- first_name\n- last_name\n- number\n- month\n- year\n\nFor external (not Recurly.js) tokenized payments you'll need the following required fields:\n\n- first_name\n- last_name\n- gateway_token\n- gateway_code\n",
        "parameters": [
          {
            "$ref": "#/components/parameters/account_id"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/BillingInfoCreate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Updated billing information.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BillingInfo"
                }
              }
            }
          },
          "400": {
            "description": "Bad request, perhaps invalid JSON?",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site or account ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "422": {
            "description": "Invalid billing information, or error running the verification transaction.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorMayHaveTransaction"
                }
              }
            }
          }
        },
        "x-code-samples": []
      }
    },
    "/accounts/{account_id}/billing_infos/{billing_info_id}": {
      "get": {
        "tags": [
          "billing_infos"
        ],
        "operationId": "get_a_billing_info",
        "summary": "Fetch a billing info",
        "parameters": [
          {
            "$ref": "#/components/parameters/account_id"
          },
          {
            "$ref": "#/components/parameters/billing_info_id"
          }
        ],
        "responses": {
          "200": {
            "description": "A billing info.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BillingInfo"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site, account, or billing info ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": []
      },
      "put": {
        "tags": [
          "billing_infos"
        ],
        "operationId": "update_a_billing_info",
        "summary": "Update an account's billing information",
        "description": "If you're using Recurly.js to securely submit data from webforms without sending it through your server,\nyou can associate the billing information with an account by passing in the `token_id`. The only other\nfields permitted with `token_id` are `primary_payment_method` and/or `backup_payment_method`.\n\nFor credit card payments you'll need the following required fields:\n\n- first_name\n- last_name\n- number\n- month\n- year\n\nFor external (not Recurly.js) tokenized payments you'll need the following required fields:\n\n- first_name\n- last_name\n- gateway_token\n- gateway_code\n",
        "parameters": [
          {
            "$ref": "#/components/parameters/account_id"
          },
          {
            "$ref": "#/components/parameters/billing_info_id"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/BillingInfoCreate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Updated billing information.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BillingInfo"
                }
              }
            }
          },
          "400": {
            "description": "Bad request, perhaps invalid JSON?",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site or account ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "422": {
            "description": "Invalid billing information, or error running the verification transaction.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorMayHaveTransaction"
                }
              }
            }
          }
        },
        "x-code-samples": []
      },
      "delete": {
        "tags": [
          "billing_infos"
        ],
        "operationId": "remove_a_billing_info",
        "summary": "Remove an account's billing information",
        "parameters": [
          {
            "$ref": "#/components/parameters/account_id"
          },
          {
            "$ref": "#/components/parameters/billing_info_id"
          }
        ],
        "description": "You may remove any stored billing information for an account. If the account has a subscription, the renewal will go into dunning unless the billing information is updated before the renewal occurs.",
        "responses": {
          "204": {
            "description": "Billing information deleted"
          },
          "404": {
            "description": "Account has no billing information, or incorrect site or account ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "422": {
            "description": "Billing info cannot be deleted. Please set a new primary billing info before deleting this billing info",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": []
      }
    },
    "/accounts/{account_id}/coupon_redemptions": {
      "get": {
        "tags": [
          "coupon_redemption"
        ],
        "operationId": "list_account_coupon_redemptions",
        "summary": "List the coupon redemptions for an account",
        "description": "See the [Pagination Guide](/developers/guides/pagination.html) to learn how to use pagination in the API and Client Libraries.",
        "parameters": [
          {
            "$ref": "#/components/parameters/account_id"
          },
          {
            "$ref": "#/components/parameters/ids"
          },
          {
            "$ref": "#/components/parameters/sort_dates"
          },
          {
            "$ref": "#/components/parameters/filter_begin_time"
          },
          {
            "$ref": "#/components/parameters/filter_end_time"
          },
          {
            "$ref": "#/components/parameters/filter_state"
          }
        ],
        "responses": {
          "200": {
            "description": "A list of the the coupon redemptions on an account.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CouponRedemptionList"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site or invoice ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": [
          {
            "lang": "Node.js",
            "source": "const redemptions = client.listAccountCouponRedemptions(accountId, { params: { limit: 200 } })\n\nfor await (const redemption of redemptions.each()) {\n  console.log(redemption.id)\n}\n"
          },
          {
            "lang": "Python",
            "source": "params = {\"limit\": 200}\nredemptions = client.list_account_coupon_redemptions(account_id, params=params).items()\nfor redemption in redemptions:\n    print(redemption.id)\n"
          },
          {
            "lang": ".NET",
            "source": "var redemptions = client.ListAccountCouponRedemptions(accountId);\nforeach(CouponRedemption redemption in redemptions)\n{\n    Console.WriteLine(redemption.Id);\n}\n"
          },
          {
            "lang": "Ruby",
            "source": "params = {\n  limit: 200\n}\nredemptions = @client.list_account_coupon_redemptions(\n  account_id: account_id,\n  params: params\n)\nredemptions.each do |redemption|\n  puts \"CouponRedemption: #{redemption.id}\"\nend\n"
          },
          {
            "lang": "Java",
            "source": "QueryParams params = new QueryParams();\nparams.setLimit(200); // Pull 200 records at a time\nfinal Pager<CouponRedemption> redemptions = client.listAccountCouponRedemptions(accountId, params);\n\nfor (CouponRedemption redemption : redemptions) {\n    System.out.println(redemption.getId());\n}\n"
          },
          {
            "lang": "PHP",
            "source": "$options = [\n  'params' => [\n    'limit' => 200\n  ]\n];\n$account_coupon_redemptions = $client->listAccountCouponRedemptions($account->getId(), $options);\n\nforeach($account_coupon_redemptions as $coupon_redemption) {\n  echo 'Coupon redemption: ' . $coupon_redemption->getId() . PHP_EOL;\n}\n"
          },
          {
            "lang": "Go",
            "source": "listParams := &recurly.ListAccountCouponRedemptionsParams{\n\tSort: recurly.String(\"created_at\"),\n}\naccountCouponRedemptions, err := client.ListAccountCouponRedemptions(accountID, listParams)\nif err != nil {\n\tfmt.Println(\"Unexpected error: %v\", err)\n\treturn\n}\n\nfor accountCouponRedemptions.HasMore() {\n\terr := accountCouponRedemptions.Fetch()\n\tif e, ok := err.(*recurly.Error); ok {\n\t\tfmt.Printf(\"Failed to retrieve next page: %v\", e)\n\t\tbreak\n\t}\n\tfor i, couponRedemption := range accountCouponRedemptions.Data() {\n\t\tfmt.Printf(\"Account Coupon Redemption %3d: %s\\n\",\n\t\t\ti,\n\t\t\tcouponRedemption.Id,\n\t\t)\n\t}\n}"
          }
        ]
      }
    },
    "/accounts/{account_id}/coupon_redemptions/active": {
      "get": {
        "tags": [
          "coupon_redemption"
        ],
        "operationId": "list_active_coupon_redemptions",
        "summary": "List the coupon redemptions that are active on an account",
        "description": "See the [Pagination Guide](/developers/guides/pagination.html) to learn how to use pagination in the API and Client Libraries.",
        "parameters": [
          {
            "$ref": "#/components/parameters/account_id"
          }
        ],
        "responses": {
          "200": {
            "description": "Active coupon redemptions on an account.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CouponRedemptionList"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site or account ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": [
          {
            "lang": "Node.js",
            "source": "const redemptions = await client.listActiveCouponRedemptions(accountId, { params: { limit: 200 } })\n\nfor await (const redemption of redemptions.each()) {\n  console.log('Fetched coupon redemption: ', redemption.id)\n}\n"
          },
          {
            "lang": "Python",
            "source": "params = {\"limit\": 200}\nredemptions = client.list_active_coupon_redemptions(account_id, params=params).items()\nfor redemption in redemptions:\n    print(redemption.id)\n"
          },
          {
            "lang": ".NET",
            "source": "try\n{\n    var redemptions = client.ListActiveCouponRedemptions(accountId);\n    foreach(CouponRedemption redemption in redemptions)\n    {\n        Console.WriteLine($\"Fetched coupon redemption {redemption.Id}\");\n    }\n}\ncatch (Recurly.Errors.NotFound ex)\n{\n    // If the resource was not found\n    // we may want to alert the user or just return null\n    Console.WriteLine($\"Resource Not Found: {ex.Error.Message}\");\n}\ncatch (Recurly.Errors.ApiError ex)\n{\n    // Use ApiError to catch a generic error from the API\n    Console.WriteLine($\"Unexpected Recurly Error: {ex.Error.Message}\");\n}\n"
          },
          {
            "lang": "Ruby",
            "source": "params = {\n  limit: 200\n}\nredemptions = @client.list_active_coupon_redemptions(account_id: account_id, params: params)\nredemptions.each do |redemption|\n  puts \"Redemption: #{redemption.id}\"\nend\n"
          },
          {
            "lang": "PHP",
            "source": "$options = [\n  'params' => [\n    'limit' => 200\n  ]\n];\n$redemptions = $client->listActiveCouponRedemptions($account_id, $options);\n\nforeach($redemptions as $redemption) {\n    echo 'Got Redemption: ' . $redemption->getId() . PHP_EOL;\n}\n"
          }
        ]
      },
      "post": {
        "tags": [
          "coupon_redemption"
        ],
        "operationId": "create_coupon_redemption",
        "summary": "Generate an active coupon redemption on an account or subscription",
        "parameters": [
          {
            "$ref": "#/components/parameters/account_id"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CouponRedemptionCreate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Returns the new coupon redemption.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CouponRedemption"
                }
              }
            }
          },
          "400": {
            "description": "Bad request; perhaps missing or invalid parameters.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site or account ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "422": {
            "description": "A validation error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": [
          {
            "lang": "Python",
            "source": "try:\n    redemption_create = {\"currency\": \"USD\", \"coupon_id\": coupon_id}\n    redemption = client.create_coupon_redemption(account_id, redemption_create)\n    print(\"Created Redemption %s\" % redemption)\nexcept recurly.errors.ValidationError as e:\n    # If the request was invalid, you may want to tell your user\n    # why. You can find the invalid params and reasons in e.error.params\n    print(\"ValidationError: %s\" % e.error.message)\n    print(e.error.params)\n"
          },
          {
            "lang": ".NET",
            "source": "try {\n  var redemptionReq = new CouponRedemptionCreate()\n  {\n    CouponId = couponId,\n  };\n  var redemption = client.CreateCouponRedemption(accountId, redemptionReq);\n  Console.WriteLine($\"Created coupon redemption: {redemption.Id}\");\n\n} catch (Recurly.Errors.Validation ex)\n{\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in ex.Error.Params\n    Console.WriteLine($\"Failed validation: {ex.Error.Message}\");\n}\ncatch (Recurly.Errors.ApiError ex)\n{\n    // Use ApiError to catch a generic error from the API\n    Console.WriteLine($\"Unexpected Recurly Error: {ex.Error.Message}\");\n}"
          },
          {
            "lang": "Ruby",
            "source": "begin\n  redemption_create = {\n    currency: 'USD',\n    coupon_id: coupon_id\n  }\n  redemption = @client.create_coupon_redemption(\n    account_id: account_id,\n    body: redemption_create\n  )\n  puts \"Created CouponRedemption #{redemption}\"\nrescue Recurly::Errors::ValidationError => e\n  # If the request was invalid, you may want to tell your user\n  # why. You can find the invalid params and reasons in e.recurly_error.params\n  puts \"ValidationError: #{e.recurly_error.params}\"\nend\n"
          },
          {
            "lang": "Java",
            "source": "try {\n    CouponRedemptionCreate coupRedCreate = new CouponRedemptionCreate();\n    coupRedCreate.setCouponId(couponId);\n\n    CouponRedemption redemption = client.createCouponRedemption(accountId, coupRedCreate);\n    System.out.println(\"Created coupon redemption \" + redemption.getId());\n} catch (ValidationException e) {\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in e.getError().getParams()\n    System.out.println(\"Failed validation: \" + e.getError().getMessage());\n} catch (ApiException e) {\n    // Use ApiException to catch a generic error from the API\n    System.out.println(\"Unexpected Recurly Error: \" + e.getError().getMessage());\n}\n"
          },
          {
            "lang": "PHP",
            "source": "try {\n    $redemption_create = [\n        \"currency\" => \"USD\",\n        \"coupon_id\" => \"code-$coupon_code\"\n    ];\n    $redemption = $client->createCouponRedemption($account_id, $redemption_create);\n    echo \"Created Redemption:\" . PHP_EOL;\n    var_dump($redemption);\n} catch (\\Recurly\\Errors\\Validation $e) {\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in err.params\n    var_dump($e);\n} catch (\\Recurly\\RecurlyError $e) {\n    // If we don't know what to do with the err, we should\n    // probably re-raise and let our web framework and logger handle it\n    var_dump($e);\n}"
          },
          {
            "lang": "Go",
            "source": "redemptionReq := &recurly.CouponRedemptionCreate{\n\tCouponId: recurly.String(couponID),\n\tCurrency: recurly.String(\"USD\"),\n}\n\ncouponRedemption, err := client.CreateCouponRedemption(accountID, redemptionReq)\nif e, ok := err.(*recurly.Error); ok {\n\tif e.Type == recurly.ErrorTypeValidation {\n\t\tfmt.Printf(\"Failed validation: %v\", e)\n\t\treturn nil, err\n\t}\n\tfmt.Printf(\"Unexpected Recurly error: %v\", e)\n\treturn nil, err\n}\nfmt.Printf(\"Created Coupon Redemption: %v\", couponRedemption)"
          }
        ]
      },
      "delete": {
        "tags": [
          "coupon_redemption"
        ],
        "operationId": "remove_coupon_redemption",
        "summary": "Delete the active coupon redemption from an account",
        "parameters": [
          {
            "$ref": "#/components/parameters/account_id"
          }
        ],
        "responses": {
          "200": {
            "description": "Coupon redemption deleted.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CouponRedemption"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site or account ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": [
          {
            "lang": "Node.js",
            "source": "try {\n  const redemption = await client.removeCouponRedemption(accountId)\n  console.log('Removed coupon redemption: ', redemption.id)\n} catch (err) {\n  if (err instanceof recurly.errors.NotFoundError) {\n    // If the request was not found, you may want to alert the user or\n    // just return null\n    console.log('Resource Not Found')\n  } else {\n    // If we don't know what to do with the err, we should\n    // probably re-raise and let our web framework and logger handle it\n    console.log('Unknown Error: ', err)\n  }\n}\n"
          },
          {
            "lang": "Python",
            "source": "try:\n    client.remove_coupon_redemption(account_id)\n    print(\"Removed Redemption from Account id=%s\" % account_id)\nexcept recurly.errors.NotFoundError:\n    # If the resource was not found, you may want to alert the user or\n    # just return nil\n    print(\"Resource Not Found\")\n"
          },
          {
            "lang": ".NET",
            "source": "try {\n  var redemption = client.RemoveCouponRedemption(accountId);\n  Console.WriteLine($\"Removed coupon redemption from account: {redemption.Id}\");\n\n} catch (Recurly.Errors.Validation ex)\n{\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in ex.Error.Params\n    Console.WriteLine($\"Failed validation: {ex.Error.Message}\");\n}\ncatch (Recurly.Errors.ApiError ex)\n{\n    // Use ApiError to catch a generic error from the API\n    Console.WriteLine($\"Unexpected Recurly Error: {ex.Error.Message}\");\n}"
          },
          {
            "lang": "Ruby",
            "source": "begin\n  @client.remove_coupon_redemption(account_id: account_id)\n  puts \"Removed CouponRedemption #{account_id}\"\nrescue Recurly::Errors::NotFoundError\n  # If the resource was not found, you may want to alert the user or\n  # just return nil\n  puts \"Resource Not Found\"\nend\n"
          },
          {
            "lang": "Java",
            "source": "try {\n    final CouponRedemption redemption = client.removeCouponRedemption(accountId);\n    System.out.println(\"Removed coupon redemption \" + redemption.getId());\n} catch (NotFoundException e) {\n    // If the resource was not found\n    // we may want to alert the user or just return null\n    System.out.println(\"Resource Not Found: \" + e.getError().getMessage());\n} catch (ApiException e) {\n    // Use ApiException to catch a generic error from the API\n    System.out.println(\"Unexpected Recurly Error: \" + e.getError().getMessage());\n}\n"
          },
          {
            "lang": "PHP",
            "source": "try {\n    $redemption = $client->removeCouponRedemption($account_id);\n    echo \"Removed Active Coupon Redemption:\" . PHP_EOL;\n    var_dump($redemption);\n} catch (\\Recurly\\Errors\\Validation $e) {\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in err.params\n    var_dump($e);\n} catch (\\Recurly\\RecurlyError $e) {\n    // If we don't know what to do with the err, we should\n    // probably re-raise and let our web framework and logger handle it\n    var_dump($e);\n}"
          },
          {
            "lang": "Go",
            "source": "couponRedemption, err := client.RemoveCouponRedemption(accountID)\nif e, ok := err.(*recurly.Error); ok {\n\tif e.Type == recurly.ErrorTypeNotFound {\n\t\tfmt.Printf(\"Resource not found: %v\", e)\n\t\treturn nil, err\n\t}\n\tfmt.Printf(\"Unexpected Recurly error: %v\", e)\n\treturn nil, err\n}\n\nfmt.Printf(\"Removed Coupon Redemption: %v\", couponRedemption.Id)"
          }
        ]
      }
    },
    "/accounts/{account_id}/credit_payments": {
      "get": {
        "tags": [
          "credit_payment"
        ],
        "operationId": "list_account_credit_payments",
        "summary": "List an account's credit payments",
        "description": "See the [Pagination Guide](/developers/guides/pagination.html) to learn how to use pagination in the API and Client Libraries.",
        "parameters": [
          {
            "$ref": "#/components/parameters/account_id"
          },
          {
            "$ref": "#/components/parameters/limit"
          },
          {
            "$ref": "#/components/parameters/order"
          },
          {
            "$ref": "#/components/parameters/sort_dates"
          },
          {
            "$ref": "#/components/parameters/filter_begin_time"
          },
          {
            "$ref": "#/components/parameters/filter_end_time"
          }
        ],
        "responses": {
          "200": {
            "description": "A list of the account's credit payments.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CreditPaymentList"
                }
              }
            }
          },
          "400": {
            "description": "Invalid or unpermitted parameter.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site or account ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": [
          {
            "lang": "Node.js",
            "source": "const payments = client.listAccountCreditPayments(accountId, { params: { limit: 200 } })\n\nfor await (const payment of payments.each()) {\n  console.log(payment.uuid)\n}\n"
          },
          {
            "lang": "Python",
            "source": "params = {\"limit\": 200}\npayments = client.list_account_credit_payments(account_id, params=params).items()\nfor payment in payments:\n    print(payment.id)\n"
          },
          {
            "lang": ".NET",
            "source": "var optionalParams = new ListAccountCreditPaymentsParams()\n{\n    Limit = 200\n};\nvar payments = client.ListAccountCreditPayments(accountId, optionalParams);\nforeach(CreditPayment payment in payments)\n{\n    Console.WriteLine(payment.Uuid);\n}\n"
          },
          {
            "lang": "Ruby",
            "source": "params = {\n  limit: 200\n}\npayments = @client.list_account_credit_payments(\n  account_id: account_id,\n  params: params\n)\npayments.each do |payment|\n  puts \"CreditPayment: #{payment.id}\"\nend\n"
          },
          {
            "lang": "Java",
            "source": "QueryParams params = new QueryParams();\nparams.setLimit(200); // Pull 200 records at a time\nPager<CreditPayment> payments = client.listAccountCreditPayments(accountId, params);\n\nfor (CreditPayment payment : payments) {\n    System.out.println(payment.getUuid());\n}\n"
          },
          {
            "lang": "PHP",
            "source": "$options = [\n  'params' => [\n    'limit' => 200\n  ]\n];\n$credit_payments = $client->listAccountCreditPayments($account->getId(), $options);\n\nforeach($credit_payments as $payment) {\n  echo 'Credit Payment: ' . $payment->getId() . PHP_EOL;\n}\n"
          },
          {
            "lang": "Go",
            "source": "listParams := &recurly.ListAccountCreditPaymentsParams{\n\tSort:  recurly.String(\"created_at\"),\n\tOrder: recurly.String(\"desc\"),\n\tLimit: recurly.Int(200),\n}\ncreditPayments, err := client.ListAccountCreditPayments(accountID, listParams)\nif err != nil {\n\tfmt.Println(\"Unexpected error: %v\", err)\n\treturn\n}\n\nfor creditPayments.HasMore() {\n\terr := creditPayments.Fetch()\n\tif e, ok := err.(*recurly.Error); ok {\n\t\tfmt.Printf(\"Failed to retrieve next page: %v\", e)\n\t\tbreak\n\t}\n\tfor i, creditPayment := range creditPayments.Data() {\n\t\tfmt.Printf(\"Account Credit Payment %3d: %s\\n\",\n\t\t\ti,\n\t\t\tcreditPayment.Id,\n\t\t)\n\t}\n}"
          }
        ]
      }
    },
    "/accounts/{account_id}/external_accounts": {
      "parameters": [
        {
          "$ref": "#/components/parameters/account_id"
        }
      ],
      "get": {
        "tags": [
          "external_accounts"
        ],
        "operationId": "list_account_external_account",
        "summary": "List external accounts for an account",
        "responses": {
          "200": {
            "description": "A list of external accounts on an account.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ExternalAccountList"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect account or external_account ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "406": {
            "description": "Unavailable API version",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "422": {
            "description": "Feature not enabled on site",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": []
      },
      "post": {
        "tags": [
          "external_accounts"
        ],
        "operationId": "create_account_external_account",
        "summary": "Create an external account",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ExternalAccountCreate"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "A representation of the created external_account.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ExternalAccount"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect account or external_account ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "406": {
            "description": "Unavailable API version",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "422": {
            "description": "Feature not enabled on site",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": []
      }
    },
    "/accounts/{account_id}/external_accounts/{external_account_id}": {
      "parameters": [
        {
          "$ref": "#/components/parameters/account_id"
        },
        {
          "$ref": "#/components/parameters/external_account_id"
        }
      ],
      "get": {
        "tags": [
          "external_accounts"
        ],
        "operationId": "get_account_external_account",
        "summary": "Get an external account for an account",
        "responses": {
          "200": {
            "description": "A external account on an account.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ExternalAccount"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect account or external_account ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "406": {
            "description": "Unavailable API version",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "422": {
            "description": "Feature not enabled on site",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": []
      },
      "put": {
        "tags": [
          "external_accounts"
        ],
        "operationId": "update_account_external_account",
        "summary": "Update an external account",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ExternalAccountUpdate"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "A representation of the updated external_account.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ExternalAccount"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect account or external_account ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "406": {
            "description": "Unavailable API version",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "422": {
            "description": "Feature not enabled on site",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": []
      },
      "delete": {
        "tags": [
          "external_accounts"
        ],
        "operationId": "delete_account_external_account",
        "summary": "Delete an external account for an account",
        "responses": {
          "200": {
            "description": "Successful Delete",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ExternalAccount"
                }
              }
            }
          },
          "404": {
            "description": "External Account not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "406": {
            "description": "Unavailable API version",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "422": {
            "description": "Feature not enabled on site",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": []
      }
    },
    "/accounts/{account_id}/external_invoices": {
      "parameters": [
        {
          "$ref": "#/components/parameters/account_id"
        }
      ],
      "get": {
        "tags": [
          "account"
        ],
        "operationId": "list_account_external_invoices",
        "summary": "List the external invoices on an account",
        "description": "See the [Pagination Guide](/developers/guides/pagination.html) to learn how to use pagination in the API and Client Libraries.",
        "parameters": [
          {
            "$ref": "#/components/parameters/sort_dates"
          },
          {
            "$ref": "#/components/parameters/limit"
          },
          {
            "$ref": "#/components/parameters/order"
          }
        ],
        "responses": {
          "200": {
            "description": "A list of the the external_invoices on an account.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ExternalInvoiceList"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect account.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": []
      }
    },
    "/accounts/{account_id}/invoices": {
      "get": {
        "tags": [
          "invoice"
        ],
        "operationId": "list_account_invoices",
        "summary": "List an account's invoices",
        "description": "See the [Pagination Guide](/developers/guides/pagination.html) to learn how to use pagination in the API and Client Libraries.",
        "parameters": [
          {
            "$ref": "#/components/parameters/account_id"
          },
          {
            "$ref": "#/components/parameters/ids"
          },
          {
            "$ref": "#/components/parameters/invoice_state"
          },
          {
            "$ref": "#/components/parameters/limit"
          },
          {
            "$ref": "#/components/parameters/order"
          },
          {
            "$ref": "#/components/parameters/sort_dates"
          },
          {
            "$ref": "#/components/parameters/filter_begin_time"
          },
          {
            "$ref": "#/components/parameters/filter_end_time"
          },
          {
            "$ref": "#/components/parameters/filter_invoice_type"
          }
        ],
        "responses": {
          "200": {
            "description": "A list of the account's invoices.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/InvoiceList"
                }
              }
            }
          },
          "400": {
            "description": "Invalid or unpermitted parameter.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site or account ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": [
          {
            "lang": "Node.js",
            "source": "const invoices = client.listAccountInvoices(accountId, { params: { limit: 200 } })\n\nfor await (const invoice of invoices.each()) {\n  console.log(invoice.number)\n}\n"
          },
          {
            "lang": "Python",
            "source": "params = {\"limit\": 200}\ninvoices = client.list_account_invoices(account_id, params=params).items()\nfor invoice in invoices:\n    print(invoice.number)\n"
          },
          {
            "lang": ".NET",
            "source": "var invoices = client.ListAccountInvoices(accountId);\nforeach(Invoice invoice in invoices)\n{\n    Console.WriteLine(invoice.Id);\n}\n"
          },
          {
            "lang": "Ruby",
            "source": "params = {\n  limit: 200\n}\ninvoices = @client.list_account_invoices(\n  account_id: account_id,\n  params: params\n)\ninvoices.each do |invoice|\n  puts \"Invoice: #{invoice.number}\"\nend\n"
          },
          {
            "lang": "Java",
            "source": "QueryParams params = new QueryParams();\nparams.setLimit(200); // Pull 200 records at a time\nfinal Pager<Invoice> invoices = client.listAccountInvoices(accountId, params);\n\nfor (Invoice invoice : invoices) {\n    System.out.println(invoice.getNumber());\n}\n"
          },
          {
            "lang": "PHP",
            "source": "$options = [\n  'params' => [\n    'limit' => 200\n  ]\n];\n$invoices = $client->listAccountInvoices($account->getId(), $options);\nforeach($invoices as $invoice) {\n  echo 'Account invoice: ' . $invoice->getNumber() . PHP_EOL;\n}\n"
          },
          {
            "lang": "Go",
            "source": "listParams := &recurly.ListAccountInvoicesParams{\n\tSort:  recurly.String(\"created_at\"),\n\tOrder: recurly.String(\"desc\"),\n\tLimit: recurly.Int(200),\n}\naccountInvoices, err := client.ListAccountInvoices(accountID, listParams)\nif err != nil {\n\tfmt.Println(\"Unexpected error: %v\", err)\n\treturn\n}\n\nfor accountInvoices.HasMore() {\n\terr := accountInvoices.Fetch()\n\tif e, ok := err.(*recurly.Error); ok {\n\t\tfmt.Printf(\"Failed to retrieve next page: %v\", e)\n\t\tbreak\n\t}\n\tfor i, invoice := range accountInvoices.Data() {\n\t\tfmt.Printf(\"Account Invoice %3d: %s\\n\",\n\t\t\ti,\n\t\t\tinvoice.Id,\n\t\t)\n\t}\n}"
          }
        ]
      },
      "post": {
        "tags": [
          "invoice"
        ],
        "operationId": "create_invoice",
        "summary": "Create an invoice for pending line items",
        "parameters": [
          {
            "$ref": "#/components/parameters/account_id"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/InvoiceCreate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Returns the new invoices.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/InvoiceCollection"
                }
              }
            }
          },
          "400": {
            "description": "Bad request, perhaps invalid JSON?",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site or account ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "422": {
            "description": "Invalid parameters, no pending line items, or error running the transaction.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorMayHaveTransaction"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": [
          {
            "lang": "Node.js",
            "source": "try {\n  let invoiceCreate = {\n    currency: 'USD',\n    collectionMethod: 'automatic'\n  }\n  let invoiceCollection = await client.createInvoice(accountId, invoiceCreate)\n  console.log('Created Invoice')\n  console.log('Charge Invoice: ', invoiceCollection.chargeInvoice)\n  console.log('Credit Invoices: ', invoiceCollection.creditInvoices)\n} catch (err) {\n  if (err instanceof recurly.errors.ValidationError) {\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in err.params\n    console.log('Failed validation', err.params)\n  } else {\n    // If we don't know what to do with the err, we should\n    // probably re-raise and let our web framework and logger handle it\n    console.log('Unknown Error: ', err)\n  }\n}\n"
          },
          {
            "lang": "Python",
            "source": "try:\n    invoice_create = {\"currency\": \"USD\", \"collection_method\": \"automatic\"}\n    invoice_collection = client.create_invoice(account_id, invoice_create)\n    print(\"Created InvoiceCollection %s\" % invoice_collection)\nexcept recurly.errors.ValidationError as e:\n    # If the request was invalid, you may want to tell your user\n    # why. You can find the invalid params and reasons in e.error.params\n    print(\"ValidationError: %s\" % e.error.message)\n    print(e.error.params)\n"
          },
          {
            "lang": ".NET",
            "source": "try\n{\n    // creates an invoice based on pending charges or credits on account\n    var collection = client.CreateInvoice(accountId, new InvoiceCreate()\n    {\n        Currency = \"USD\",\n        CollectionMethod = CollectionMethod.Automatic\n    });\n    Console.WriteLine(\"Created Invoice\");\n    Console.WriteLine(collection.ChargeInvoice);\n    Console.WriteLine(collection.CreditInvoices);\n}\ncatch (Recurly.Errors.Validation ex)\n{\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in ex.Error.Params\n    Console.WriteLine($\"Failed validation: {ex.Error.Message}\");\n}\ncatch (Recurly.Errors.ApiError ex)\n{\n    // Use ApiError to catch a generic error from the API\n    Console.WriteLine($\"Unexpected Recurly Error: {ex.Error.Message}\");\n}\n"
          },
          {
            "lang": "Ruby",
            "source": "begin\n  invoice_create = {\n    currency: 'USD',\n    collection_method: 'automatic'\n  }\n  collection = @client.create_invoice(\n    account_id: account_id,\n    body: invoice_create\n  )\n  puts \"Created InvoiceCollection #{collection}\"\nrescue Recurly::Errors::ValidationError => e\n  # If the request was invalid, you may want to tell your user\n  # why. You can find the invalid params and reasons in e.recurly_error.params\n  puts \"ValidationError: #{e.recurly_error.params}\"\nend\n"
          },
          {
            "lang": "Java",
            "source": "try {\n    InvoiceCreate invoiceCreate = new InvoiceCreate();\n    invoiceCreate.setCurrency(\"USD\");\n    invoiceCreate.setCollectionMethod(Constants.CollectionMethod.AUTOMATIC);\n\n    InvoiceCollection collection = client.createInvoice(accountId, invoiceCreate);\n    System.out.println(\"Created Invoice\");\n    System.out.println(collection.getChargeInvoice());\n    System.out.println(collection.getCreditInvoices());\n} catch (ValidationException e) {\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in e.getError().getParams()\n    System.out.println(\"Failed validation: \" + e.getError().getMessage());\n} catch (ApiException e) {\n    // Use ApiException to catch a generic error from the API\n    System.out.println(\"Unexpected Recurly Error: \" + e.getError().getMessage());\n}\n"
          },
          {
            "lang": "PHP",
            "source": "try {\n    $invoice_create = [\n        \"currency\" => \"USD\",\n        \"collection_method\" => \"automatic\"\n    ];\n    $invoice_collection = $client->createInvoice(\n        $account_id,\n        $invoice_create\n    );\n    echo \"Created Invoice:\" . PHP_EOL;\n    var_dump($invoice_collection);\n} catch (\\Recurly\\Errors\\Validation $e) {\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in err.params\n    var_dump($e);\n} catch (\\Recurly\\RecurlyError $e) {\n    // If we don't know what to do with the err, we should\n    // probably re-raise and let our web framework and logger handle it\n    var_dump($e);\n}"
          },
          {
            "lang": "Go",
            "source": "invoiceReq := &recurly.InvoiceCreate{\n\tCurrency:         recurly.String(\"USD\"),\n\tCollectionMethod: recurly.String(\"automatic\"),\n}\n\ncollection, err := client.CreateInvoice(accountID, invoiceReq)\nif e, ok := err.(*recurly.Error); ok {\n\tif e.Type == recurly.ErrorTypeValidation {\n\t\tfmt.Printf(\"Failed validation: %v\", e)\n\t\treturn nil, err\n\t}\n\tfmt.Printf(\"Unexpected Recurly error: %v\", e)\n\treturn nil, err\n}\nfmt.Printf(\"Created Invoice Collection: %v\", collection)"
          }
        ]
      }
    },
    "/accounts/{account_id}/invoices/preview": {
      "post": {
        "tags": [
          "invoice"
        ],
        "operationId": "preview_invoice",
        "summary": "Preview new invoice for pending line items",
        "parameters": [
          {
            "$ref": "#/components/parameters/account_id"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/InvoiceCreate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Returns the invoice previews.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/InvoiceCollection"
                }
              }
            }
          },
          "400": {
            "description": "Bad request, perhaps invalid JSON?",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site or account ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "422": {
            "description": "Invalid parameter or pending line items.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": [
          {
            "lang": "Node.js",
            "source": "try {\n  const collection = await client.previewInvoice(accountId, {\n    currency: \"USD\",\n    collectionMethod: \"automatic\"\n  })\n  console.log(`Previewed invoice due at ${collection.chargeInvoice.dueAt}`)\n  console.log(collection.chargeInvoice)\n  console.log(collection.creditInvoices)\n} catch(err) {\n\n  if (err instanceof recurly.errors.ValidationError) {\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in err.params\n    console.log('Failed validation', err.params)\n  } else {\n    // If we don't know what to do with the err, we should\n    // probably re-raise and let our web framework and logger handle it\n    console.log('Unknown Error: ', err)\n  }\n}\n"
          },
          {
            "lang": "Python",
            "source": "try:\n    invoice_preview = {\"currency\": \"USD\", \"collection_method\": \"automatic\"}\n    invoice_collection = client.preview_invoice(account_id, invoice_preview)\n    print(\"Preview InvoiceCollection %s\" % invoice_collection)\nexcept recurly.errors.ValidationError as e:\n    # If the request was invalid, you may want to tell your user\n    # why. You can find the invalid params and reasons in e.error.params\n    print(\"ValidationError: %s\" % e.error.message)\n    print(e.error.params)\n"
          },
          {
            "lang": ".NET",
            "source": "try\n{\n    // creates a preview invoice based on pending charges or credits on account\n    var collection = client.PreviewInvoice(accountId, new InvoiceCreate()\n    {\n        Currency = \"USD\",\n        CollectionMethod = CollectionMethod.Automatic\n    });\n    Console.WriteLine($\"Previewed invoice DueAt {collection.ChargeInvoice.DueAt}\");\n    Console.WriteLine(collection.ChargeInvoice);\n    Console.WriteLine(collection.CreditInvoices);\n}\ncatch (Recurly.Errors.Validation ex)\n{\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in ex.Error.Params\n    Console.WriteLine($\"Failed validation: {ex.Error.Message}\");\n}\ncatch (Recurly.Errors.ApiError ex)\n{\n    // Use ApiError to catch a generic error from the API\n    Console.WriteLine($\"Unexpected Recurly Error: {ex.Error.Message}\");\n}\n"
          },
          {
            "lang": "Ruby",
            "source": "begin\n  invoice_preview = {\n    currency: \"USD\",\n    collection_method: \"automatic\"\n  }\n  collection = @client.create_invoice(\n    account_id: account_id,\n    body: invoice_preview\n  )\n  puts \"Created InvoiceCollection #{collection}\"\nrescue Recurly::Errors::ValidationError => e\n  # If the request was invalid, you may want to tell your user\n  # why. You can find the invalid params and reasons in e.recurly_error.params\n  puts \"ValidationError: #{e.recurly_error.params}\"\nend\n"
          },
          {
            "lang": "Java",
            "source": "try {\n    InvoiceCreate invoiceCreate = new InvoiceCreate();\n    invoiceCreate.setCurrency(\"USD\");\n    invoiceCreate.setCollectionMethod(Constants.CollectionMethod.AUTOMATIC);\n\n    InvoiceCollection collection = client.previewInvoice(accountId, invoiceCreate);\n    System.out.println(\"Previewed Invoice due at \" + collection.getChargeInvoice().getDueAt());\n    System.out.println(collection.getChargeInvoice());\n    System.out.println(collection.getCreditInvoices());\n} catch (ValidationException e) {\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in e.getError().getParams()\n    System.out.println(\"Failed validation: \" + e.getError().getMessage());\n} catch (ApiException e) {\n    // Use ApiException to catch a generic error from the API\n    System.out.println(\"Unexpected Recurly Error: \" + e.getError().getMessage());\n}\n"
          },
          {
            "lang": "PHP",
            "source": "try {\n    $invoice_preview = [\n        \"currency\" => \"USD\",\n        \"collection_method\" => \"automatic\"\n    ];\n    $invoice_collection = $client->previewInvoice(\n        $account_id,\n        $invoice_preview\n    );\n    echo \"Previewed Invoice:\" . PHP_EOL;\n    var_dump($invoice_collection);\n} catch (\\Recurly\\Errors\\Validation $e) {\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in err.params\n    var_dump($e);\n} catch (\\Recurly\\RecurlyError $e) {\n    // If we don't know what to do with the err, we should\n    // probably re-raise and let our web framework and logger handle it\n    var_dump($e);\n}"
          },
          {
            "lang": "Go",
            "source": "invoiceReq := &recurly.InvoiceCreate{\n\tCurrency: recurly.String(\"USD\"),\n}\n\ncollection, err := client.PreviewInvoice(accountID, invoiceReq)\nif e, ok := err.(*recurly.Error); ok {\n\tif e.Type == recurly.ErrorTypeValidation {\n\t\tfmt.Printf(\"Failed validation: %v\", e)\n\t\treturn nil, err\n\t}\n\tfmt.Printf(\"Unexpected Recurly error: %v\", e)\n\treturn nil, err\n}\nfmt.Printf(\"Preview Invoice %v\", collection.ChargeInvoice)"
          }
        ]
      }
    },
    "/accounts/{account_id}/line_items": {
      "get": {
        "tags": [
          "line_item"
        ],
        "operationId": "list_account_line_items",
        "summary": "List an account's line items",
        "description": "See the [Pagination Guide](/developers/guides/pagination.html) to learn how to use pagination in the API and Client Libraries.",
        "parameters": [
          {
            "$ref": "#/components/parameters/account_id"
          },
          {
            "$ref": "#/components/parameters/ids"
          },
          {
            "$ref": "#/components/parameters/limit"
          },
          {
            "$ref": "#/components/parameters/order"
          },
          {
            "$ref": "#/components/parameters/sort_dates"
          },
          {
            "$ref": "#/components/parameters/filter_begin_time"
          },
          {
            "$ref": "#/components/parameters/filter_end_time"
          },
          {
            "$ref": "#/components/parameters/filter_line_item_original"
          },
          {
            "$ref": "#/components/parameters/filter_line_item_state"
          },
          {
            "$ref": "#/components/parameters/filter_line_item_type"
          }
        ],
        "responses": {
          "200": {
            "description": "A list of the account's line items.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LineItemList"
                }
              }
            }
          },
          "400": {
            "description": "Invalid or unpermitted parameter.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": [
          {
            "lang": "Node.js",
            "source": "const lineItems = client.listAccountLineItems(accountId, { params: { limit: 200 } })\n\nfor await (const lineItem of lineItems.each()) {\n  console.log(lineItem.id)\n}\n"
          },
          {
            "lang": "Python",
            "source": "params = {\"limit\": 200}\nline_items = client.list_account_line_items(account_id, params=params).items()\nfor line_item in line_items:\n    print(line_item.id)\n"
          },
          {
            "lang": ".NET",
            "source": "var lineItems = client.ListAccountLineItems(accountId);\nforeach(LineItem lineItem in lineItems)\n{\n    Console.WriteLine(lineItem.Id);\n}\n"
          },
          {
            "lang": "Ruby",
            "source": "params = {\n  limit: 200\n}\nline_items = @client.list_account_line_items(\n  account_id: account_id,\n  params: params\n)\nline_items.each do |line_item|\n  puts \"LineItem: #{line_item.id}\"\nend\n"
          },
          {
            "lang": "Java",
            "source": "QueryParams params = new QueryParams();\nparams.setLimit(200); // Pull 200 records at a time\nfinal Pager<LineItem> lineItems = client.listAccountLineItems(accountId, params);\n\nfor (LineItem lineItem : lineItems) {\n    System.out.println(lineItem.getId());\n}\n"
          },
          {
            "lang": "PHP",
            "source": "$options = [\n  'params' => [\n    'limit' => 200\n  ]\n];\n$account_line_items = $client->listAccountLineItems($account_id, $options);\n\nforeach($account_line_items as $line_item) {\n  echo 'Account line item: ' . $line_item->getId() . PHP_EOL;\n}\n"
          },
          {
            "lang": "Go",
            "source": "listParams := &recurly.ListAccountLineItemsParams{\n\tSort:  recurly.String(\"created_at\"),\n\tOrder: recurly.String(\"desc\"),\n\tLimit: recurly.Int(200),\n}\naccountLineItems, err := client.ListAccountLineItems(accountID, listParams)\nif err != nil {\n\tfmt.Println(\"Unexpected error: %v\", err)\n\treturn\n}\n\nfor accountLineItems.HasMore() {\n\terr := accountLineItems.Fetch()\n\tif e, ok := err.(*recurly.Error); ok {\n\t\tfmt.Printf(\"Failed to retrieve next page: %v\", e)\n\t\tbreak\n\t}\n\tfor i, lineItem := range accountLineItems.Data() {\n\t\tfmt.Printf(\"Account Line Item %3d: %s\\n\",\n\t\t\ti,\n\t\t\tlineItem.Id,\n\t\t)\n\t}\n}"
          }
        ]
      },
      "post": {
        "tags": [
          "line_item"
        ],
        "operationId": "create_line_item",
        "summary": "Create a new line item for the account",
        "description": "When using the Credit Invoices feature, utilize the purchases endpoint in order to immediately post credit to a credit invoice.",
        "parameters": [
          {
            "$ref": "#/components/parameters/account_id"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/LineItemCreate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Returns the new line item.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LineItem"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site or account ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "422": {
            "description": "A validation error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": [
          {
            "lang": "Node.js",
            "source": "try {\n  let lineItemReq = {\n    currency: 'USD',\n    unitAmount: 1000,\n    type: 'charge' // choose \"credit\" for a credit\n  }\n  let lineItem = await client.createLineItem(accountId, lineItemReq)\n  console.log('Created Line Item: ', lineItem.uuid)\n} catch (err) {\n  if (err instanceof recurly.errors.ValidationError) {\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in err.params\n    console.log('Failed validation', err.params)\n  } else {\n    // If we don't know what to do with the err, we should\n    // probably re-raise and let our web framework and logger handle it\n    console.log('Unknown Error: ', err)\n  }\n}\n"
          },
          {
            "lang": "Python",
            "source": "try:\n    line_item_create = {\n        \"currency\": \"USD\",\n        \"unit_amount\": 1000,\n        \"type\": \"charge\",  # choose \"credit\" for a credit\n    }\n    line_item = client.create_line_item(account_id, line_item_create)\n    print(\"Created LineItem %s\" % line_item)\nexcept recurly.errors.ValidationError as e:\n    # If the request was invalid, you may want to tell your user\n    # why. You can find the invalid params and reasons in e.error.params\n    print(\"ValidationError: %s\" % e.error.message)\n    print(e.error.params)\n"
          },
          {
            "lang": ".NET",
            "source": "try\n{\n    // creates a pending charge or credit on the account\n    var lineItemReq = new LineItemCreate()\n    {\n        Currency = \"USD\",\n        UnitAmount = 1000,\n        Type = LineItemType.Charge // choose \"credit\" for a credit\n    };\n    LineItem lineItem = client.CreateLineItem(accountId, lineItemReq);\n    Console.WriteLine($\"Created line item {lineItem.Uuid}\");\n}\ncatch (Recurly.Errors.Validation ex)\n{\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in ex.Error.Params\n    Console.WriteLine($\"Failed validation: {ex.Error.Message}\");\n}\ncatch (Recurly.Errors.ApiError ex)\n{\n    // Use ApiError to catch a generic error from the API\n    Console.WriteLine($\"Unexpected Recurly Error: {ex.Error.Message}\");\n}\n"
          },
          {
            "lang": "Ruby",
            "source": "begin\n  line_item_create = {\n    currency: 'USD',\n    unit_amount: 1_000,\n    type: :charge\n  }\n  line_item = @client.create_line_item(\n    account_id: account_id,\n    body: line_item_create\n  )\n  puts \"Created LineItem #{line_item}\"\nrescue Recurly::Errors::ValidationError => e\n  # If the request was invalid, you may want to tell your user\n  # why. You can find the invalid params and reasons in e.recurly_error.params\n  puts \"ValidationError: #{e.recurly_error.params}\"\nend\n"
          },
          {
            "lang": "Java",
            "source": "try {\n    LineItemCreate lineItemCreate = new LineItemCreate();\n    lineItemCreate.setCurrency(\"USD\");\n    lineItemCreate.setUnitAmount(new BigDecimal(\"1000.0\"));\n    lineItemCreate.setType(Constants.LineItemType.CHARGE); // choose \"credit\" for a credit\n\n    LineItem lineItem = client.createLineItem(accountId, lineItemCreate);\n    System.out.println(\"Created line item \" + lineItem.getUuid());\n} catch (ValidationException e) {\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in e.getError().getParams()\n    System.out.println(\"Failed validation: \" + e.getError().getMessage());\n} catch (ApiException e) {\n    // Use ApiException to catch a generic error from the API\n    System.out.println(\"Unexpected Recurly Error: \" + e.getError().getMessage());\n}\n"
          },
          {
            "lang": "PHP",
            "source": "try {\n    $line_item_create = [\n        'currency' => 'USD',\n        'unit_amount' => 1000,\n        'type' => 'charge'\n    ];\n    $line_item = $client->createLineItem(\n        $account->getId(),\n        $line_item_create\n    );\n    echo 'Created Line Item:' . PHP_EOL;\n    var_dump($line_item);\n} catch (\\Recurly\\Errors\\Validation $e) {\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in err.params\n    var_dump($e);\n} catch (\\Recurly\\RecurlyError $e) {\n    // If we don't know what to do with the err, we should\n    // probably re-raise and let our web framework and logger handle it\n    var_dump($e);\n}"
          },
          {
            "lang": "Go",
            "source": "lineItemReq := &recurly.LineItemCreate{\n\tCurrency:   recurly.String(\"USD\"),\n\tUnitAmount: recurly.Float(1000),\n\tType:       recurly.String(\"charge\"),\n}\n\nlineItem, err := client.CreateLineItem(accountID, lineItemReq)\nif e, ok := err.(*recurly.Error); ok {\n\tif e.Type == recurly.ErrorTypeValidation {\n\t\tfmt.Printf(\"Failed validation: %v\", e)\n\t\treturn nil, err\n\t}\n\tfmt.Printf(\"Unexpected Recurly error: %v\", e)\n\treturn nil, err\n}\nfmt.Printf(\"Created Line Item: %v\", lineItem)"
          }
        ]
      }
    },
    "/accounts/{account_id}/notes": {
      "get": {
        "tags": [
          "note"
        ],
        "operationId": "list_account_notes",
        "summary": "List an account's notes",
        "description": "See the [Pagination Guide](/developers/guides/pagination.html) to learn how to use pagination in the API and Client Libraries.",
        "parameters": [
          {
            "$ref": "#/components/parameters/account_id"
          },
          {
            "$ref": "#/components/parameters/ids"
          }
        ],
        "responses": {
          "200": {
            "description": "A list of an account's notes.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AccountNoteList"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site or account ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": [
          {
            "lang": "Node.js",
            "source": "const notes = client.listAccountNotes(accountId, { params: { limit: 200 } })\n\nfor await (const note of notes.each()) {\n  console.log(note.message)\n}\n"
          },
          {
            "lang": "Python",
            "source": "params = {\"limit\": 200}\nline_items = client.list_account_line_items(account_id, params=params).items()\nfor line_item in line_items:\n    print(line_item.id)\n"
          },
          {
            "lang": ".NET",
            "source": "var notes = client.ListAccountNotes(accountId);\nforeach(AccountNote note in notes)\n{\n    Console.WriteLine(note.Message);\n}\n"
          },
          {
            "lang": "Ruby",
            "source": "params = {\n  limit: 200\n}\naccount_notes = @client.list_account_notes(account_id: account_id, params: params)\naccount_notes.each do |note|\n  puts \"AccountNote: #{note.message}\"\nend\n"
          },
          {
            "lang": "Java",
            "source": "QueryParams params = new QueryParams();\nparams.setLimit(200); // Pull 200 records at a time\nfinal Pager<AccountNote> notes = client.listAccountNotes(accountId, params);\n\nfor (AccountNote note : notes) {\n    System.out.println(note.getMessage());\n}\n"
          },
          {
            "lang": "PHP",
            "source": "$options = [\n  'params' => [\n    'limit' => 200\n  ]\n];\n$account_notes = $client->listAccountNotes($account_id, $options);\n\nforeach($account_notes as $note) {\n  echo 'Account note: ' . $note->getMessage() . PHP_EOL;\n}\n"
          },
          {
            "lang": "Go",
            "source": "listParams := &recurly.ListAccountNotesParams{}\naccountNotes, err := client.ListAccountNotes(accountID, listParams)\nif err != nil {\n\tfmt.Println(\"Unexpected error: %v\", err)\n\treturn\n}\n\nfor accountNotes.HasMore() {\n\terr := accountNotes.Fetch()\n\tif e, ok := err.(*recurly.Error); ok {\n\t\tfmt.Printf(\"Failed to retrieve next page: %v\", e)\n\t\tbreak\n\t}\n\tfor i, note := range accountNotes.Data() {\n\t\tfmt.Printf(\"Account Note %3d: %s\\n\",\n\t\t\ti,\n\t\t\tnote.Id,\n\t\t)\n\t}\n}"
          }
        ]
      }
    },
    "/accounts/{account_id}/notes/{account_note_id}": {
      "get": {
        "tags": [
          "note"
        ],
        "operationId": "get_account_note",
        "summary": "Fetch an account note",
        "parameters": [
          {
            "$ref": "#/components/parameters/account_id"
          },
          {
            "name": "account_note_id",
            "in": "path",
            "description": "Account Note ID.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "An account note.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AccountNote"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site, account or note ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": [
          {
            "lang": "Node.js",
            "source": "try {\n  console.log(accountId)\n  const note = await client.getAccountNote(accountId, accountNoteId)\n  console.log('Fetched account note: ', note.message)\n} catch (err) {\n  if (err instanceof recurly.errors.NotFoundError) {\n    // If the request was not found, you may want to alert the user or\n    // just return null\n    console.log('Resource Not Found')\n  } else {\n    // If we don't know what to do with the err, we should\n    // probably re-raise and let our web framework and logger handle it\n    console.log('Unknown Error: ', err)\n  }\n}\n"
          },
          {
            "lang": "Python",
            "source": "try:\n    note = client.get_account_note(account_id, note_id)\n    print(\"Got AccountNote %s\" % note)\nexcept recurly.errors.NotFoundError:\n    # If the resource was not found, you may want to alert the user or\n    # just return nil\n    print(\"Resource Not Found\")\n"
          },
          {
            "lang": ".NET",
            "source": "try\n{\n    AccountNote note = client.GetAccountNote(accountId, accountNoteId);\n    Console.WriteLine($\"Fetched account note: {note.Message}\");\n}\ncatch (Recurly.Errors.NotFound ex)\n{\n    // If the resource was not found\n    // we may want to alert the user or just return null\n    Console.WriteLine($\"Resource Not Found: {ex.Error.Message}\");\n}\ncatch (Recurly.Errors.ApiError ex)\n{\n    // Use ApiError to catch a generic error from the API\n    Console.WriteLine($\"Unexpected Recurly Error: {ex.Error.Message}\");\n}\n"
          },
          {
            "lang": "Ruby",
            "source": "begin\n  note = @client.get_account_note(\n    account_id: account_id,\n    account_note_id: note_id\n  )\n  puts \"Got AccountNote #{note}\"\nrescue Recurly::Errors::NotFoundError\n  # If the resource was not found, you may want to alert the user or\n  # just return nil\n  puts \"Resource Not Found\"\nend\n"
          },
          {
            "lang": "Java",
            "source": "try {\n    final AccountNote note = client.getAccountNote(accountId, accountNoteId);\n    System.out.println(\"Fetched account note: \" + note.getMessage());\n} catch (NotFoundException e) {\n    // If the resource was not found\n    // we may want to alert the user or just return null\n    System.out.println(\"Resource Not Found: \" + e.getError().getMessage());\n} catch (ApiException e) {\n    // Use ApiException to catch a generic error from the API\n    System.out.println(\"Unexpected Recurly Error: \" + e.getError().getMessage());\n}\n"
          },
          {
            "lang": "PHP",
            "source": "try {\n    $note = $client->getAccountNote($account_id, $account_node_id);\n\n    echo 'Got Account Note:' . PHP_EOL;\n    var_dump($note);\n} catch (\\Recurly\\Errors\\NotFound $e) {\n    // Could not find the resource, you may want to inform the user\n    // or just return a NULL\n    echo 'Could not find resource.' . PHP_EOL;\n    var_dump($e);\n} catch (\\Recurly\\RecurlyError $e) {\n    // Something bad happened... tell the user so that they can fix it?\n    echo 'Some unexpected Recurly error happened. Try again later.' . PHP_EOL;\n}\n"
          },
          {
            "lang": "Go",
            "source": "accountNote, err := client.GetAccountNote(accountID, accountNoteID)\nif e, ok := err.(*recurly.Error); ok {\n\tif e.Type == recurly.ErrorTypeNotFound {\n\t\tfmt.Printf(\"Resource not found: %v\", e)\n\t\treturn nil, err\n\t}\n\tfmt.Printf(\"Unexpected Recurly error: %v\", e)\n\treturn nil, err\n}\nfmt.Printf(\"Fetched Account Note: %v\", accountNote)"
          }
        ]
      }
    },
    "/accounts/{account_id}/shipping_addresses": {
      "get": {
        "tags": [
          "shipping_address"
        ],
        "operationId": "list_shipping_addresses",
        "summary": "Fetch a list of an account's shipping addresses",
        "description": "See the [Pagination Guide](/developers/guides/pagination.html) to learn how to use pagination in the API and Client Libraries.",
        "parameters": [
          {
            "$ref": "#/components/parameters/account_id"
          },
          {
            "$ref": "#/components/parameters/ids"
          },
          {
            "$ref": "#/components/parameters/limit"
          },
          {
            "$ref": "#/components/parameters/order"
          },
          {
            "$ref": "#/components/parameters/sort_dates"
          },
          {
            "$ref": "#/components/parameters/filter_begin_time"
          },
          {
            "$ref": "#/components/parameters/filter_end_time"
          }
        ],
        "responses": {
          "200": {
            "description": "A list of an account's shipping addresses.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ShippingAddressList"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site or account ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": [
          {
            "lang": "Node.js",
            "source": "const addresses = client.listShippingAddresses(accountId, { params: { limit: 200 } })\n\nfor await (const address of addresses.each()) {\n  console.log(address.street1)\n}\n"
          },
          {
            "lang": "Python",
            "source": "shipping_addresses = client.list_shipping_addresses(account_id).items()\nfor shipping_address in shipping_addresses:\n    print(shipping_address.id)\n"
          },
          {
            "lang": ".NET",
            "source": "var addresses = client.ListShippingAddresses(accountId);\nforeach(ShippingAddress address in addresses)\n{\n    Console.WriteLine(address.Street1);\n}\n"
          },
          {
            "lang": "Ruby",
            "source": "params = {\n  limit: 200\n}\nshipping_addresses = @client.list_shipping_addresses(\n  account_id: account_id,\n  params: params\n)\nshipping_addresses.each do |addr|\n  puts \"ShippingAddress: #{addr.nickname} - #{addr.street1}\"\nend\n"
          },
          {
            "lang": "Java",
            "source": "QueryParams params = new QueryParams();\nparams.setLimit(200); // Pull 200 records at a time\nfinal Pager<ShippingAddress> addresses = client.listShippingAddresses(accountId, params);\n\nfor (ShippingAddress address : addresses) {\n    System.out.println(address.getStreet1());\n}\n"
          },
          {
            "lang": "PHP",
            "source": "$options = [\n  'params' => [\n    'limit' => 200\n  ]\n];\n$shippingAddresses = $client->listShippingAddresses($account_id, $options);\n\nforeach($shippingAddresses as $address) {\n  echo 'Shipping Address: ' . $address->getId() . PHP_EOL;\n}\n"
          },
          {
            "lang": "Go",
            "source": "listParams := &recurly.ListShippingAddressesParams{\n\tSort:  recurly.String(\"created_at\"),\n\tOrder: recurly.String(\"desc\"),\n\tLimit: recurly.Int(200),\n}\nshippingAddresses, err := client.ListShippingAddresses(accountID, listParams)\nif err != nil {\n\tfmt.Println(\"Unexpected error: %v\", err)\n\treturn\n}\n\nfor shippingAddresses.HasMore() {\n\terr := shippingAddresses.Fetch()\n\tif e, ok := err.(*recurly.Error); ok {\n\t\tfmt.Printf(\"Failed to retrieve next page: %v\", e)\n\t\tbreak\n\t}\n\tfor i, shippingAddress := range shippingAddresses.Data() {\n\t\tfmt.Printf(\"Shipping Address %3d: %s, %s\\n\",\n\t\t\ti,\n\t\t\tshippingAddress.Id,\n\t\t\tshippingAddress.Street1,\n\t\t)\n\t}\n}"
          }
        ]
      },
      "post": {
        "tags": [
          "shipping_address"
        ],
        "operationId": "create_shipping_address",
        "summary": "Create a new shipping address for the account",
        "parameters": [
          {
            "$ref": "#/components/parameters/account_id"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ShippingAddressCreate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Returns the new shipping address.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ShippingAddress"
                }
              }
            }
          },
          "400": {
            "description": "Bad request; perhaps missing or invalid parameters.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site or account ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "422": {
            "description": "A validation error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": [
          {
            "lang": "Node.js",
            "source": "try {\n  const shippingAddressCreate = {\n    firstName: 'Aaron',\n    lastName: 'Du Monde',\n    street1: '900 Camp St.',\n    city: 'New Orleans',\n    region: 'LA',\n    postalCode: '70115',\n    country: 'US'\n  }\n  const address = await client.createShippingAddress(accountId, shippingAddressCreate)\n  console.log('Created shipping address: ', address.street1)\n} catch (err) {\n  if (err instanceof recurly.errors.ValidationError) {\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in err.params\n    console.log('Failed validation', err.params)\n  } else {\n    // If we don't know what to do with the err, we should\n    // probably re-raise and let our web framework and logger handle it\n    console.log('Unknown Error: ', err)\n  }\n}\n"
          },
          {
            "lang": "Python",
            "source": "try:\n    shipping_addr_create = {\n        \"first_name\": \"Aaron\",\n        \"last_name\": \"Du Monde\",\n        \"street1\": \"900 Camp St.\",\n        \"city\": \"New Orleans\",\n        \"postal_code\": \"70115\",\n        \"country\": \"US\",\n    }\n    shad = client.create_shipping_address(account_id, shipping_addr_create)\n    print(\"Created ShippingAddress %s\" % shad)\nexcept recurly.errors.ValidationError as e:\n    # If the request was invalid, you may want to tell your user\n    # why. You can find the invalid params and reasons in e.error.params\n    print(\"ValidationError: %s\" % e.error.message)\n    print(e.error.params)\n"
          },
          {
            "lang": ".NET",
            "source": "try\n{\n    var addrReq = new ShippingAddressCreate()\n    {\n        FirstName = \"Benjamin\",\n        LastName = \"Du Monde\",\n        Street1 = \"900 Camp St.\",\n        City = \"New Orleans\",\n        Region = \"LA\",\n        PostalCode = \"70115\",\n        Country = \"US\",\n    };\n    ShippingAddress address = client.CreateShippingAddress(accountId, addrReq);\n    Console.WriteLine($\"Created shipping address {address.Street1}\");\n}\ncatch (Recurly.Errors.Validation ex)\n{\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in ex.Error.Params\n    Console.WriteLine($\"Failed validation: {ex.Error.Message}\");\n}\ncatch (Recurly.Errors.ApiError ex)\n{\n    // Use ApiError to catch a generic error from the API\n    Console.WriteLine($\"Unexpected Recurly Error: {ex.Error.Message}\");\n}\n"
          },
          {
            "lang": "Ruby",
            "source": "begin\n  shipping_address_create = {\n    nickname: 'Work',\n    street1: '900 Camp St',\n    city: 'New Orleans',\n    region: 'LA',\n    country: 'US',\n    postal_code: '70115',\n    first_name: 'Joanna',\n    last_name: 'Du Monde'\n  }\n  shipping_address = @client.create_shipping_address(account_id: account_id, body: shipping_address_create)\n  puts \"Created Shipping Address #{shipping_address}\"\nrescue Recurly::Errors::NotFoundError\n  # If the resource was not found, you may want to alert the user or\n  # just return nil\n  puts \"Resource Not Found\"\nend\n"
          },
          {
            "lang": "Java",
            "source": "try {\n    ShippingAddressCreate shippingAddressCreate = new ShippingAddressCreate();\n    shippingAddressCreate.setFirstName(\"Aaron\");\n    shippingAddressCreate.setLastName(\"Du Monde\");\n    shippingAddressCreate.setStreet1(\"900 Camp St\");\n    shippingAddressCreate.setCity(\"New Orleans\");\n    shippingAddressCreate.setRegion(\"LA\");\n    shippingAddressCreate.setPostalCode(\"70115\");\n    shippingAddressCreate.setCountry(\"US\");\n\n    ShippingAddress shippingAddress = client.createShippingAddress(accountId, shippingAddressCreate);\n    System.out.println(\"Created shipping address \" + shippingAddress.getStreet1());\n} catch (ValidationException e) {\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in e.getError().getParams()\n    System.out.println(\"Failed validation: \" + e.getError().getMessage());\n} catch (ApiException e) {\n    // Use ApiException to catch a generic error from the API\n    System.out.println(\"Unexpected Recurly Error: \" + e.getError().getMessage());\n}\n"
          },
          {
            "lang": "PHP",
            "source": "try {\n    $address_create = [\n        \"nickname\" => \"Work\",\n        \"street1\" => \"900 Camp St\",\n        \"city\" => \"New Orleans\",\n        \"region\" => \"LA\",\n        \"country\" => \"US\",\n        \"postal_code\" => \"70115\",\n        \"first_name\" => \"Douglas\",\n        \"last_name\" => \"Du Monde\"\n    ];\n    $shipping_address = $client->createShippingAddress($account_id, $address_create);\n\n    echo \"Created Shpping Address:\" . PHP_EOL;\n    var_dump($shipping_address);\n} catch (\\Recurly\\Errors\\Validation $e) {\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in err.params\n    var_dump($e);\n} catch (\\Recurly\\RecurlyError $e) {\n    // If we don\"t know what to do with the err, we should\n    // probably re-raise and let our web framework and logger handle it\n    var_dump($e);\n}\n"
          },
          {
            "lang": "Go",
            "source": "shippingReq := &recurly.ShippingAddressCreate{\n\tNickname:   recurly.String(\"Home\"),\n\tStreet1:    recurly.String(\"1 Tchoupitoulas St\"),\n\tCity:       recurly.String(\"New Orleans\"),\n\tRegion:     recurly.String(\"LA\"),\n\tCountry:    recurly.String(\"US\"),\n\tPostalCode: recurly.String(\"70115\"),\n\tFirstName:  recurly.String(\"Aaron\"),\n\tLastName:   recurly.String(\"Du Monde\"),\n}\n\nshippingAddress, err := client.CreateShippingAddress(accountID, shippingReq)\nif e, ok := err.(*recurly.Error); ok {\n\tif e.Type == recurly.ErrorTypeValidation {\n\t\tfmt.Printf(\"Failed validation: %v\", e)\n\t\treturn nil, err\n\t}\n\tfmt.Printf(\"Unexpected Recurly error: %v\", e)\n\treturn nil, err\n}\nfmt.Printf(\"Created Shipping Address: %v\", shippingAddress.Id)"
          }
        ]
      }
    },
    "/accounts/{account_id}/shipping_addresses/{shipping_address_id}": {
      "get": {
        "tags": [
          "shipping_address"
        ],
        "operationId": "get_shipping_address",
        "summary": "Fetch an account's shipping address",
        "parameters": [
          {
            "$ref": "#/components/parameters/account_id"
          },
          {
            "$ref": "#/components/parameters/shipping_address_id"
          }
        ],
        "responses": {
          "200": {
            "description": "A shipping address.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ShippingAddress"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site, account, or shipping address ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": [
          {
            "lang": "Node.js",
            "source": "try {\n  const address = await client.getShippingAddress(accountId, shippingAddressId)\n  console.log('Fetched shipping address: ', address.street1)\n} catch (err) {\n  if (err instanceof recurly.errors.NotFoundError) {\n    // If the request was not found, you may want to alert the user or\n    // just return null\n    console.log('Resource Not Found')\n  } else {\n    // If we don't know what to do with the err, we should\n    // probably re-raise and let our web framework and logger handle it\n    console.log('Unknown Error: ', err)\n  }\n}\n"
          },
          {
            "lang": "Python",
            "source": "try:\n    client.get_shipping_address(account_id, shipping_address_id)\n    print(\"Got ShippingAddress %s\" % shipping_address_id)\nexcept recurly.errors.NotFoundError:\n    # If the resource was not found, you may want to alert the user or\n    # just return nil\n    print(\"Resource Not Found\")\n"
          },
          {
            "lang": ".NET",
            "source": "try\n{\n    ShippingAddress address = client.GetShippingAddress(accountId, shippingAddressId);\n    Console.WriteLine($\"Fetched shipping address {address.Id}\");\n}\ncatch (Recurly.Errors.NotFound ex)\n{\n    // If the resource was not found\n    // we may want to alert the user or just return null\n    Console.WriteLine($\"Resource Not Found: {ex.Error.Message}\");\n}\ncatch (Recurly.Errors.ApiError ex)\n{\n    // Use ApiError to catch a generic error from the API\n    Console.WriteLine($\"Unexpected Recurly Error: {ex.Error.Message}\");\n}\n"
          },
          {
            "lang": "Ruby",
            "source": "begin\n  address = @client.get_shipping_address(\n    account_id: account_id,\n    shipping_address_id: shipping_address_id\n  )\n  puts \"Got ShippingAddress #{address}\"\nrescue Recurly::Errors::NotFoundError\n  # If the resource was not found, you may want to alert the user or\n  # just return nil\n  puts \"Resource Not Found\"\nend\n"
          },
          {
            "lang": "Java",
            "source": "try {\n    final ShippingAddress address = client.getShippingAddress(accountId, shippingAddressId);\n    System.out.println(\"Fetched shipping address \" + address.getId());\n} catch (NotFoundException e) {\n    // If the resource was not found\n    // we may want to alert the user or just return null\n    System.out.println(\"Resource Not Found: \" + e.getError().getMessage());\n} catch (ApiException e) {\n    // Use ApiException to catch a generic error from the API\n    System.out.println(\"Unexpected Recurly Error: \" + e.getError().getMessage());\n}\n"
          },
          {
            "lang": "PHP",
            "source": "try {\n    $shipping_address = $client->getShippingAddress($account_id, $shipping_address_id);\n\n    echo 'Got Shipping Address:' . PHP_EOL;\n    var_dump($shipping_address);\n} catch (\\Recurly\\Errors\\NotFound $e) {\n    // Could not find the resource, you may want to inform the user\n    // or just return a NULL\n    echo 'Could not find resource.' . PHP_EOL;\n    var_dump($e);\n} catch (\\Recurly\\RecurlyError $e) {\n    // Something bad happened... tell the user so that they can fix it?\n    echo 'Some unexpected Recurly error happened. Try again later.' . PHP_EOL;\n}\n"
          },
          {
            "lang": "Go",
            "source": "shippingAddress, err := client.GetShippingAddress(accountID, shippingAddressID)\nif e, ok := err.(*recurly.Error); ok {\n\tif e.Type == recurly.ErrorTypeNotFound {\n\t\tfmt.Printf(\"Resource not found: %v\", e)\n\t\treturn nil, err\n\t}\n\tfmt.Printf(\"Unexpected Recurly error: %v\", e)\n\treturn nil, err\n}\nfmt.Printf(\"Fetched Shipping Address: %v\", shippingAddress)"
          }
        ]
      },
      "put": {
        "tags": [
          "shipping_address"
        ],
        "operationId": "update_shipping_address",
        "summary": "Update an account's shipping address",
        "parameters": [
          {
            "$ref": "#/components/parameters/account_id"
          },
          {
            "$ref": "#/components/parameters/shipping_address_id"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ShippingAddressUpdate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "The updated shipping address.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ShippingAddress"
                }
              }
            }
          },
          "400": {
            "description": "Bad request, perhaps invalid JSON?",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site, account, or shipping address ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "422": {
            "description": "Invalid request parameters",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": [
          {
            "lang": "Node.js",
            "source": "try {\n  const shadUpdate = {\n    firstName: \"Benjamin\",\n    lastName: \"Du Monde\"\n  }\n  const address = await client.updateShippingAddress(accountId, shippingAddressId, shadUpdate)\n  console.log('Updated shipping address: ', address.street1)\n} catch (err) {\n  if (err instanceof recurly.errors.ValidationError) {\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in err.params\n    console.log('Failed validation', err.params)\n  } else {\n    // If we don't know what to do with the err, we should\n    // probably re-raise and let our web framework and logger handle it\n    console.log('Unknown Error: ', err)\n  }\n}\n"
          },
          {
            "lang": "Python",
            "source": "try:\n    address_update = {\n        \"first_name\": \"Aaron\",\n        \"last_name\": \"Du Monde\",\n        \"postal_code\": \"70130\",\n    }\n    address = client.update_shipping_address(\n        account_id, shipping_address_id, address_update\n    )\n    print(\"Updated ShippingAddress %s\" % address)\nexcept recurly.errors.ValidationError as e:\n    # If the request was invalid, you may want to tell your user\n    # why. You can find the invalid params and reasons in e.error.params\n    print(\"ValidationError: %s\" % e.error.message)\n    print(e.error.params)\n"
          },
          {
            "lang": ".NET",
            "source": "try\n{\n    var shadReq = new ShippingAddressUpdate()\n    {\n        FirstName = \"Aaron\",\n        LastName = \"Du Monde\"\n    };\n    ShippingAddress address = client.UpdateShippingAddress(accountId, shippingAddressId, shadReq);\n    Console.WriteLine($\"Updated shipping address {address.Street1}\");\n}\ncatch (Recurly.Errors.Validation ex)\n{\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in ex.Error.Params\n    Console.WriteLine($\"Failed validation: {ex.Error.Message}\");\n}\ncatch (Recurly.Errors.ApiError ex)\n{\n    // Use ApiError to catch a generic error from the API\n    Console.WriteLine($\"Unexpected Recurly Error: {ex.Error.Message}\");\n}\n"
          },
          {
            "lang": "Ruby",
            "source": "begin\n  address_update = {\n    first_name: \"Aaron\",\n    last_name: \"Du Monde\",\n    postal_code: \"70130\"\n  }\n  address = @client.update_shipping_address(\n    account_id: account_id,\n    shipping_address_id: shipping_address_id,\n    body: address_update\n  )\n  puts \"Updated ShippingAddress #{address}\"\nrescue Recurly::Errors::ValidationError => e\n  # If the request was invalid, you may want to tell your user\n  # why. You can find the invalid params and reasons in e.recurly_error.params\n  puts \"ValidationError: #{e.recurly_error.params}\"\nend\n"
          },
          {
            "lang": "Java",
            "source": "try {\n    final ShippingAddressUpdate shadUpdate = new ShippingAddressUpdate();\n    shadUpdate.setFirstName(\"Aaron\");\n    shadUpdate.setLastName(\"Du Monde\");\n\n    final ShippingAddress address = client.updateShippingAddress(accountId, shippingAddressId, shadUpdate);\n    System.out.println(\"Updated shipping address \" + address.getStreet1());\n} catch (ValidationException e) {\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in e.getError().getParams()\n    System.out.println(\"Failed validation: \" + e.getError().getMessage());\n} catch (ApiException e) {\n    // Use ApiException to catch a generic error from the API\n    System.out.println(\"Unexpected Recurly Error: \" + e.getError().getMessage());\n}\n"
          },
          {
            "lang": "PHP",
            "source": "try {\n    $shad_update = [\n        \"first_name\" => \"Douglas\",\n        \"last_name\" => \"Du Monde\",\n    ];\n    $shad = $client->updateShippingAddress($account_id, $shipping_address_id, $shad_update);\n\n    echo 'Updated Shipping Address:' . PHP_EOL;\n    var_dump($shad);\n} catch (\\Recurly\\Errors\\Validation $e) {\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in err.params\n    var_dump($e);\n} catch (\\Recurly\\RecurlyError $e) {\n    // If we don't know what to do with the err, we should\n    // probably re-raise and let our web framework and logger handle it\n    var_dump($e);\n}\n"
          },
          {
            "lang": "Go",
            "source": "updateReq := &recurly.ShippingAddressUpdate{\n\tFirstName: recurly.String(\"Joanna\"),\n\tLastName:  recurly.String(\"DuMonde\"),\n}\nshippingAddress, err := client.UpdateShippingAddress(accountID, shippingAddressID, updateReq)\nif e, ok := err.(*recurly.Error); ok {\n\tif e.Type == recurly.ErrorTypeNotFound {\n\t\tfmt.Printf(\"Resource not found: %v\", e)\n\t\treturn nil, err\n\t}\n\tfmt.Printf(\"Unexpected Recurly error: %v\", e)\n\treturn nil, err\n}\nfmt.Printf(\"Updated Shipping Address: %v\", shippingAddress)"
          }
        ]
      },
      "delete": {
        "tags": [
          "shipping_address"
        ],
        "operationId": "remove_shipping_address",
        "summary": "Remove an account's shipping address",
        "parameters": [
          {
            "$ref": "#/components/parameters/account_id"
          },
          {
            "$ref": "#/components/parameters/shipping_address_id"
          }
        ],
        "responses": {
          "204": {
            "description": "Shipping address deleted."
          },
          "404": {
            "description": "Incorrect site, account, or shipping address ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": [
          {
            "lang": "Node.js",
            "source": "try {\n  await client.removeShippingAddress(accountId, shippingAddress.id)\n  console.log('Removed shipping address: ', shippingAddress.street1)\n} catch (err) {\n  if (err instanceof recurly.errors.NotFoundError) {\n    // If the request was not found, you may want to alert the user or\n    // just return null\n    console.log('Resource Not Found')\n  } else {\n    // If we don't know what to do with the err, we should\n    // probably re-raise and let our web framework and logger handle it\n    console.log('Unknown Error: ', err)\n  }\n}\n"
          },
          {
            "lang": "Python",
            "source": "try:\n    client.remove_shipping_address(account_id, shipping_address_id)\n    print(\"Removed ShippingAddress %s\" % shipping_address_id)\nexcept recurly.errors.NotFoundError:\n    # If the resource was not found, you may want to alert the user or\n    # just return nil\n    print(\"Resource Not Found\")\n"
          },
          {
            "lang": ".NET",
            "source": "try\n{\n    client.RemoveShippingAddress(accountId, shippingAddressId);\n    Console.WriteLine($\"Removed shipping address {shippingAddressId}\");\n}\ncatch (Recurly.Errors.Validation ex)\n{\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in ex.Error.Params\n    Console.WriteLine($\"Failed validation: {ex.Error.Message}\");\n}\ncatch (Recurly.Errors.ApiError ex)\n{\n    // Use ApiError to catch a generic error from the API\n    Console.WriteLine($\"Unexpected Recurly Error: {ex.Error.Message}\");\n}\n"
          },
          {
            "lang": "Ruby",
            "source": "begin\n  @client.remove_shipping_address(\n    account_id: account_id,\n    shipping_address_id: shipping_address_id\n  )\n  puts \"Removed ShippingAddress #{shipping_address_id}\"\nrescue Recurly::Errors::NotFoundError\n  # If the resource was not found, you may want to alert the user or\n  # just return nil\n  puts \"Resource Not Found\"\nend\n"
          },
          {
            "lang": "Java",
            "source": "try {\n    client.removeShippingAddress(accountId, shippingAddressId);\n    System.out.println(\"Removed shipping address \" + shippingAddressId);\n} catch (ValidationException e) {\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in e.getError().getParams()\n    System.out.println(\"Failed validation: \" + e.getError().getMessage());\n} catch (ApiException e) {\n    // Use ApiException to catch a generic error from the API\n    System.out.println(\"Unexpected Recurly Error: \" + e.getError().getMessage());\n}\n"
          },
          {
            "lang": "PHP",
            "source": "try {\n    $client->removeShippingAddress($account_id, $shipping_address_id);\n    echo \"Removed Shipping Address:\" . PHP_EOL;\n} catch (\\Recurly\\Errors\\Validation $e) {\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in err.params\n    var_dump($e);\n} catch (\\Recurly\\RecurlyError $e) {\n    // If we don't know what to do with the err, we should\n    // probably re-raise and let our web framework and logger handle it\n    var_dump($e);\n}"
          },
          {
            "lang": "Go",
            "source": "shippingAddress, err := client.RemoveShippingAddress(accountID, shippingAddressID)\nif e, ok := err.(*recurly.Error); ok {\n\tif e.Type == recurly.ErrorTypeNotFound {\n\t\tfmt.Printf(\"Resource not found: %v\", e)\n\t\treturn nil, err\n\t}\n\tfmt.Printf(\"Unexpected Recurly error: %v\", e)\n\treturn nil, err\n}\n\nfmt.Printf(\"Removed Shipping Address: %v\", shippingAddress)"
          }
        ]
      }
    },
    "/accounts/{account_id}/subscriptions": {
      "get": {
        "tags": [
          "subscription"
        ],
        "operationId": "list_account_subscriptions",
        "summary": "List an account's subscriptions",
        "description": "See the [Pagination Guide](/developers/guides/pagination.html) to learn how to use pagination in the API and Client Libraries.",
        "parameters": [
          {
            "$ref": "#/components/parameters/account_id"
          },
          {
            "$ref": "#/components/parameters/ids"
          },
          {
            "$ref": "#/components/parameters/limit"
          },
          {
            "$ref": "#/components/parameters/order"
          },
          {
            "$ref": "#/components/parameters/sort_dates"
          },
          {
            "$ref": "#/components/parameters/filter_begin_time"
          },
          {
            "$ref": "#/components/parameters/filter_end_time"
          },
          {
            "$ref": "#/components/parameters/filter_subscription_state"
          }
        ],
        "responses": {
          "200": {
            "description": "A list of the account's subscriptions.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SubscriptionList"
                }
              }
            }
          },
          "400": {
            "description": "Invalid or unpermitted parameter.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site or account ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": [
          {
            "lang": "Node.js",
            "source": "const subscriptions = client.listAccountSubscriptions(accountId, { params: { limit: 200 } })\n\nfor await (const subscription of subscriptions.each()) {\n  console.log(subscription.uuid)\n}\n"
          },
          {
            "lang": "Python",
            "source": "params = {\"limit\": 200}\nsubscriptions = client.list_account_subscriptions(account.id, params=params).items()\nfor subscription in subscriptions:\n    print(subscription.uuid)\n"
          },
          {
            "lang": ".NET",
            "source": "var subscriptions = client.ListAccountSubscriptions(accountId);\nforeach(Subscription subscription in subscriptions) {\n  Console.WriteLine(subscription.Id);\n}\n"
          },
          {
            "lang": "Ruby",
            "source": "params = {\n  limit: 200\n}\nsubscriptions = @client.list_account_subscriptions(\n  account_id: account_id,\n  params: params\n)\nsubscriptions.each do |subscription|\n  puts \"Subscription: #{subscription.uuid}\"\nend\n"
          },
          {
            "lang": "Java",
            "source": "QueryParams params = new QueryParams();\nparams.setLimit(200); // Pull 200 records at a time\nfinal Pager<Subscription> subscriptions = client.listAccountSubscriptions(accountId, params);\n\nfor (Subscription subscription : subscriptions) {\n    System.out.println(subscription.getUuid());\n}\n"
          },
          {
            "lang": "PHP",
            "source": "$options = [\n  'params' => [\n    'limit' => 200\n  ]\n];\n$account_subscriptions = $client->listAccountSubscriptions($account_id, $options);\n\nforeach($account_subscriptions as $sub) {\n  echo 'Account subscription: ' . $sub->getUuid() . PHP_EOL;\n}\n"
          },
          {
            "lang": "Go",
            "source": "listParams := &recurly.ListAccountSubscriptionsParams{\n\tSort:  recurly.String(\"created_at\"),\n\tOrder: recurly.String(\"desc\"),\n\tLimit: recurly.Int(200),\n}\naccountSubscriptions, err := client.ListAccountSubscriptions(accountID, listParams)\nif err != nil {\n\tfmt.Println(\"Unexpected error: %v\", err)\n\treturn\n}\n\nfor accountSubscriptions.HasMore() {\n\terr := accountSubscriptions.Fetch()\n\tif e, ok := err.(*recurly.Error); ok {\n\t\tfmt.Printf(\"Failed to retrieve next page: %v\", e)\n\t\tbreak\n\t}\n\tfor i, sub := range accountSubscriptions.Data() {\n\t\tfmt.Printf(\"Account Subscription %3d: %s\\n\",\n\t\t\ti,\n\t\t\tsub.Id,\n\t\t)\n\t}\n}"
          }
        ]
      }
    },
    "/accounts/{account_id}/transactions": {
      "get": {
        "tags": [
          "transaction"
        ],
        "operationId": "list_account_transactions",
        "summary": "List an account's transactions",
        "description": "See the [Pagination Guide](/developers/guides/pagination.html) to learn how to use pagination in the API and Client Libraries.",
        "parameters": [
          {
            "$ref": "#/components/parameters/account_id"
          },
          {
            "$ref": "#/components/parameters/ids"
          },
          {
            "$ref": "#/components/parameters/limit"
          },
          {
            "$ref": "#/components/parameters/order"
          },
          {
            "$ref": "#/components/parameters/sort_dates"
          },
          {
            "$ref": "#/components/parameters/filter_begin_time"
          },
          {
            "$ref": "#/components/parameters/filter_end_time"
          },
          {
            "$ref": "#/components/parameters/filter_transaction_type"
          },
          {
            "$ref": "#/components/parameters/filter_transaction_success"
          }
        ],
        "responses": {
          "200": {
            "description": "A list of the account's transactions.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TransactionList"
                }
              }
            }
          },
          "400": {
            "description": "Invalid or unpermitted parameter.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site or subscription ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": [
          {
            "lang": "Node.js",
            "source": "const transactions = client.listAccountTransactions(accountId, { params: { limit: 200 } })\n\nfor await (const transaction of transactions.each()) {\n  console.log(transaction.uuid)\n}\n"
          },
          {
            "lang": "Python",
            "source": "params = {\"limit\": 200}\ntransactions = client.list_account_transactions(account_id, params=params).items()\nfor transaction in transactions:\n    print(\"Transaction %s\" % transaction.id)\n"
          },
          {
            "lang": ".NET",
            "source": "var transactions = client.ListAccountTransactions(accountId);\nforeach(Transaction transaction in transactions)\n{\n    Console.WriteLine(transaction.Id);\n}\n"
          },
          {
            "lang": "Ruby",
            "source": "params = {\n  limit: 200\n}\ntransactions = @client.list_account_transactions(\n  account_id: account_id,\n  params: params\n)\ntransactions.each do |transaction|\n  puts \"Transaction: #{transaction.uuid}\"\nend\n"
          },
          {
            "lang": "Java",
            "source": "QueryParams params = new QueryParams();\nparams.setLimit(200); // Pull 200 records at a time\nfinal Pager<Transaction> transactions = client.listAccountTransactions(accountId, params);\n\nfor (Transaction transaction : transactions) {\n    System.out.println(transaction.getUuid());\n}\n"
          },
          {
            "lang": "PHP",
            "source": "$options = [\n  'params' => [\n    'limit' => 200\n  ]\n];\n$account_transactions = $client->listAccountTransactions($account_id, $options);\n\nforeach($account_transactions as $transaction) {\n  echo 'Account transactions: ' . $transaction->getUuid() . PHP_EOL;\n}\n"
          },
          {
            "lang": "Go",
            "source": "listParams := &recurly.ListAccountTransactionsParams{\n\tSort:  recurly.String(\"created_at\"),\n\tOrder: recurly.String(\"desc\"),\n\tLimit: recurly.Int(200),\n}\naccountTransactions, err := client.ListAccountTransactions(accountID, listParams)\nif err != nil {\n\tfmt.Println(\"Unexpected error: %v\", err)\n\treturn\n}\n\nfor accountTransactions.HasMore() {\n\terr := accountTransactions.Fetch()\n\tif e, ok := err.(*recurly.Error); ok {\n\t\tfmt.Printf(\"Failed to retrieve next page: %v\", e)\n\t\tbreak\n\t}\n\tfor i, transaction := range accountTransactions.Data() {\n\t\tfmt.Printf(\"Account Transaction %3d: %s\\n\",\n\t\t\ti,\n\t\t\ttransaction.Id,\n\t\t)\n\t}\n}"
          }
        ]
      }
    },
    "/accounts/{account_id}/accounts": {
      "get": {
        "tags": [
          "account"
        ],
        "operationId": "list_child_accounts",
        "summary": "List an account's child accounts",
        "description": "See the [Pagination Guide](/developers/guides/pagination.html) to learn how to use pagination in the API and Client Libraries.",
        "parameters": [
          {
            "$ref": "#/components/parameters/account_id"
          },
          {
            "$ref": "#/components/parameters/ids"
          },
          {
            "$ref": "#/components/parameters/limit"
          },
          {
            "$ref": "#/components/parameters/order"
          },
          {
            "$ref": "#/components/parameters/sort_dates"
          },
          {
            "$ref": "#/components/parameters/filter_begin_time"
          },
          {
            "$ref": "#/components/parameters/filter_end_time"
          },
          {
            "$ref": "#/components/parameters/filter_account_email"
          },
          {
            "$ref": "#/components/parameters/filter_account_subscriber"
          },
          {
            "$ref": "#/components/parameters/filter_account_past_due"
          }
        ],
        "responses": {
          "200": {
            "description": "A list of an account's child accounts.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AccountList"
                }
              }
            }
          },
          "400": {
            "description": "Invalid or unpermitted parameter.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site or account ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": [
          {
            "lang": "Python",
            "source": "params = {\"limit\": 200}\nchild_accounts = client.list_child_accounts(account_id, params=params).items()\nfor account in child_accounts:\n    print(\"Child Account %s\" % account.code)\n"
          },
          {
            "lang": "Ruby",
            "source": "params = {\n  limit: 200\n}\nchild_accounts = @client.list_child_accounts(\n  account_id: account_id,\n  params: params\n)\nchild_accounts.each do |child|\n  puts \"Account: #{child.code}\"\nend\n"
          },
          {
            "lang": "PHP",
            "source": "$options = [\n  'params' => [\n    'limit' => 200\n  ]\n];\n$child_accounts = $client->listChildAccounts($account_id, $options);\n\nforeach($child_accounts as $child_account) {\n  echo 'Child Account: ' . $child_account->getId() . PHP_EOL;\n}\n"
          },
          {
            "lang": "Go",
            "source": "listParams := &recurly.ListChildAccountsParams{\n\tSort:  recurly.String(\"created_at\"),\n\tOrder: recurly.String(\"desc\"),\n\tLimit: recurly.Int(200),\n}\naccounts, err := client.ListChildAccounts(accountID, listParams)\nif err != nil {\n\tfmt.Println(\"Unexpected error: %v\", err)\n\treturn\n}\n\nfor accounts.HasMore() {\n\terr := accounts.Fetch()\n\tif e, ok := err.(*recurly.Error); ok {\n\t\tfmt.Printf(\"Failed to retrieve next page: %v\", e)\n\t\tbreak\n\t}\n\tfor i, account := range accounts.Data() {\n\t\tfmt.Printf(\"Child Account %3d: %s, %s\\n\",\n\t\t\ti,\n\t\t\taccount.Id,\n\t\t\taccount.Code,\n\t\t)\n\t}\n}"
          }
        ]
      }
    },
    "/acquisitions": {
      "get": {
        "tags": [
          "account_acquisition"
        ],
        "operationId": "list_account_acquisition",
        "summary": "List a site's account acquisition data",
        "description": "See the [Pagination Guide](/developers/guides/pagination.html) to learn how to use pagination in the API and Client Libraries.",
        "parameters": [
          {
            "$ref": "#/components/parameters/ids"
          },
          {
            "$ref": "#/components/parameters/limit"
          },
          {
            "$ref": "#/components/parameters/order"
          },
          {
            "$ref": "#/components/parameters/sort_dates"
          },
          {
            "$ref": "#/components/parameters/filter_begin_time"
          },
          {
            "$ref": "#/components/parameters/filter_end_time"
          }
        ],
        "responses": {
          "200": {
            "description": "A list of the site's account acquisition data.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AccountAcquisitionList"
                }
              }
            }
          },
          "400": {
            "description": "Invalid or unpermitted parameter.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": [
          {
            "lang": "Node.js",
            "source": "const acquisitions = client.listAccountAcquisition({ params: { limit: 200 } })\n\nfor await (const acquisition of acquisitions.each()) {\n  console.log(acquisition.id)\n}\n"
          },
          {
            "lang": "Python",
            "source": "params = {\"limit\": 200}\nacquisitions = client.list_account_acquisition(params=params).items()\nfor acquisition in acquisitions:\n    print(acquisition.id)\n"
          },
          {
            "lang": ".NET",
            "source": "var acquisitions = client.ListAccountAcquisition();\nforeach(AccountAcquisition acquisition in acquisitions)\n{\n    Console.WriteLine(acquisition.Id);\n}\n"
          },
          {
            "lang": "Ruby",
            "source": "params = {\n  limit: 200\n}\nacquisitions = @client.list_account_acquisition(params: params)\nacquisitions.each do |acquisition|\n  puts \"AccountAcquisition: #{acquisition.cost}\"\nend\n"
          },
          {
            "lang": "Java",
            "source": "QueryParams params = new QueryParams();\nparams.setLimit(200); // Pull 200 records at a time\nfinal Pager<AccountAcquisition> acquisitions = client.listAccountAcquisition(params);\n\nfor (AccountAcquisition acquisition : acquisitions) {\n    System.out.println(acquisition.getId());\n}\n"
          },
          {
            "lang": "PHP",
            "source": "$options = [\n  'params' => [\n    'limit' => 200\n  ]\n];\n$account_acquisition = $client->listAccountAcquisition($options);\n\nforeach($account_acquisition as $aa) {\n  echo 'Account acquisition: ' . $aa->getId() . PHP_EOL;\n}\n"
          },
          {
            "lang": "Go",
            "source": "listParams := &recurly.ListAccountAcquisitionParams{\n\tSort:  recurly.String(\"created_at\"),\n\tOrder: recurly.String(\"asc\"),\n\tLimit: recurly.Int(200),\n}\naccountAcquisition, err := client.ListAccountAcquisition(listParams)\nif err != nil {\n\tfmt.Println(\"Unexpected error: %v\", err)\n\treturn\n}\n\nfor accountAcquisition.HasMore() {\n\terr := accountAcquisition.Fetch()\n\tif e, ok := err.(*recurly.Error); ok {\n\t\tfmt.Printf(\"Failed to retrieve next page: %v\", e)\n\t\tbreak\n\t}\n\tfor i, a := range accountAcquisition.Data() {\n\t\tfmt.Printf(\"Account Acquisition %3d: %s\\n\",\n\t\t\ti,\n\t\t\ta.Id,\n\t\t)\n\t}\n}"
          }
        ]
      }
    },
    "/coupons": {
      "get": {
        "tags": [
          "coupon"
        ],
        "operationId": "list_coupons",
        "summary": "List a site's coupons",
        "description": "See the [Pagination Guide](/developers/guides/pagination.html) to learn how to use pagination in the API and Client Libraries.",
        "parameters": [
          {
            "$ref": "#/components/parameters/ids"
          },
          {
            "$ref": "#/components/parameters/limit"
          },
          {
            "$ref": "#/components/parameters/order"
          },
          {
            "$ref": "#/components/parameters/sort_dates"
          },
          {
            "$ref": "#/components/parameters/filter_begin_time"
          },
          {
            "$ref": "#/components/parameters/filter_end_time"
          }
        ],
        "responses": {
          "200": {
            "description": "A list of the site's coupons.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CouponList"
                }
              }
            }
          },
          "400": {
            "description": "Invalid or unpermitted parameter.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": [
          {
            "lang": "Node.js",
            "source": "const coupons = client.listCoupons({ params: { limit: 200 } })\n\nfor await (const coupon of coupons.each()) {\n  console.log(coupon.code)\n}\n"
          },
          {
            "lang": "Python",
            "source": "params = {\"limit\": 200}\ncoupons = client.list_coupons(params=params).items()\nfor coupon in coupons:\n    print(coupon.code)\n"
          },
          {
            "lang": ".NET",
            "source": "var optionalParams = new ListCouponsParams()\n{\n    Limit = 200\n};\nvar coupons = client.ListCoupons(optionalParams);\nforeach(Coupon coupon in coupons)\n{\n    Console.WriteLine(coupon.Code);\n}\n"
          },
          {
            "lang": "Ruby",
            "source": "params = {\n  limit: 200\n}\ncoupons = @client.list_coupons(params: params)\ncoupons.each do |coupon|\n  puts \"coupon: #{coupon.code}\"\nend\n"
          },
          {
            "lang": "Java",
            "source": "QueryParams params = new QueryParams();\nparams.setLimit(200); // Pull 200 records at a time\nfinal Pager<Coupon> coupons = client.listCoupons(params);\n\nfor (Coupon coupon : coupons) {\n    System.out.println(coupon.getCode());\n}\n"
          },
          {
            "lang": "PHP",
            "source": "$options = [\n  'params' => [\n    'limit' => 200\n  ]\n];\n$coupons = $client->listCoupons($options);\n\nforeach($coupons as $coupon) {\n  echo 'Coupon: ' . $coupon->getCode() . PHP_EOL;\n}\n"
          },
          {
            "lang": "Go",
            "source": "listParams := &recurly.ListCouponsParams{\n\tSort:  recurly.String(\"created_at\"),\n\tOrder: recurly.String(\"desc\"),\n\tLimit: recurly.Int(200),\n}\ncoupons, err := client.ListCoupons(listParams)\nif err != nil {\n\tfmt.Println(\"Unexpected error: %v\", err)\n\treturn\n}\n\nfor coupons.HasMore() {\n\terr := coupons.Fetch()\n\tif e, ok := err.(*recurly.Error); ok {\n\t\tfmt.Printf(\"Failed to retrieve next page: %v\", e)\n\t\tbreak\n\t}\n\tfor i, coupon := range coupons.Data() {\n\t\tfmt.Printf(\"Coupon %3d: %s, %s\\n\",\n\t\t\ti,\n\t\t\tcoupon.Id,\n\t\t\tcoupon.Code,\n\t\t)\n\t}\n}"
          }
        ]
      },
      "post": {
        "tags": [
          "coupon"
        ],
        "operationId": "create_coupon",
        "summary": "Create a new coupon",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CouponCreate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "A new coupon.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Coupon"
                }
              }
            }
          },
          "400": {
            "description": "Bad request, perhaps invalid JSON?",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "422": {
            "description": "Invalid request parameters.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": [
          {
            "lang": "Node.js",
            "source": "try {\n  const couponCreate = {\n    name: \"Promotional Coupon\",\n    code: couponCode,\n    discount_type: \"fixed\",\n    currencies: [{\"currency\": \"USD\", \"discount\": 10}],\n  }\n  const coupon = await client.createCoupon(couponCreate)\n  console.log('Created coupon: ', coupon.id)\n} catch (err) {\n  if (err instanceof recurly.errors.ValidationError) {\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in err.params\n    console.log('Failed validation', err.params)\n  } else {\n    // If we don't know what to do with the err, we should\n    // probably re-raise and let our web framework and logger handle it\n    console.log('Unknown Error: ', err)\n  }\n}\n"
          },
          {
            "lang": "Python",
            "source": "try:\n    coupon_create = {\n        \"name\": \"Promotional Coupon\",\n        \"code\": coupon_code,\n        \"discount_type\": \"fixed\",\n        \"currencies\": [{\"currency\": \"USD\", \"discount\": 10000}],\n    }\n    coupon = client.create_coupon(coupon_create)\n    print(\"Created Coupon %s\" % coupon)\nexcept recurly.errors.ValidationError as e:\n    # If the request was invalid, you may want to tell your user\n    # why. You can find the invalid params and reasons in e.error.params\n    print(\"ValidationError: %s\" % e.error.message)\n    print(e.error.params)\n"
          },
          {
            "lang": ".NET",
            "source": "try\n{\n    var couponReq = new CouponCreate()\n    {\n        Name = \"Promotional Coupon\",\n        Code = couponCode,\n        DiscountType = DiscountType.Fixed,\n        Currencies = new List<CouponPricing>() {\n          new CouponPricing() {\n            Currency = \"USD\",\n            Discount = 1000\n          }\n        }\n    };\n    Coupon coupon = client.CreateCoupon(couponReq);\n    Console.WriteLine($\"Created coupon {coupon.Id}\");\n}\ncatch (Recurly.Errors.Validation ex)\n{\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in ex.Error.Params\n    Console.WriteLine($\"Failed validation: {ex.Error.Message}\");\n}\ncatch (Recurly.Errors.ApiError ex)\n{\n    // Use ApiError to catch a generic error from the API\n    Console.WriteLine($\"Unexpected Recurly Error: {ex.Error.Message}\");\n}\n"
          },
          {
            "lang": "Ruby",
            "source": "begin\n  coupon_create = {\n    name: \"Promotional Coupon\",\n    code: coupon_code,\n    discount_type: 'fixed',\n    currencies: [\n      {\n        currency: 'USD',\n        discount: 10_000\n      }\n    ]\n  }\n  coupon = @client.create_coupon(\n    body: coupon_create\n  )\n  puts \"Created Coupon #{coupon}\"\nrescue Recurly::Errors::ValidationError => e\n  # If the request was invalid, you may want to tell your user\n  # why. You can find the invalid params and reasons in e.recurly_error.params\n  puts \"ValidationError: #{e.recurly_error.params}\"\nend\n"
          },
          {
            "lang": "Java",
            "source": "try {\n    CouponCreate couponCreate = new CouponCreate();\n\n    couponCreate.setName(\"Promotional Coupon\");\n    couponCreate.setCode(couponCode);\n\n    List<CouponPricing> currencies = new ArrayList<CouponPricing>();\n    CouponPricing couponPrice = new CouponPricing();\n    couponPrice.setCurrency(\"USD\");\n    couponPrice.setDiscount(new BigDecimal(\"10.0\"));\n    currencies.add(couponPrice);\n\n    couponCreate.setCurrencies(currencies);\n    couponCreate.setDiscountType(Constants.DiscountType.FIXED);\n\n    Coupon coupon = client.createCoupon(couponCreate);\n    System.out.println(\"Created coupon \" + coupon.getCode());\n} catch (ValidationException e) {\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in e.getError().getParams()\n    System.out.println(\"Failed validation: \" + e.getError().getMessage());\n} catch (ApiException e) {\n    // Use ApiException to catch a generic error from the API\n    System.out.println(\"Unexpected Recurly Error: \" + e.getError().getMessage());\n}\n"
          },
          {
            "lang": "PHP",
            "source": "try {\n    $coupon_create = [\n        \"name\" => \"Promotional Coupon\",\n        \"code\" => $coupon_code,\n        \"discount_type\" => \"fixed\",\n        \"currencies\" => [\n            \"currency\" => \"USD\",\n            \"discount\" => 10\n        ]\n    ];\n\n    $coupon = $client->createCoupon($coupon_create);\n\n    echo 'Created Coupon:' . PHP_EOL;\n    var_dump($coupon);\n} catch (\\Recurly\\Errors\\Validation $e) {\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in err.params\n    var_dump($e);\n} catch (\\Recurly\\RecurlyError $e) {\n    // If we don't know what to do with the err, we should\n    // probably re-raise and let our web framework and logger handle it\n    var_dump($e);\n}\n"
          },
          {
            "lang": "Go",
            "source": "couponReq := &recurly.CouponCreate{\n\tName:                     recurly.String(\"Promotional Coupon\"),\n\tMaxRedemptions:           recurly.Int(50),\n\tMaxRedemptionsPerAccount: recurly.Int(1),\n\tCode:                     recurly.String(genUuid()),\n\tDiscountType:             recurly.String(\"percent\"),\n\tDiscountPercent:          recurly.Int(25),\n}\n\ncoupon, err := client.CreateCoupon(couponReq)\nif e, ok := err.(*recurly.Error); ok {\n\tif e.Type == recurly.ErrorTypeValidation {\n\t\tfmt.Printf(\"Failed validation: %v\", e)\n\t\treturn nil, err\n\t}\n\tfmt.Printf(\"Unexpected Recurly error: %v\", e)\n\treturn nil, err\n}\nfmt.Printf(\"Created Coupon: %v\", coupon.Id)"
          }
        ]
      }
    },
    "/coupons/{coupon_id}": {
      "get": {
        "tags": [
          "coupon"
        ],
        "operationId": "get_coupon",
        "summary": "Fetch a coupon",
        "parameters": [
          {
            "$ref": "#/components/parameters/coupon_id"
          }
        ],
        "responses": {
          "200": {
            "description": "A coupon.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Coupon"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site or coupon ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": [
          {
            "lang": "Node.js",
            "source": "try {\n  const coupon = await client.getCoupon(couponId)\n  console.log('Fetched coupon: ', coupon.code)\n} catch (err) {\n  if (err instanceof recurly.errors.NotFoundError) {\n    // If the request was not found, you may want to alert the user or\n    // just return null\n    console.log('Resource Not Found')\n  } else {\n    // If we don't know what to do with the err, we should\n    // probably re-raise and let our web framework and logger handle it\n    console.log('Unknown Error: ', err)\n  }\n}\n"
          },
          {
            "lang": "Python",
            "source": "try:\n    coupon = client.get_coupon(coupon_id)\n    print(\"Got Coupon %s\" % coupon)\nexcept recurly.errors.NotFoundError:\n    # If the resource was not found, you may want to alert the user or\n    # just return nil\n    print(\"Resource Not Found\")\n"
          },
          {
            "lang": ".NET",
            "source": "try\n{\n    Coupon coupon = client.GetCoupon(couponId);\n    Console.WriteLine($\"Fetched coupon {coupon.Code}\");\n}\ncatch (Recurly.Errors.NotFound ex)\n{\n    // If the resource was not found\n    // we may want to alert the user or just return null\n    Console.WriteLine($\"Resource Not Found: {ex.Error.Message}\");\n}\ncatch (Recurly.Errors.ApiError ex)\n{\n    // Use ApiError to catch a generic error from the API\n    Console.WriteLine($\"Unexpected Recurly Error: {ex.Error.Message}\");\n}\n"
          },
          {
            "lang": "Ruby",
            "source": "begin\n  coupon = @client.get_coupon(coupon_id: coupon_id)\n  puts \"Got Coupon #{coupon}\"\nrescue Recurly::Errors::NotFoundError\n  # If the resource was not found, you may want to alert the user or\n  # just return nil\n  puts \"Resource Not Found\"\nend\n"
          },
          {
            "lang": "Java",
            "source": "try {\n    final Coupon coupon = client.getCoupon(couponId);\n    System.out.println(\"Fetched coupon \" + coupon.getCode());\n} catch (NotFoundException e) {\n    // If the resource was not found\n    // we may want to alert the user or just return null\n    System.out.println(\"Resource Not Found: \" + e.getError().getMessage());\n} catch (ApiException e) {\n    // Use ApiException to catch a generic error from the API\n    System.out.println(\"Unexpected Recurly Error: \" + e.getError().getMessage());\n}\n"
          },
          {
            "lang": "PHP",
            "source": "try {\n    $coupon = $client->getCoupon($coupon_id);\n\n    echo 'Got Coupon:' . PHP_EOL;\n    var_dump($coupon);\n} catch (\\Recurly\\Errors\\NotFound $e) {\n    // Could not find the resource, you may want to inform the user\n    // or just return a NULL\n    echo 'Could not find resource.' . PHP_EOL;\n    var_dump($e);\n} catch (\\Recurly\\RecurlyError $e) {\n    // Something bad happened... tell the user so that they can fix it?\n    echo 'Some unexpected Recurly error happened. Try again later.' . PHP_EOL;\n}\n"
          },
          {
            "lang": "Go",
            "source": "coupon, err := client.GetCoupon(couponID)\nif e, ok := err.(*recurly.Error); ok {\n\tif e.Type == recurly.ErrorTypeNotFound {\n\t\tfmt.Printf(\"Resource not found: %v\", e)\n\t\treturn nil, err\n\t}\n\tfmt.Printf(\"Unexpected Recurly error: %v\", e)\n\treturn nil, err\n}\n\nfmt.Printf(\"Fetched Coupon: %v\", coupon.Id)"
          }
        ]
      },
      "put": {
        "tags": [
          "coupon"
        ],
        "operationId": "update_coupon",
        "summary": "Update an active coupon",
        "parameters": [
          {
            "$ref": "#/components/parameters/coupon_id"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CouponUpdate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "The updated coupon.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Coupon"
                }
              }
            }
          },
          "400": {
            "description": "Bad request, perhaps invalid JSON?",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site or coupon ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "422": {
            "description": "Invalid request parameters",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": [
          {
            "lang": "Node.js",
            "source": "try {\n  const couponUpdate = {\n    name: \"New Coupon Name\"\n  }\n  const coupon = await client.updateCoupon(couponId, couponUpdate)\n  console.log('Updated coupon: ', coupon)\n} catch (err) {\n  if (err instanceof recurly.errors.ValidationError) {\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in err.params\n    console.log('Failed validation', err.params)\n  } else {\n    // If we don't know what to do with the err, we should\n    // probably re-raise and let our web framework and logger handle it\n    console.log('Unknown Error: ', err)\n  }\n}\n"
          },
          {
            "lang": "Python",
            "source": "try:\n    coupon_update = {\n      \"name\": \"New Coupon Name\",\n    }\n    coupon = client.update_coupon(coupon_id, coupon_update)\n    print(\"Updated Coupon %s\" % coupon)\nexcept recurly.errors.NotFoundError:\n    # If the resource was not found, you may want to alert the user or\n    # just return nil\n    print(\"Resource Not Found\")\n"
          },
          {
            "lang": ".NET",
            "source": "try\n{\n    var couponReq = new CouponUpdate() {\n        Name = \"New Coupon Name\"\n    };\n    Coupon coupon = client.UpdateCoupon(couponId, couponReq);\n    Console.WriteLine($\"Updated Coupon: {coupon.Id}\");\n}\ncatch (Recurly.Errors.Validation ex)\n{\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in ex.Error.Params\n    Console.WriteLine($\"Failed validation: {ex.Error.Message}\");\n}\ncatch (Recurly.Errors.ApiError ex)\n{\n    // Use ApiError to catch a generic error from the API\n    Console.WriteLine($\"Unexpected Recurly Error: {ex.Error.Message}\");\n}\n"
          },
          {
            "lang": "Ruby",
            "source": "begin\n  coupon_update = {\n    name: \"New Coupon Name\"\n  }\n  coupon = @client.update_coupon(coupon_id: coupon_id, body: coupon_update)\n  puts \"Updated Coupon #{coupon}\"\nrescue Recurly::Errors::NotFoundError\n  # If the resource was not found, you may want to alert the user or\n  # just return nil\n  puts \"Resource Not Found\"\nend\n"
          },
          {
            "lang": "Java",
            "source": "try {\n  final CouponUpdate couponUpdate = new CouponUpdate();\n  couponUpdate.setName(\"New Coupon Name\");\n\n  final Coupon coupon = client.updateCoupon(couponId, couponUpdate);\n  System.out.println(\"Updated coupon: \" + coupon.getCode());\n  System.out.println(coupon.getName());\n} catch (ValidationException e) {\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in e.getError().getParams()\n    System.out.println(\"Failed validation: \" + e.getError().getMessage());\n} catch (ApiException e) {\n    // Use ApiException to catch a generic error from the API\n    System.out.println(\"Unexpected Recurly Error: \" + e.getError().getMessage());\n}\n"
          },
          {
            "lang": "PHP",
            "source": "try {\n    $coupon_update = [\n        \"name\" => \"New Coupon Name\"\n    ];\n    $coupon = $client->updateCoupon($coupon_id, $coupon_update);\n\n    echo 'Updated Coupon:' . PHP_EOL;\n    var_dump($coupon);\n} catch (\\Recurly\\Errors\\Validation $e) {\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in err.params\n    var_dump($e);\n} catch (\\Recurly\\RecurlyError $e) {\n    // If we don't know what to do with the err, we should\n    // probably re-raise and let our web framework and logger handle it\n    var_dump($e);\n}\n"
          },
          {
            "lang": "Go",
            "source": "updateReq := &recurly.CouponUpdate{\n\tName: recurly.String(\"New Coupon Name\"),\n}\ncoupon, err := client.UpdateCoupon(couponID, updateReq)\nif e, ok := err.(*recurly.Error); ok {\n\tif e.Type == recurly.ErrorTypeValidation {\n\t\tfmt.Printf(\"Failed validation: %v\", e)\n\t\treturn nil, err\n\t}\n\tfmt.Printf(\"Unexpected Recurly error: %v\", e)\n\treturn nil, err\n}\n\nfmt.Printf(\"Updated Coupon: %v\", coupon.Id)"
          }
        ]
      },
      "delete": {
        "tags": [
          "coupon"
        ],
        "operationId": "deactivate_coupon",
        "summary": "Expire a coupon",
        "parameters": [
          {
            "$ref": "#/components/parameters/coupon_id"
          }
        ],
        "description": "Mark an existing Coupon as expired",
        "responses": {
          "200": {
            "description": "The expired Coupon",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Coupon"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site or coupon ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": [
          {
            "lang": "Node.js",
            "source": "try {\n  const coupon = await client.deactivateCoupon(couponId)\n  console.log('Deactivated coupon: ', coupon.code)\n} catch (err) {\n  if (err instanceof recurly.errors.NotFoundError) {\n    // If the request was not found, you may want to alert the user or\n    // just return null\n    console.log('Resource Not Found')\n  } else {\n    // If we don't know what to do with the err, we should\n    // probably re-raise and let our web framework and logger handle it\n    console.log('Unknown Error: ', err)\n  }\n}\n"
          },
          {
            "lang": "Python",
            "source": "try:\n    coupon = client.deactivate_coupon(coupon_id)\n    print(\"Deactivated Coupon %s\" % coupon)\nexcept recurly.errors.NotFoundError:\n    # If the resource was not found, you may want to alert the user or\n    # just return nil\n    print(\"Resource Not Found\")\n"
          },
          {
            "lang": ".NET",
            "source": "try\n{\n    Coupon coupon = client.DeactivateCoupon(couponId);\n    Console.WriteLine($\"Deactivated coupon {coupon.Code}\");\n}\ncatch (Recurly.Errors.NotFound ex)\n{\n    // If the resource was not found\n    // we may want to alert the user or just return null\n    Console.WriteLine($\"Resource Not Found: {ex.Error.Message}\");\n}\ncatch (Recurly.Errors.ApiError ex)\n{\n    // Use ApiError to catch a generic error from the API\n    Console.WriteLine($\"Unexpected Recurly Error: {ex.Error.Message}\");\n}\n"
          },
          {
            "lang": "Ruby",
            "source": "begin\n  coupon = @client.deactivate_coupon(coupon_id: coupon_id)\n  puts \"Deactivated Coupon #{coupon}\"\nrescue Recurly::Errors::NotFoundError\n  # If the resource was not found, you may want to alert the user or\n  # just return nil\n  puts \"Resource Not Found\"\nend\n"
          },
          {
            "lang": "Java",
            "source": "try {\n    final Coupon coupon = client.deactivateCoupon(couponId);\n    System.out.println(\"Deactivated coupon \" + coupon.getCode());\n} catch (NotFoundException e) {\n    // If the resource was not found\n    // we may want to alert the user or just return null\n    System.out.println(\"Resource Not Found: \" + e.getError().getMessage());\n} catch (ApiException e) {\n    // Use ApiException to catch a generic error from the API\n    System.out.println(\"Unexpected Recurly Error: \" + e.getError().getMessage());\n}\n"
          },
          {
            "lang": "PHP",
            "source": "try {\n    $coupon = $client->deactivateCoupon($coupon_id);\n\n    echo 'Deactivated Coupon:' . PHP_EOL;\n    var_dump($coupon);\n} catch (\\Recurly\\Errors\\NotFound $e) {\n    // Could not find the resource, you may want to inform the user\n    // or just return a NULL\n    echo 'Could not find resource.' . PHP_EOL;\n    var_dump($e);\n} catch (\\Recurly\\RecurlyError $e) {\n    // Something bad happened... tell the user so that they can fix it?\n    echo 'Some unexpected Recurly error happened. Try again later.' . PHP_EOL;\n}\n"
          }
        ]
      }
    },
    "/coupons/{coupon_id}/generate": {
      "post": {
        "tags": [
          "unique_coupon_code"
        ],
        "operationId": "generate_unique_coupon_codes",
        "summary": "Generate unique coupon codes",
        "parameters": [
          {
            "$ref": "#/components/parameters/coupon_id"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CouponBulkCreate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "A set of parameters that can be passed to the `list_unique_coupon_codes`\nendpoint to obtain only the newly generated `UniqueCouponCodes`.\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UniqueCouponCodeParams"
                }
              }
            }
          },
          "400": {
            "description": "Invalid or unpermitted parameter; perhaps you tried to generate more than 200 codes at a time?",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site or coupon ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": []
      }
    },
    "/coupons/{coupon_id}/restore": {
      "put": {
        "tags": [
          "coupon"
        ],
        "operationId": "restore_coupon",
        "summary": "Restore an inactive coupon",
        "description": "Make an expired coupon redeemable again. You can change editable fields in this call.",
        "parameters": [
          {
            "$ref": "#/components/parameters/coupon_id"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CouponUpdate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "The restored coupon.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Coupon"
                }
              }
            }
          },
          "400": {
            "description": "Bad request, perhaps invalid JSON?",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site or coupon ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "422": {
            "description": "Invalid request parameters",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": []
      }
    },
    "/coupons/{coupon_id}/unique_coupon_codes": {
      "get": {
        "tags": [
          "unique_coupon_code"
        ],
        "operationId": "list_unique_coupon_codes",
        "summary": "List unique coupon codes associated with a bulk coupon",
        "description": "See the [Pagination Guide](/developers/guides/pagination.html) to learn how to use pagination in the API and Client Libraries.",
        "parameters": [
          {
            "$ref": "#/components/parameters/coupon_id"
          },
          {
            "$ref": "#/components/parameters/ids"
          },
          {
            "$ref": "#/components/parameters/limit"
          },
          {
            "$ref": "#/components/parameters/order"
          },
          {
            "$ref": "#/components/parameters/sort_dates"
          },
          {
            "$ref": "#/components/parameters/filter_begin_time"
          },
          {
            "$ref": "#/components/parameters/filter_end_time"
          }
        ],
        "responses": {
          "200": {
            "description": "A list of unique coupon codes that were generated",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UniqueCouponCodeList"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site or coupon ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": []
      }
    },
    "/credit_payments": {
      "get": {
        "tags": [
          "credit_payment"
        ],
        "operationId": "list_credit_payments",
        "summary": "List a site's credit payments",
        "description": "See the [Pagination Guide](/developers/guides/pagination.html) to learn how to use pagination in the API and Client Libraries.",
        "parameters": [
          {
            "$ref": "#/components/parameters/limit"
          },
          {
            "$ref": "#/components/parameters/order"
          },
          {
            "$ref": "#/components/parameters/sort_dates"
          },
          {
            "$ref": "#/components/parameters/filter_begin_time"
          },
          {
            "$ref": "#/components/parameters/filter_end_time"
          }
        ],
        "responses": {
          "200": {
            "description": "A list of the site's credit payments.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CreditPaymentList"
                }
              }
            }
          },
          "400": {
            "description": "Invalid or unpermitted parameter.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site or account ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": [
          {
            "lang": "Node.js",
            "source": "const payments = client.listCreditPayments({ params: { limit: 200 } })\n\nfor await (const payment of payments.each()) {\n  console.log(payment.uuid)\n}\n"
          },
          {
            "lang": "Python",
            "source": "params = {\"limit\": 200}\npayments = client.list_credit_payments(params=params).items()\nfor payment in payments:\n    print(\"Credit Payment %s\" % payment.id)\n"
          },
          {
            "lang": ".NET",
            "source": "var optionalParams = new ListCreditPaymentsParams()\n{\n    Limit = 200\n};\nvar payments = client.ListCreditPayments(optionalParams);\nforeach(CreditPayment payment in payments)\n{\n    Console.WriteLine(payment.Uuid);\n}\n"
          },
          {
            "lang": "Ruby",
            "source": "params = {\n  limit: 200\n}\npayments = @client.list_credit_payments(params: params)\npayments.each do |payment|\n  puts \"CreditPayment: #{payment.id}\"\nend\n"
          },
          {
            "lang": "Java",
            "source": "QueryParams params = new QueryParams();\nparams.setLimit(200); // Pull 200 records at a time\nfinal Pager<CreditPayment> payments = client.listCreditPayments(params);\n\nfor (CreditPayment payment : payments) {\n    System.out.println(payment.getUuid());\n}\n"
          },
          {
            "lang": "PHP",
            "source": "$options = [\n  'params' => [\n    'limit' => 200\n  ]\n];\n$credit_payments = $client->listCreditPayments($options);\n\nforeach($credit_payments as $payment) {\n  echo 'Credit Payment: ' . $payment->getId() . PHP_EOL;\n}\n"
          },
          {
            "lang": "Go",
            "source": "listParams := &recurly.ListCreditPaymentsParams{\n\tSort:  recurly.String(\"created_at\"),\n\tOrder: recurly.String(\"desc\"),\n\tLimit: recurly.Int(200),\n}\ncreditPayments, err := client.ListCreditPayments(listParams)\nif err != nil {\n\tfmt.Println(\"Unexpected error: %v\", err)\n\treturn\n}\n\nfor creditPayments.HasMore() {\n\terr := creditPayments.Fetch()\n\tif e, ok := err.(*recurly.Error); ok {\n\t\tfmt.Printf(\"Failed to retrieve next page: %v\", e)\n\t\tbreak\n\t}\n\tfor i, creditPayment := range creditPayments.Data() {\n\t\tfmt.Printf(\"Credit Payment %3d: %s\\n\",\n\t\t\ti,\n\t\t\tcreditPayment.Id,\n\t\t)\n\t}\n}"
          }
        ]
      }
    },
    "/credit_payments/{credit_payment_id}": {
      "get": {
        "tags": [
          "credit_payment"
        ],
        "operationId": "get_credit_payment",
        "summary": "Fetch a credit payment",
        "parameters": [
          {
            "$ref": "#/components/parameters/credit_payment_id"
          }
        ],
        "responses": {
          "200": {
            "description": "A credit payment.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CreditPayment"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site or credit payment ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": []
      }
    },
    "/custom_field_definitions": {
      "get": {
        "tags": [
          "custom_field_definition"
        ],
        "operationId": "list_custom_field_definitions",
        "summary": "List a site's custom field definitions",
        "description": "See the [Pagination Guide](/developers/guides/pagination.html) to learn how to use pagination in the API and Client Libraries.",
        "parameters": [
          {
            "$ref": "#/components/parameters/ids"
          },
          {
            "$ref": "#/components/parameters/limit"
          },
          {
            "$ref": "#/components/parameters/order"
          },
          {
            "$ref": "#/components/parameters/sort_dates"
          },
          {
            "$ref": "#/components/parameters/filter_begin_time"
          },
          {
            "$ref": "#/components/parameters/filter_end_time"
          },
          {
            "name": "related_type",
            "in": "query",
            "description": "Filter by related type.",
            "schema": {
              "type": "string",
              "enum": [
                "account",
                "item",
                "plan",
                "subscription",
                "charge"
              ]
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A list of the site's custom field definitions.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CustomFieldDefinitionList"
                }
              }
            }
          },
          "400": {
            "description": "Invalid or unpermitted parameter.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": [
          {
            "lang": "Node.js",
            "source": "const definitions = client.listCustomFieldDefinitions({ params: { limit: 200 } })\n\nfor await (const definition of definitions.each()) {\n  console.log(definition.displayName)\n}\n"
          },
          {
            "lang": "Python",
            "source": "params = {\"limit\": 200}\ncustom_fields = client.list_custom_field_definitions(params=params).items()\nfor custom_field in custom_fields:\n    print(custom_field.name)\n"
          },
          {
            "lang": ".NET",
            "source": "var optionalParams = new ListCustomFieldDefinitionsParams()\n{\n    Limit = 200\n};\nvar fields = client.ListCustomFieldDefinitions(optionalParams);\nforeach(CustomFieldDefinition def in fields)\n{\n    Console.WriteLine(def.DisplayName);\n}\n"
          },
          {
            "lang": "Ruby",
            "source": "params = {\n  limit: 200\n}\ncustom_fields = @client.list_custom_field_definitions(params: params)\ncustom_fields.each do |field|\n  puts \"CustomFieldDefinition: #{field.name}\"\nend\n"
          },
          {
            "lang": "Java",
            "source": "QueryParams params = new QueryParams();\nparams.setLimit(200); // Pull 200 records at a time\nfinal Pager<CustomFieldDefinition> fields = client.listCustomFieldDefinitions(params);\n\nfor (CustomFieldDefinition field : fields) {\n    System.out.println(field.getDisplayName());\n}\n"
          },
          {
            "lang": "PHP",
            "source": "$options = [\n  'params' => [\n    'limit' => 200\n  ]\n];\n$custom_field_definitions = $client->listCustomFieldDefinitions($options);\n\nforeach($custom_field_definitions as $definition) {\n  echo 'Custom Field Definition: ' . $definition->getName() . PHP_EOL;\n}\n"
          },
          {
            "lang": "Go",
            "source": "listParams := &recurly.ListCustomFieldDefinitionsParams{\n\tSort:  recurly.String(\"created_at\"),\n\tOrder: recurly.String(\"desc\"),\n\tLimit: recurly.Int(200),\n}\ncustomFieldDefinitions, err := client.ListCustomFieldDefinitions(listParams)\nif err != nil {\n\tfmt.Println(\"Unexpected error: %v\", err)\n\treturn\n}\n\nfor customFieldDefinitions.HasMore() {\n\terr := customFieldDefinitions.Fetch()\n\tif e, ok := err.(*recurly.Error); ok {\n\t\tfmt.Printf(\"Failed to retrieve next page: %v\", e)\n\t\tbreak\n\t}\n\tfor i, definition := range customFieldDefinitions.Data() {\n\t\tfmt.Printf(\"Custom Field Definition %3d: %s\\n\",\n\t\t\ti,\n\t\t\tdefinition.Id,\n\t\t)\n\t}\n}"
          }
        ]
      }
    },
    "/custom_field_definitions/{custom_field_definition_id}": {
      "get": {
        "tags": [
          "custom_field_definition"
        ],
        "operationId": "get_custom_field_definition",
        "summary": "Fetch an custom field definition",
        "parameters": [
          {
            "$ref": "#/components/parameters/custom_field_definition_id"
          }
        ],
        "responses": {
          "200": {
            "description": "A custom field definition.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CustomFieldDefinition"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site or custom field definition ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": [
          {
            "lang": "Node.js",
            "source": "try {\n  const definition = await client.getCustomFieldDefinition(definitionId)\n  console.log('Fetched custom field definition: ', definition.displayName)\n} catch (err) {\n  if (err instanceof recurly.errors.NotFoundError) {\n    // If the request was not found, you may want to alert the user or\n    // just return null\n    console.log('Resource Not Found')\n  } else {\n    // If we don't know what to do with the err, we should\n    // probably re-raise and let our web framework and logger handle it\n    console.log('Unknown Error: ', err)\n  }\n}\n"
          },
          {
            "lang": "Python",
            "source": "try:\n    custom_field_definition = client.get_custom_field_definition(custom_field_definition_id)\n    print(\"Custom Field Definition %s\" % custom_field_definition)\nexcept recurly.errors.NotFoundError as e:\n    print(\"Invoice not found\")\n"
          },
          {
            "lang": ".NET",
            "source": "try\n{\n    CustomFieldDefinition definition = client.GetCustomFieldDefinition(definitionId);\n    Console.WriteLine($\"Fetched custom field definition {definition.DisplayName}\");\n}\ncatch (Recurly.Errors.NotFound ex)\n{\n    // If the resource was not found\n    // we may want to alert the user or just return null\n    Console.WriteLine($\"Resource Not Found: {ex.Error.Message}\");\n}\ncatch (Recurly.Errors.ApiError ex)\n{\n    // Use ApiError to catch a generic error from the API\n    Console.WriteLine($\"Unexpected Recurly Error: {ex.Error.Message}\");\n}\n"
          },
          {
            "lang": "Ruby",
            "source": "begin\n  custom_field_definition = @client.get_custom_field_definition(\n    custom_field_definition_id: custom_field_definition_id\n  )\n  puts \"Got Custom Field Definition #{custom_field_definition}\"\nrescue Recurly::Errors::NotFoundError\n  # If the resource was not found, you may want to alert the user or\n  # just return nil\n  puts \"Resource Not Found\"\nend\n"
          },
          {
            "lang": "Java",
            "source": "try {\n    final CustomFieldDefinition definition = client.getCustomFieldDefinition(definitionId);\n    System.out.println(\"Fetched custom field definition \" + definition.getDisplayName());\n} catch (NotFoundException e) {\n    // If the resource was not found\n    // we may want to alert the user or just return null\n    System.out.println(\"Resource Not Found: \" + e.getError().getMessage());\n} catch (ApiException e) {\n    // Use ApiException to catch a generic error from the API\n    System.out.println(\"Unexpected Recurly Error: \" + e.getError().getMessage());\n}\n"
          },
          {
            "lang": "PHP",
            "source": "try {\n    $custom_field_def = $client->getCustomFieldDefinition($definition_id);\n\n    echo 'Got CustomFieldDefinition:' . PHP_EOL;\n    var_dump($custom_field_def);\n} catch (\\Recurly\\Errors\\NotFound $e) {\n    // Could not find the resource, you may want to inform the user\n    // or just return a NULL\n    echo 'Could not find resource.' . PHP_EOL;\n    var_dump($e);\n} catch (\\Recurly\\RecurlyError $e) {\n    // Something bad happened... tell the user so that they can fix it?\n    echo 'Some unexpected Recurly error happened. Try again later.' . PHP_EOL;\n}\n"
          },
          {
            "lang": "Go",
            "source": "definition, err := client.GetCustomFieldDefinition(customFieldDefinitionID)\nif e, ok := err.(*recurly.Error); ok {\n\tif e.Type == recurly.ErrorTypeNotFound {\n\t\tfmt.Printf(\"Resource not found: %v\", e)\n\t\treturn nil, err\n\t}\n\tfmt.Printf(\"Unexpected Recurly error: %v\", e)\n\treturn nil, err\n}\nfmt.Printf(\"Fetched Custom Field Definition: %s\", definition.Id)"
          }
        ]
      }
    },
    "/general_ledger_accounts": {
      "post": {
        "tags": [
          "general_ledger_account"
        ],
        "operationId": "create_general_ledger_account",
        "summary": "Create a new general ledger account",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GeneralLedgerAccountCreate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "A new general ledger account.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GeneralLedgerAccount"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": []
      },
      "get": {
        "tags": [
          "general_ledger_account"
        ],
        "operationId": "list_general_ledger_accounts",
        "summary": "List a site's general ledger accounts",
        "description": "See the [Pagination Guide](/developers/guides/pagination.html) to learn how to use pagination in the API and Client Libraries.",
        "parameters": [
          {
            "$ref": "#/components/parameters/ids"
          },
          {
            "$ref": "#/components/parameters/limit"
          },
          {
            "$ref": "#/components/parameters/order"
          },
          {
            "$ref": "#/components/parameters/sort_dates"
          },
          {
            "$ref": "#/components/parameters/general_ledger_account_type_enum"
          }
        ],
        "responses": {
          "200": {
            "description": "A list of the site's general ledger accounts.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GeneralLedgerAccountList"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": []
      }
    },
    "/general_ledger_accounts/{general_ledger_account_id}": {
      "get": {
        "tags": [
          "general_ledger_account"
        ],
        "operationId": "get_general_ledger_account",
        "summary": "Fetch a general ledger account",
        "parameters": [
          {
            "$ref": "#/components/parameters/general_ledger_account_id"
          }
        ],
        "responses": {
          "200": {
            "description": "A general ledger account.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GeneralLedgerAccount"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site or general ledger account ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": []
      },
      "put": {
        "tags": [
          "general_ledger_account"
        ],
        "operationId": "update_general_ledger_account",
        "summary": "Update a general ledger account",
        "parameters": [
          {
            "$ref": "#/components/parameters/general_ledger_account_id"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GeneralLedgerAccountUpdate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "The updated general ledger account.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GeneralLedgerAccount"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site or general ledger account ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": []
      }
    },
    "/performance_obligations/{performance_obligation_id}": {
      "get": {
        "tags": [
          "performance_obligations"
        ],
        "operationId": "get_performance_obligation",
        "summary": "Get a single Performance Obligation.",
        "parameters": [
          {
            "$ref": "#/components/parameters/performance_obligation_id"
          }
        ],
        "responses": {
          "200": {
            "description": "A single Performance Obligation.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PerformanceObligation"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": []
      }
    },
    "/performance_obligations": {
      "get": {
        "tags": [
          "performance_obligations"
        ],
        "operationId": "get_performance_obligations",
        "summary": "Get a site's Performance Obligations",
        "responses": {
          "200": {
            "description": "A list of Performance Obligations.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PerformanceObligationList"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": []
      }
    },
    "/invoice_templates/{invoice_template_id}/accounts": {
      "get": {
        "tags": [
          "account"
        ],
        "operationId": "list_invoice_template_accounts",
        "summary": "List an invoice template's associated accounts",
        "description": "See the [Pagination Guide](/developers/guides/pagination.html) to learn how to use pagination in the API and Client Libraries.",
        "parameters": [
          {
            "$ref": "#/components/parameters/invoice_template_id"
          },
          {
            "$ref": "#/components/parameters/ids"
          },
          {
            "$ref": "#/components/parameters/limit"
          },
          {
            "$ref": "#/components/parameters/order"
          },
          {
            "$ref": "#/components/parameters/sort_dates"
          },
          {
            "$ref": "#/components/parameters/filter_begin_time"
          },
          {
            "$ref": "#/components/parameters/filter_end_time"
          },
          {
            "$ref": "#/components/parameters/filter_account_email"
          },
          {
            "$ref": "#/components/parameters/filter_account_subscriber"
          },
          {
            "$ref": "#/components/parameters/filter_account_past_due"
          }
        ],
        "responses": {
          "200": {
            "description": "A list of an invoice template's associated accounts.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AccountList"
                }
              }
            }
          },
          "400": {
            "description": "Invalid or unpermitted parameter.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site or invoice template ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": []
      }
    },
    "/items": {
      "get": {
        "tags": [
          "item"
        ],
        "operationId": "list_items",
        "summary": "List a site's items",
        "description": "See the [Pagination Guide](/developers/guides/pagination.html) to learn how to use pagination in the API and Client Libraries.",
        "parameters": [
          {
            "$ref": "#/components/parameters/ids"
          },
          {
            "$ref": "#/components/parameters/limit"
          },
          {
            "$ref": "#/components/parameters/order"
          },
          {
            "$ref": "#/components/parameters/sort_dates"
          },
          {
            "$ref": "#/components/parameters/filter_begin_time"
          },
          {
            "$ref": "#/components/parameters/filter_end_time"
          },
          {
            "$ref": "#/components/parameters/filter_state"
          }
        ],
        "responses": {
          "200": {
            "description": "A list of the site's items.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ItemList"
                }
              }
            }
          },
          "400": {
            "description": "Invalid or unpermitted parameter.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": [
          {
            "lang": "Node.js",
            "source": "const items = client.listItems({ params: { limit: 200 } })\n\nfor await (const item of items.each()) {\n  console.log(item.code)\n}\n"
          },
          {
            "lang": "Python",
            "source": "params = {\"limit\": 200}\nitems = client.list_items(params=params).items()\nfor item in items:\n    print(item.code)\n"
          },
          {
            "lang": ".NET",
            "source": "var optionalParams = new ListItemsParams()\n{\n    Limit = 200\n};\nvar items = client.ListItems(optionalParams);\nforeach(Item item in items)\n{\n    Console.WriteLine(item.Code);\n}\n"
          },
          {
            "lang": "Ruby",
            "source": "params = {\n  limit: 200\n}\nitems = @client.list_items(params: params)\nitems.each do |item|\n  puts \"Item: #{item.code}\"\nend\n"
          },
          {
            "lang": "Java",
            "source": "QueryParams params = new QueryParams();\nparams.setLimit(200); // Pull 200 records at a time\nPager<Item> items = client.listItems(params);\n\nfor (Item item : items) {\n    System.out.println(item.getCode());\n}\n"
          },
          {
            "lang": "PHP",
            "source": "$options = [\n  'params' => [\n    'limit' => 200\n  ]\n];\n$items = $client->listItems($options);\n\nforeach($items as $item) {\n  echo 'Item: ' . $item->getCode() . PHP_EOL;\n}\n"
          },
          {
            "lang": "Go",
            "source": "listParams := &recurly.ListItemsParams{\n\tSort:  recurly.String(\"created_at\"),\n\tOrder: recurly.String(\"desc\"),\n\tLimit: recurly.Int(200),\n}\nitems, err := client.ListItems(listParams)\nif err != nil {\n\tfmt.Println(\"Unexpected error: %v\", err)\n\treturn\n}\n\nfor items.HasMore() {\n\terr := items.Fetch()\n\tif e, ok := err.(*recurly.Error); ok {\n\t\tfmt.Printf(\"Failed to retrieve next page: %v\", e)\n\t\tbreak\n\t}\n\tfor i, item := range items.Data() {\n\t\tfmt.Printf(\"Item %3d: %s, %s\\n\",\n\t\t\ti,\n\t\t\titem.Id,\n\t\t\titem.Code,\n\t\t)\n\t}\n}"
          }
        ]
      },
      "post": {
        "tags": [
          "item"
        ],
        "operationId": "create_item",
        "summary": "Create a new item",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ItemCreate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "A new item.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Item"
                }
              }
            }
          },
          "400": {
            "description": "Bad request, perhaps invalid JSON?",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "422": {
            "description": "Invalid request parameters.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": [
          {
            "lang": "Node.js",
            "source": "try {\n  const itemCreate = {\n    code: itemCode,\n    name: \"Item Name\",\n    description: \"Item Description\",\n    external_sku: \"a35JE-44\",\n    accounting_code: \"item-code-127\",\n    revenue_schedule_type: \"at_range_end\",\n    custom_fields: [{\n      name: \"custom-field-1\",\n      value: \"Custom Field 1 value\"\n    }]\n  }\n  const item = await client.createItem(itemCreate)\n  console.log('Created Item: ', item.code)\n} catch (err) {\n  if (err instanceof recurly.errors.ValidationError) {\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in err.params\n    console.log('Failed validation', err.params)\n  } else {\n    // If we don't know what to do with the err, we should\n    // probably re-raise and let our web framework and logger handle it\n    console.log('Unknown Error: ', err)\n  }\n}\n"
          },
          {
            "lang": "Python",
            "source": "try:\n    item_create = {\n        \"code\": item_code,\n        \"name\": \"Item Name\",\n        \"description\": \"Item Description\",\n        \"external_sku\": \"a35JE-44\",\n        \"accounting_code\": \"item-code-127\",\n        \"revenue_schedule_type\": \"at_range_end\",\n        \"custom_fields\": [{\n            \"name\": \"custom-field-1\",\n            \"value\": \"Custom Field 1 value\"\n        }]\n    }\n    item = client.create_item(item_create)\n    print(\"Created Item %s\" % item)\nexcept recurly.errors.ValidationError as e:\n    # If the request was invalid, you may want to tell your user\n    # why. You can find the invalid params and reasons in e.error.params\n    print(\"ValidationError: %s\" % e.error.message)\n    print(e.error.params)\n"
          },
          {
            "lang": ".NET",
            "source": "try\n{\n    var itemReq = new ItemCreate()\n    {\n        Code = itemCode,\n        Name = \"Item Name\",\n        Description = \"Item Description\",\n        ExternalSku = \"a35JE-44\",\n        AccountingCode = \"item-code-127\",\n        RevenueScheduleType = RevenueScheduleType.AtRangeEnd,\n        CustomFields = new List<CustomField>() {\n            new CustomField() {\n                Name = \"custom-field-1\",\n                Value = \"Custom Field 1 value\"\n            }\n        }\n    };\n    Item item = client.CreateItem(itemReq);\n    Console.WriteLine($\"Created item {item.Code}\");\n}\ncatch (Recurly.Errors.Validation ex)\n{\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in ex.Error.Params\n    Console.WriteLine($\"Failed validation: {ex.Error.Message}\");\n}\ncatch (Recurly.Errors.ApiError ex)\n{\n    // Use ApiError to catch a generic error from the API\n    Console.WriteLine($\"Unexpected Recurly Error: {ex.Error.Message}\");\n}\n"
          },
          {
            "lang": "Ruby",
            "source": "begin\n  item_create = {\n    code: item_code,\n    name: \"Item Name\",\n    description: \"Item Description\",\n    external_sku: \"a35JE-44\",\n    accounting_code: \"item-code-127\",\n    revenue_schedule_type: \"at_range_end\",\n    custom_fields: [{\n      name: \"custom-field-1\",\n      value: \"Custom Field 1 value\"\n    }]\n  }\n  item = @client.create_item(body: item_create)\n  puts \"Created Item #{item}\"\nrescue Recurly::Errors::ValidationError => e\n  # If the request was invalid, you may want to tell your user\n  # why. You can find the invalid params and reasons in e.recurly_error.params\n  puts \"ValidationError: #{e.recurly_error.params}\"\nend\n"
          },
          {
            "lang": "Java",
            "source": "try {\n    ItemCreate itemReq = new ItemCreate();\n\n    itemReq.setCode(itemCode);\n    itemReq.setName(\"Item Name\");\n    itemReq.setDescription(\"Item Description\");\n    itemReq.setExternalSku(\"a35JE-44\");\n    itemReq.setAccountingCode(\"item-code-127\");\n    itemReq.setRevenueScheduleType(Constants.RevenueScheduleType.AT_RANGE_END);\n\n    List<CustomField> customFields = new ArrayList<>();\n    CustomField customField = new CustomField();\n    customField.setName(\"custom-field-1\");\n    customField.setValue(\"Custom Field 1 value\");\n    customFields.add(customField);\n\n    itemReq.setCustomFields(customFields);\n\n\n    Item item = client.createItem(itemReq);\n    System.out.println(\"Created item \" + item.getCode());\n} catch (ValidationException e) {\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in e.getError().getParams()\n    System.out.println(\"Failed validation: \" + e.getError().getMessage());\n} catch (ApiException e) {\n    // Use ApiException to catch a generic error from the API\n    System.out.println(\"Unexpected Recurly Error: \" + e.getError().getMessage());\n}\n"
          },
          {
            "lang": "PHP",
            "source": "try {\n    $item_create = [\n        \"code\" => $item_code,\n        \"name\" => \"Coffee Grinder\",\n        \"description\" => \"A professional-grade bean grinder.\"\n    ];\n    $item = $client->createItem($item_create);\n\n    echo 'Created Item:' . PHP_EOL;\n    var_dump($item);\n} catch (\\Recurly\\Errors\\Validation $e) {\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in err.params\n    var_dump($e);\n} catch (\\Recurly\\RecurlyError $e) {\n    // If we don't know what to do with the err, we should\n    // probably re-raise and let our web framework and logger handle it\n    var_dump($e);\n}\n"
          },
          {
            "lang": "Go",
            "source": "itemReq := &recurly.ItemCreate{\n\tCode:                &itemCode,\n\tName:                recurly.String(\"Item Name\"),\n\tDescription:         recurly.String(\"Item Description\"),\n\tExternalSku:         recurly.String(\"a35JE-44\"),\n\tAccountingCode:      recurly.String(\"item-code-127\"),\n\tRevenueScheduleType: recurly.String(\"at_range_end\"),\n}\n\nitem, err := client.CreateItem(itemReq)\nif e, ok := err.(*recurly.Error); ok {\n\tif e.Type == recurly.ErrorTypeValidation {\n\t\tfmt.Printf(\"Failed validation: %v\", e)\n\t\treturn nil, err\n\t}\n\tfmt.Printf(\"Unexpected Recurly error: %v\", e)\n\treturn nil, err\n}\nfmt.Printf(\"Created Item: %v\", item.Id)"
          }
        ]
      }
    },
    "/items/{item_id}": {
      "get": {
        "tags": [
          "item"
        ],
        "operationId": "get_item",
        "summary": "Fetch an item",
        "parameters": [
          {
            "$ref": "#/components/parameters/item_id"
          }
        ],
        "responses": {
          "200": {
            "description": "An item.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Item"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site or item ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": [
          {
            "lang": "Node.js",
            "source": "try {\n  const item = await client.getItem(itemId)\n  console.log('Fetched item: ', item.code)\n} catch (err) {\n  if (err instanceof recurly.errors.NotFoundError) {\n    // If the request was not found, you may want to alert the user or\n    // just return null\n    console.log('Resource Not Found')\n  } else {\n    // If we don't know what to do with the err, we should\n    // probably re-raise and let our web framework and logger handle it\n    console.log('Unknown Error: ', err)\n  }\n}\n"
          },
          {
            "lang": "Python",
            "source": "try:\n    item = client.get_item(item_id)\n    print(\"Got Item %s\" % item)\nexcept recurly.errors.NotFoundError:\n    # If the resource was not found, you may want to alert the user or\n    # just return nil\n    print(\"Resource Not Found\")\n"
          },
          {
            "lang": ".NET",
            "source": "try\n{\n    Item item = client.GetItem(itemId);\n    Console.WriteLine($\"Fetched item {item.Code}\");\n}\ncatch (Recurly.Errors.NotFound ex)\n{\n    // If the resource was not found\n    // we may want to alert the user or just return null\n    Console.WriteLine($\"Resource Not Found: {ex.Error.Message}\");\n}\ncatch (Recurly.Errors.ApiError ex)\n{\n    // Use ApiError to catch a generic error from the API\n    Console.WriteLine($\"Unexpected Recurly Error: {ex.Error.Message}\");\n}\n"
          },
          {
            "lang": "Ruby",
            "source": "begin\n  item = @client.get_item(item_id: item_id)\n  puts \"Got Item #{item}\"\nrescue Recurly::Errors::NotFoundError\n  # If the resource was not found, you may want to alert the user or\n  # just return nil\n  puts \"Resource Not Found\"\nend\n"
          },
          {
            "lang": "Java",
            "source": "try {\n    final Item item = client.getItem(itemId);\n    System.out.println(\"Fetched item: \" + item.getCode());\n} catch (NotFoundException e) {\n    // If the resource was not found\n    // we may want to alert the user or just return null\n    System.out.println(\"Resource Not Found: \" + e.getError().getMessage());\n} catch (ApiException e) {\n    // Use ApiException to catch a generic error from the API\n    System.out.println(\"Unexpected Recurly Error: \" + e.getError().getMessage());\n}\n"
          },
          {
            "lang": "PHP",
            "source": "try {\n    $item = $client->getItem($item_id);\n\n    echo 'Got Item:' . PHP_EOL;\n    var_dump($item);\n} catch (\\Recurly\\Errors\\NotFound $e) {\n    // Could not find the resource, you may want to inform the user\n    // or just return a NULL\n    echo 'Could not find resource.' . PHP_EOL;\n    var_dump($e);\n} catch (\\Recurly\\RecurlyError $e) {\n    // Something bad happened... tell the user so that they can fix it?\n    echo 'Some unexpected Recurly error happened. Try again later.' . PHP_EOL;\n}\n"
          },
          {
            "lang": "Go",
            "source": "item, err := client.GetItem(itemID)\nif e, ok := err.(*recurly.Error); ok {\n\tif e.Type == recurly.ErrorTypeNotFound {\n\t\tfmt.Printf(\"Resource not found: %v\", e)\n\t\treturn nil, err\n\t}\n\tfmt.Printf(\"Unexpected Recurly error: %v\", e)\n\treturn nil, err\n}\n\nfmt.Printf(\"Fetched Item: %v\", item.Id)"
          }
        ]
      },
      "put": {
        "tags": [
          "item"
        ],
        "operationId": "update_item",
        "summary": "Update an active item",
        "parameters": [
          {
            "$ref": "#/components/parameters/item_id"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ItemUpdate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "The updated item.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Item"
                }
              }
            }
          },
          "400": {
            "description": "Bad request, perhaps invalid JSON?",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site or item ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "422": {
            "description": "Invalid request parameters",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": [
          {
            "lang": "Node.js",
            "source": "try {\n  const itemUpdate = {\n    name: 'New Item Name',\n    description: 'New Item Description'\n  }\n  const item = await client.updateItem(itemId, itemUpdate)\n  console.log('Updated item: ', item)\n} catch (err) {\n  if (err instanceof recurly.errors.ValidationError) {\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in err.params\n    console.log('Failed validation', err.params)\n  } else {\n    // If we don't know what to do with the err, we should\n    // probably re-raise and let our web framework and logger handle it\n    console.log('Unknown Error: ', err)\n  }\n}\n"
          },
          {
            "lang": "Python",
            "source": "try:\n    item_update = {\n        \"name\": \"New Item Name\",\n        \"description\": \"New Item Description\",\n    }\n    item = client.update_item(item_id, item_update)\n    print(\"Updated Item %s\" % item)\nexcept recurly.errors.ValidationError as e:\n    # If the request was invalid, you may want to tell your user\n    # why. You can find the invalid params and reasons in e.error.params\n    print(\"ValidationError: %s\" % e.error.message)\n    print(e.error.params)\n"
          },
          {
            "lang": ".NET",
            "source": "try\n{\n    var itemReq = new ItemUpdate() {\n        Name = \"New Item Name\",\n        Description = \"New Item Description\",\n    };\n    Item item = client.UpdateItem(itemId, itemReq);\n    Console.WriteLine(item.Name);\n    Console.WriteLine(item.Description);\n}\ncatch (Recurly.Errors.Validation ex)\n{\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in ex.Error.Params\n    Console.WriteLine($\"Failed validation: {ex.Error.Message}\");\n}\ncatch (Recurly.Errors.ApiError ex)\n{\n    // Use ApiError to catch a generic error from the API\n    Console.WriteLine($\"Unexpected Recurly Error: {ex.Error.Message}\");\n}\n"
          },
          {
            "lang": "Ruby",
            "source": "begin\n  item_update = {\n    name: \"New Item Name\",\n    description: \"New Item Description\"\n  }\n  item = @client.update_item(\n    item_id: item_id,\n    body: item_update\n  )\n  puts \"Updated Item #{item}\"\nrescue Recurly::Errors::ValidationError => e\n  # If the request was invalid, you may want to tell your user\n  # why. You can find the invalid params and reasons in e.recurly_error.params\n  puts \"ValidationError: #{e.recurly_error.params}\"\nend\n"
          },
          {
            "lang": "Java",
            "source": "try {\n    final ItemUpdate itemUpdate = new ItemUpdate();\n    itemUpdate.setName(\"New Item Name\");\n    itemUpdate.setDescription(\"New Item Description\");\n\n    final Item item = client.updateItem(itemId, itemUpdate);\n    System.out.println(\"Updated item: \" + item.getCode());\n    System.out.println(item.getName());\n    System.out.println(item.getDescription());\n} catch (ValidationException e) {\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in e.getError().getParams()\n    System.out.println(\"Failed validation: \" + e.getError().getMessage());\n} catch (ApiException e) {\n    // Use ApiException to catch a generic error from the API\n    System.out.println(\"Unexpected Recurly Error: \" + e.getError().getMessage());\n}\n"
          },
          {
            "lang": "PHP",
            "source": "try {\n    $item_update = [\n        \"name\" => \"Dark Roast Coffee Beans\",\n        \"description\" => \"A special dark roast version.\",\n    ];\n    $item = $client->updateItem($item_id, $item_update);\n\n    echo 'Updated Item:' . PHP_EOL;\n    var_dump($item);\n} catch (\\Recurly\\Errors\\Validation $e) {\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in err.params\n    var_dump($e);\n} catch (\\Recurly\\RecurlyError $e) {\n    // If we don't know what to do with the err, we should\n    // probably re-raise and let our web framework and logger handle it\n    var_dump($e);\n}\n"
          },
          {
            "lang": "Go",
            "source": "updateReq := &recurly.ItemUpdate{\n\tName:        recurly.String(\"Pothos Plant\"),\n\tDescription: recurly.String(\"A sturdy houseplant\"),\n}\nitem, err := client.UpdateItem(itemID, updateReq)\nif e, ok := err.(*recurly.Error); ok {\n\tif e.Type == recurly.ErrorTypeValidation {\n\t\tfmt.Printf(\"Failed validation: %v\", e)\n\t\treturn nil, err\n\t}\n\tfmt.Printf(\"Unexpected Recurly error: %v\", e)\n\treturn nil, err\n}\n\nfmt.Printf(\"Updated Item: %v\", item.Id)"
          }
        ]
      },
      "delete": {
        "tags": [
          "item"
        ],
        "operationId": "deactivate_item",
        "summary": "Deactivate an item",
        "parameters": [
          {
            "$ref": "#/components/parameters/item_id"
          }
        ],
        "description": "Deactivating an item makes it unavailable for new purchases. It will not affect existing line items.",
        "responses": {
          "200": {
            "description": "An item.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Item"
                }
              }
            }
          },
          "422": {
            "description": "Item may already be inactive.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": [
          {
            "lang": "Node.js",
            "source": "try {\n  const item = await client.deactivateItem(itemId)\n  console.log('Deleted item: ', item.code)\n} catch (err) {\n  if (err && err.type === 'not-found') {\n    // If the request was not found, you may want to alert the user or\n    // just return null\n    console.log('Resource Not Found')\n  }\n  // If we don't know what to do with the err, we should\n  // probably re-raise and let our web framework and logger handle it\n  throw err\n}\n"
          },
          {
            "lang": "Python",
            "source": "try:\n    item = client.deactivate_item(item_id)\n    print(\"Deactivated Item %s\" % item)\nexcept recurly.errors.NotFoundError:\n    # If the resource was not found, you may want to alert the user or\n    # just return nil\n    print(\"Resource Not Found\")\n"
          },
          {
            "lang": ".NET",
            "source": "try\n{\n    Item item = client.DeactivateItem(itemId);\n    Console.WriteLine($\"Deactivated item {item.Code}\");\n}\ncatch (Recurly.Errors.Validation ex)\n{\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in ex.Error.Params\n    Console.WriteLine($\"Failed validation: {ex.Error.Message}\");\n}\ncatch (Recurly.Errors.ApiError ex)\n{\n    // Use ApiError to catch a generic error from the API\n    Console.WriteLine($\"Unexpected Recurly Error: {ex.Error.Message}\");\n}\n"
          },
          {
            "lang": "Ruby",
            "source": "begin\n  item = @client.deactivate_item(item_id: item_id)\n  puts \"Deactivated Item #{item}\"\nrescue Recurly::Errors::NotFoundError\n  # If the resource was not found, you may want to alert the user or\n  # just return nil\n  puts \"Resource Not Found\"\nend\n"
          },
          {
            "lang": "Java",
            "source": "try {\n    Item item = client.deactivateItem(itemId);\n    System.out.println(\"deactivated item \" + item.getCode());\n} catch (ValidationException e) {\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in e.getError().getParams()\n    System.out.println(\"Failed validation: \" + e.getError().getMessage());\n} catch (ApiException e) {\n    // Use ApiException to catch a generic error from the API\n    System.out.println(\"Unexpected Recurly Error: \" + e.getError().getMessage());\n}\n"
          },
          {
            "lang": "PHP",
            "source": "try {\n    $item = $client->deactivateItem($item_id);\n\n    echo 'Deactivated Item:' . PHP_EOL;\n    var_dump($item);\n} catch (\\Recurly\\Errors\\NotFound $e) {\n    // Could not find the resource, you may want to inform the user\n    // or just return a NULL\n    echo 'Could not find resource.' . PHP_EOL;\n    var_dump($e);\n} catch (\\Recurly\\RecurlyError $e) {\n    // Something bad happened... tell the user so that they can fix it?\n    echo 'Some unexpected Recurly error happened. Try again later.' . PHP_EOL;\n}\n"
          },
          {
            "lang": "Go",
            "source": "deactivatedItem, err := client.DeactivateItem(itemID)\nif e, ok := err.(*recurly.Error); ok {\n\tif e.Type == recurly.ErrorTypeNotFound {\n\t\tfmt.Printf(\"Resource not found: %v\", e)\n\t\treturn nil, err\n\t}\n\tfmt.Printf(\"Unexpected Recurly error: %v\", e)\n\treturn nil, err\n}\nfmt.Printf(\"Item deactivated: %s\", deactivatedItem.Code)"
          }
        ]
      }
    },
    "/items/{item_id}/reactivate": {
      "parameters": [
        {
          "$ref": "#/components/parameters/item_id"
        }
      ],
      "put": {
        "tags": [
          "item"
        ],
        "operationId": "reactivate_item",
        "summary": "Reactivate an inactive item",
        "description": "Reactivating an item makes it available for new purchases. It will not affect existing line items.",
        "responses": {
          "200": {
            "description": "An item.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Item"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site or item ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "422": {
            "description": "Item is already active.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": [
          {
            "lang": "Node.js",
            "source": "try {\n  const item = await client.reactivateItem(itemId)\n  console.log('Reactivated item: ', item.code)\n} catch (err) {\n  if (err && err.type === 'not_found') {\n    // If the request was not found, you may want to alert the user or\n    // just return null\n    console.log('Resource Not Found')\n  }\n  // If we don't know what to do with the err, we should\n  // probably re-raise and let our web framework and logger handle it\n  throw err\n}\n"
          },
          {
            "lang": "Python",
            "source": "try:\n    item = client.reactivate_item(item_id)\n    print(\"Reactivated Item %s\" % item)\nexcept recurly.errors.NotFoundError:\n    # If the resource was not found, you may want to alert the user or\n    # just return nil\n    print(\"Resource Not Found\")\n"
          },
          {
            "lang": ".NET",
            "source": "try\n{\n    Item item = client.ReactivateItem(itemId);\n    Console.WriteLine($\"Reactivated item {item.Code}\");\n}\ncatch (Recurly.Errors.Validation ex)\n{\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in ex.Error.Params\n    Console.WriteLine($\"Failed validation: {ex.Error.Message}\");\n}\ncatch (Recurly.Errors.ApiError ex)\n{\n    // Use ApiError to catch a generic error from the API\n    Console.WriteLine($\"Unexpected Recurly Error: {ex.Error.Message}\");\n}\n"
          },
          {
            "lang": "Ruby",
            "source": "begin\n  item = @client.reactivate_item(item_id: item_id)\n  puts \"Reactivated Item #{item}\"\nrescue Recurly::Errors::NotFoundError\n  # If the resource was not found, you may want to alert the user or\n  # just return nil\n  puts \"Resource Not Found\"\nend\n"
          },
          {
            "lang": "Java",
            "source": "try {\n    final Item item = client.reactivateItem(itemId);\n    System.out.println(\"Reactivated item: \" + item.getCode());\n} catch (ValidationException e) {\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in e.getError().getParams()\n    System.out.println(\"Failed validation: \" + e.getError().getMessage());\n} catch (ApiException e) {\n    // Use ApiException to catch a generic error from the API\n    System.out.println(\"Unexpected Recurly Error: \" + e.getError().getMessage());\n}\n"
          },
          {
            "lang": "PHP",
            "source": "try {\n    $item = $client->reactivateItem($item_id);\n\n    echo 'Reactivate Item:' . PHP_EOL;\n    var_dump($item);\n} catch (\\Recurly\\Errors\\NotFound $e) {\n    // Could not find the resource, you may want to inform the user\n    // or just return a NULL\n    echo 'Could not find resource.' . PHP_EOL;\n    var_dump($e);\n} catch (\\Recurly\\RecurlyError $e) {\n    // Something bad happened... tell the user so that they can fix it?\n    echo 'Some unexpected Recurly error happened. Try again later.' . PHP_EOL;\n}\n"
          },
          {
            "lang": "Go",
            "source": "item, err := client.ReactivateItem(itemID)\nif e, ok := err.(*recurly.Error); ok {\n\tif e.Type == recurly.ErrorTypeValidation {\n\t\tfmt.Printf(\"Failed validation: %v\", e)\n\t\treturn nil, err\n\t}\n\tfmt.Printf(\"Unexpected Recurly error: %v\", e)\n\treturn nil, err\n}\nfmt.Printf(\"Reactivated Item: %s\", item.Id)"
          }
        ]
      }
    },
    "/measured_units": {
      "get": {
        "tags": [
          "measured_unit"
        ],
        "operationId": "list_measured_unit",
        "summary": "List a site's measured units",
        "description": "See the [Pagination Guide](/developers/guides/pagination.html) to learn how to use pagination in the API and Client Libraries.",
        "parameters": [
          {
            "$ref": "#/components/parameters/ids"
          },
          {
            "$ref": "#/components/parameters/limit"
          },
          {
            "$ref": "#/components/parameters/order"
          },
          {
            "$ref": "#/components/parameters/sort_dates"
          },
          {
            "$ref": "#/components/parameters/filter_begin_time"
          },
          {
            "$ref": "#/components/parameters/filter_end_time"
          },
          {
            "$ref": "#/components/parameters/filter_state"
          }
        ],
        "responses": {
          "200": {
            "description": "A list of the site's measured units.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MeasuredUnitList"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": []
      },
      "post": {
        "tags": [
          "measured_unit"
        ],
        "operationId": "create_measured_unit",
        "summary": "Create a new measured unit",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/MeasuredUnitCreate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "A new measured unit.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MeasuredUnit"
                }
              }
            }
          },
          "400": {
            "description": "Bad request, perhaps invalid JSON?",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "422": {
            "description": "Invalid request parameters.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": []
      }
    },
    "/measured_units/{measured_unit_id}": {
      "get": {
        "tags": [
          "measured_unit"
        ],
        "operationId": "get_measured_unit",
        "summary": "Fetch a measured unit",
        "parameters": [
          {
            "$ref": "#/components/parameters/measured_unit_id"
          }
        ],
        "responses": {
          "200": {
            "description": "An item.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MeasuredUnit"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site or measured unit ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": []
      },
      "put": {
        "tags": [
          "measured_unit"
        ],
        "operationId": "update_measured_unit",
        "summary": "Update a measured unit",
        "parameters": [
          {
            "$ref": "#/components/parameters/measured_unit_id"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/MeasuredUnitUpdate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "The updated measured_unit.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MeasuredUnit"
                }
              }
            }
          },
          "400": {
            "description": "Bad request, perhaps invalid JSON?",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site or measured unit ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "422": {
            "description": "Invalid request parameters",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": []
      },
      "delete": {
        "tags": [
          "measured_unit"
        ],
        "operationId": "remove_measured_unit",
        "summary": "Remove a measured unit",
        "description": "A mesured unit cannot be deleted if it is used by an active plan.",
        "parameters": [
          {
            "$ref": "#/components/parameters/measured_unit_id"
          }
        ],
        "responses": {
          "200": {
            "description": "A measured unit.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MeasuredUnit"
                }
              }
            }
          },
          "422": {
            "description": "Measured unit may already be inactive.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": []
      }
    },
    "/external_products": {
      "get": {
        "tags": [
          "external_products"
        ],
        "operationId": "list_external_products",
        "summary": "List a site's external products",
        "description": "See the [Pagination Guide](/developers/guides/pagination.html) to learn how to use pagination in the API and Client Libraries.",
        "parameters": [
          {
            "$ref": "#/components/parameters/sort_dates"
          }
        ],
        "responses": {
          "200": {
            "description": "A list of the the external_products on a site.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ExternalProductList"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": []
      },
      "post": {
        "tags": [
          "external_products"
        ],
        "operationId": "create_external_product",
        "summary": "Create an external product",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ExternalProductCreate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Returns the external product",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ExternalProduct"
                }
              }
            }
          },
          "400": {
            "description": "Bad request; perhaps missing or invalid parameters.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "404": {
            "description": "External product cannot be created for the specified reason.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": []
      }
    },
    "/external_products/{external_product_id}": {
      "parameters": [
        {
          "$ref": "#/components/parameters/external_product_id"
        }
      ],
      "get": {
        "tags": [
          "external_products"
        ],
        "operationId": "get_external_product",
        "summary": "Fetch an external product",
        "responses": {
          "200": {
            "description": "Settings for an external product.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ExternalProduct"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site or external product ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": []
      },
      "put": {
        "tags": [
          "external_products"
        ],
        "operationId": "update_external_product",
        "summary": "Update an external product",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ExternalProductUpdate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Settings for an external product.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ExternalProduct"
                }
              }
            }
          },
          "404": {
            "description": "Bad request; perhaps missing or invalid parameters.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": []
      },
      "delete": {
        "tags": [
          "external_products"
        ],
        "operationId": "deactivate_external_products",
        "summary": "Deactivate an external product",
        "description": "Deactivate an external product.",
        "responses": {
          "200": {
            "description": "Deactivated external product.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ExternalProduct"
                }
              }
            }
          },
          "404": {
            "description": "Bad request; perhaps missing or invalid parameters.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": []
      }
    },
    "/external_products/{external_product_id}/external_product_references": {
      "parameters": [
        {
          "$ref": "#/components/parameters/external_product_id"
        }
      ],
      "get": {
        "tags": [
          "external_product_references"
        ],
        "operationId": "list_external_product_external_product_references",
        "summary": "List the external product references for an external product",
        "description": "See the [Pagination Guide](/developers/guides/pagination.html) to learn how to use pagination in the API and Client Libraries.",
        "parameters": [
          {
            "$ref": "#/components/parameters/sort_dates"
          }
        ],
        "responses": {
          "200": {
            "description": "A list of the the external product references for an external product.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ExternalProductReferenceCollection"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site or external product ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": []
      },
      "post": {
        "tags": [
          "external_product_references"
        ],
        "operationId": "create_external_product_external_product_reference",
        "summary": "Create an external product reference on an external product",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ExternalProductReferenceCreate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Details for the external product reference.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ExternalProductReferenceMini"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": []
      }
    },
    "/external_products/{external_product_id}/external_product_references/{external_product_reference_id}": {
      "parameters": [
        {
          "$ref": "#/components/parameters/external_product_id"
        },
        {
          "$ref": "#/components/parameters/external_product_reference_id"
        }
      ],
      "get": {
        "tags": [
          "external_product_references"
        ],
        "operationId": "get_external_product_external_product_reference",
        "summary": "Fetch an external product reference",
        "responses": {
          "200": {
            "description": "Details for an external product reference.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ExternalProductReferenceMini"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site or external product ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": []
      },
      "delete": {
        "tags": [
          "external_product_references"
        ],
        "operationId": "deactivate_external_product_external_product_reference",
        "summary": "Deactivate an external product reference",
        "responses": {
          "200": {
            "description": "Details for an external product reference.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ExternalProductReferenceMini"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site or external product reference ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": []
      }
    },
    "/external_subscriptions": {
      "get": {
        "tags": [
          "external_subscriptions"
        ],
        "operationId": "list_external_subscriptions",
        "summary": "List a site's external subscriptions",
        "description": "See the [Pagination Guide](/developers/guides/pagination.html) to learn how to use pagination in the API and Client Libraries.",
        "parameters": [
          {
            "$ref": "#/components/parameters/sort_dates"
          }
        ],
        "responses": {
          "200": {
            "description": "A list of the the external_subscriptions on a site.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ExternalSubscriptionList"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": []
      }
    },
    "/external_subscriptions/{external_subscription_id}": {
      "parameters": [
        {
          "$ref": "#/components/parameters/external_subscription_id_fetch"
        }
      ],
      "get": {
        "tags": [
          "external_subscriptions"
        ],
        "operationId": "get_external_subscription",
        "summary": "Fetch an external subscription",
        "responses": {
          "200": {
            "description": "Settings for an external subscription.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ExternalSubscription"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site or external subscription ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "422": {
            "description": "Validation error with external resource connection or feature flag.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": []
      }
    },
    "/external_subscriptions/{external_subscription_id}/external_invoices": {
      "parameters": [
        {
          "$ref": "#/components/parameters/external_subscription_id"
        }
      ],
      "get": {
        "tags": [
          "external_subscriptions"
        ],
        "operationId": "list_external_subscription_external_invoices",
        "summary": "List the external invoices on an external subscription",
        "description": "See the [Pagination Guide](/developers/guides/pagination.html) to learn how to use pagination in the API and Client Libraries.",
        "parameters": [
          {
            "$ref": "#/components/parameters/sort_dates"
          },
          {
            "$ref": "#/components/parameters/limit"
          },
          {
            "$ref": "#/components/parameters/order"
          }
        ],
        "responses": {
          "200": {
            "description": "A list of the the external_invoices on a site.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ExternalInvoiceList"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": []
      }
    },
    "/invoices": {
      "get": {
        "tags": [
          "invoice"
        ],
        "operationId": "list_invoices",
        "summary": "List a site's invoices",
        "description": "See the [Pagination Guide](/developers/guides/pagination.html) to learn how to use pagination in the API and Client Libraries.",
        "parameters": [
          {
            "$ref": "#/components/parameters/ids"
          },
          {
            "$ref": "#/components/parameters/invoice_state"
          },
          {
            "$ref": "#/components/parameters/limit"
          },
          {
            "$ref": "#/components/parameters/order"
          },
          {
            "$ref": "#/components/parameters/sort_dates"
          },
          {
            "$ref": "#/components/parameters/filter_begin_time"
          },
          {
            "$ref": "#/components/parameters/filter_end_time"
          },
          {
            "$ref": "#/components/parameters/filter_invoice_type"
          }
        ],
        "responses": {
          "200": {
            "description": "A list of the site's invoices.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/InvoiceList"
                }
              }
            }
          },
          "400": {
            "description": "Invalid or unpermitted parameter.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": [
          {
            "lang": "Node.js",
            "source": "const invoices = client.listInvoices({ params: { limit: 200 } })\n\nfor await (const invoice of invoices.each()) {\n  console.log(invoice.number)\n}\n"
          },
          {
            "lang": "Python",
            "source": "params = {\"limit\": 200}\ninvoices = client.list_invoices(params=params).items()\nfor invoice in invoices:\n    print(invoice.number)\n"
          },
          {
            "lang": ".NET",
            "source": "var optionalParams = new ListInvoicesParams()\n{\n    Limit = 200\n};\nvar invoices = client.ListInvoices(optionalParams);\nforeach(Invoice invoice in invoices)\n{\n    Console.WriteLine(invoice.Number);\n}\n"
          },
          {
            "lang": "Ruby",
            "source": "params = {\n  limit: 200\n}\ninvoices = @client.list_invoices(params: params)\ninvoices.each do |invoice|\n  puts \"Invoice: #{invoice.number}\"\nend\n"
          },
          {
            "lang": "Java",
            "source": "QueryParams params = new QueryParams();\nparams.setLimit(200); // Pull 200 records at a time\nfinal Pager<Invoice> invoices = client.listInvoices(params);\n\nfor (Invoice invoice : invoices) {\n    System.out.println(invoice.getNumber());\n}\n"
          },
          {
            "lang": "PHP",
            "source": "$options = [\n  'params' => [\n    'limit' => 200\n  ]\n];\n$invoices = $client->listInvoices($options);\n\nforeach($invoices as $invoice) {\n  echo 'Invoice: ' . $invoice->getNumber() . PHP_EOL;\n}\n"
          },
          {
            "lang": "Go",
            "source": "listParams := &recurly.ListInvoicesParams{\n\tSort:  recurly.String(\"created_at\"),\n\tOrder: recurly.String(\"desc\"),\n\tLimit: recurly.Int(200),\n}\ninvoices, err := client.ListInvoices(listParams)\nif err != nil {\n\tfmt.Println(\"Unexpected error: %v\", err)\n\treturn\n}\n\nfor invoices.HasMore() {\n\terr := invoices.Fetch()\n\tif e, ok := err.(*recurly.Error); ok {\n\t\tfmt.Printf(\"Failed to retrieve next page: %v\", e)\n\t\tbreak\n\t}\n\tfor i, invoice := range invoices.Data() {\n\t\tfmt.Printf(\"Invoice %3d: %s, %s\\n\",\n\t\t\ti,\n\t\t\tinvoice.Id,\n\t\t\tinvoice.Number,\n\t\t)\n\t}\n}"
          }
        ]
      }
    },
    "/invoices/{invoice_id}": {
      "get": {
        "tags": [
          "invoice"
        ],
        "operationId": "get_invoice",
        "summary": "Fetch an invoice",
        "parameters": [
          {
            "$ref": "#/components/parameters/invoice_id"
          }
        ],
        "responses": {
          "200": {
            "description": "An invoice.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Invoice"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site or invoice ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": [
          {
            "lang": "Node.js",
            "source": "try {\n  const invoice = await client.getInvoice(invoiceId)\n  console.log('Fetched Invoice: ', invoice.number)\n} catch (err) {\n  if (err instanceof recurly.errors.NotFoundError) {\n    // If the request was not found, you may want to alert the user or\n    // just return null\n    console.log('Resource Not Found')\n  } else {\n    // If we don't know what to do with the err, we should\n    // probably re-raise and let our web framework and logger handle it\n    console.log('Unknown Error: ', err)\n  }\n}\n"
          },
          {
            "lang": "Python",
            "source": "try:\n    invoice = client.get_invoice(invoice_id)\n    print(\"Got Invoice %s\" % invoice)\nexcept recurly.errors.NotFoundError:\n    # If the resource was not found, you may want to alert the user or\n    # just return nil\n    print(\"Resource Not Found\")\n"
          },
          {
            "lang": ".NET",
            "source": "try\n{\n    Invoice invoice = client.GetInvoice(invoiceId);\n    Console.WriteLine($\"Fetched invoice #{invoice.Number}\");\n}\ncatch (Recurly.Errors.NotFound ex)\n{\n    // If the resource was not found\n    // we may want to alert the user or just return null\n    Console.WriteLine($\"Resource Not Found: {ex.Error.Message}\");\n}\ncatch (Recurly.Errors.ApiError ex)\n{\n    // Use ApiError to catch a generic error from the API\n    Console.WriteLine($\"Unexpected Recurly Error: {ex.Error.Message}\");\n}\n"
          },
          {
            "lang": "Ruby",
            "source": "begin\n  invoice = @client.get_invoice(invoice_id: invoice_id)\n  puts \"Got invoice #{invoice}\"\nrescue Recurly::Errors::NotFoundError\n  # If the resource was not found, you may want to alert the user or\n  # just return nil\n  puts \"Resource Not Found\"\nend\n"
          },
          {
            "lang": "Java",
            "source": "try {\n    final Invoice invoice = client.getInvoice(invoiceId);\n    System.out.println(\"Fetched invoice \" + invoice.getNumber());\n} catch (NotFoundException e) {\n    // If the resource was not found\n    // we may want to alert the user or just return null\n    System.out.println(\"Resource Not Found: \" + e.getError().getMessage());\n} catch (ApiException e) {\n    // Use ApiException to catch a generic error from the API\n    System.out.println(\"Unexpected Recurly Error: \" + e.getError().getMessage());\n}\n"
          },
          {
            "lang": "PHP",
            "source": "try {\n    $invoice = $client->getInvoice($invoice_id);\n\n    echo 'Got Invoice:' . PHP_EOL;\n    var_dump($invoice);\n} catch (\\Recurly\\Errors\\NotFound $e) {\n    // Could not find the resource, you may want to inform the user\n    // or just return a NULL\n    echo 'Could not find resource.' . PHP_EOL;\n    var_dump($e);\n} catch (\\Recurly\\RecurlyError $e) {\n    // Something bad happened... tell the user so that they can fix it?\n    echo 'Some unexpected Recurly error happened. Try again later.' . PHP_EOL;\n}\n"
          },
          {
            "lang": "Go",
            "source": "invoice, err := client.GetInvoice(invoiceID)\nif e, ok := err.(*recurly.Error); ok {\n\tif e.Type == recurly.ErrorTypeNotFound {\n\t\tfmt.Printf(\"Resource not found: %v\", e)\n\t\treturn nil, err\n\t}\n\tfmt.Printf(\"Unexpected Recurly error: %v\", e)\n\treturn nil, err\n}\n\nfmt.Printf(\"Fetched Invoice: %v\", invoice)"
          }
        ]
      },
      "put": {
        "tags": [
          "invoice"
        ],
        "operationId": "update_invoice",
        "summary": "Update an invoice",
        "parameters": [
          {
            "$ref": "#/components/parameters/invoice_id"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/InvoiceUpdate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "An invoice.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Invoice"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site or invoice ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "422": {
            "description": "A validation error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": [
          {
            "lang": "Node.js",
            "source": "try {\n  const invoiceUpdate = {\n    customerNotes: \"New notes\",\n    termsAndConditions: \"New terms and conditions\"\n  }\n\n  const invoice = await client.updateInvoice(invoiceId, invoiceUpdate)\n  console.log('Edited invoice: ', invoice.number)\n} catch(err) {\n\n  if (err instanceof recurly.errors.ValidationError) {\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in err.params\n    console.log('Failed validation', err.params)\n  } else {\n    // If we don't know what to do with the err, we should\n    // probably re-raise and let our web framework and logger handle it\n    console.log('Unknown Error: ', err)\n  }\n}\n"
          },
          {
            "lang": "Python",
            "source": "try:\n    invoice_update = {\n      \"customer_notes\": \"New Notes\",\n      \"terms_and_conditions\": \"New Terms and Conditions\",\n    }\n    invoice = client.update_invoice(invoice_id, invoice_update)\n    print(\"Updated Invoice %s\" % invoice.id)\nexcept recurly.errors.NotFoundError:\n    # If the resource was not found, you may want to alert the user or\n    # just return nil\n    print(\"Resource Not Found\")\n"
          },
          {
            "lang": ".NET",
            "source": "try\n{\n    var invoiceReq = new InvoiceUpdate()\n    {\n        CustomerNotes = \"New Notes\",\n        TermsAndConditions = \"New Terms and Conditions\"\n    };\n    Invoice invoice = client.UpdateInvoice(invoiceId, invoiceReq);\n    Console.WriteLine($\"Edited invoice #{invoice.Number}\");\n}\ncatch (Recurly.Errors.Validation ex)\n{\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in ex.Error.Params\n    Console.WriteLine($\"Failed validation: {ex.Error.Message}\");\n}\ncatch (Recurly.Errors.ApiError ex)\n{\n    // Use ApiError to catch a generic error from the API\n    Console.WriteLine($\"Unexpected Recurly Error: {ex.Error.Message}\");\n}\n"
          },
          {
            "lang": "Ruby",
            "source": "begin\n  invoice_update = {\n    customer_notes: \"New Notes\",\n    terms_and_conditions: \"New Terms and Conditions\"\n  }\n  invoice = @client.update_invoice(invoice_id: invoice_id, body: invoice_update)\n  puts \"Updated invoice #{invoice}\"\nrescue Recurly::Errors::NotFoundError\n  # If the resource was not found, you may want to alert the user or\n  # just return nil\n  puts \"Resource Not Found\"\nend\n"
          },
          {
            "lang": "Java",
            "source": "try {\n    final InvoiceUpdate invoiceUpdate = new InvoiceUpdate();\n    invoiceUpdate.setCustomerNotes(\"New notes\");\n    invoiceUpdate.setTermsAndConditions(\"New terms and conditions\");\n\n    final Invoice invoice = client.updateInvoice(invoiceId, invoiceUpdate);\n    System.out.println(\"Edited invoice \" + invoice.getNumber());\n} catch (ValidationException e) {\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in e.getError().getParams()\n    System.out.println(\"Failed validation: \" + e.getError().getMessage());\n} catch (ApiException e) {\n    // Use ApiException to catch a generic error from the API\n    System.out.println(\"Unexpected Recurly Error: \" + e.getError().getMessage());\n}\n"
          },
          {
            "lang": "PHP",
            "source": "try {\n    $invoice_update =  [\n      \"customer_notes\" => \"New Notes\",\n      \"terms_and_conditions\" => \"New terms and conditions\",\n    ];\n    $invoice = $client->updateInvoice($invoice_id, $invoice_update);\n\n    echo 'Updated Invoice:' . PHP_EOL;\n    var_dump($invoice);\n} catch (\\Recurly\\Errors\\Validation $e) {\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in err.params\n    var_dump($e);\n} catch (\\Recurly\\RecurlyError $e) {\n    // If we don't know what to do with the err, we should\n    // probably re-raise and let our web framework and logger handle it\n    var_dump($e);\n}\n"
          },
          {
            "lang": "Go",
            "source": "updateReq := &recurly.InvoiceUpdate{\n\tCustomerNotes:      recurly.String(\"New Notes\"),\n\tTermsAndConditions: recurly.String(\"New Terms and Conditions\"),\n}\ninvoice, err := client.UpdateInvoice(invoiceID, updateReq)\nif e, ok := err.(*recurly.Error); ok {\n\tif e.Type == recurly.ErrorTypeValidation {\n\t\tfmt.Printf(\"Failed validation: %v\", e)\n\t\treturn nil, err\n\t}\n\tfmt.Printf(\"Unexpected Recurly error: %v\", e)\n\treturn nil, err\n}\nfmt.Printf(\"Updated Invoice: %s\", invoice.Id)"
          }
        ]
      }
    },
    "/invoices/{invoice_id}.pdf": {
      "get": {
        "tags": [
          "invoice"
        ],
        "operationId": "get_invoice_pdf",
        "summary": "Fetch an invoice as a PDF",
        "parameters": [
          {
            "$ref": "#/components/parameters/invoice_id"
          }
        ],
        "responses": {
          "200": {
            "description": "An invoice as a PDF.",
            "content": {
              "application/pdf": {
                "schema": {
                  "$ref": "#/components/schemas/BinaryFile"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site or invoice ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": [
          {
            "lang": "Node.js",
            "source": "try {\n  const invoice = await client.getInvoicePdf(invoiceId)\n  console.log('Fetched Invoice: ', invoice)\n  const filename = `${downloadDirectory}/nodeinvoice-${invoiceId}.pdf`\n  await fs.writeFile(filename, invoice.data, 'binary', (err) => {\n    // throws an error, you could also catch it here\n    if (err) throw err;\n\n    // success case, the file was saved\n    console.log('Saved Invoice PDF to', filename)\n  })\n} catch (err) {\n  if (err instanceof recurly.errors.NotFoundError) {\n    // If the request was not found, you may want to alert the user or\n    // just return null\n    console.log('Resource Not Found')\n  } else {\n    // If we don't know what to do with the err, we should\n    // probably re-raise and let our web framework and logger handle it\n    console.log('Unknown Error: ', err)\n  }\n}\n"
          },
          {
            "lang": "Python",
            "source": "try:\n    invoice = client.get_invoice_pdf(invoice_id)\n    print(\"Got Invoice %s\" % invoice)\n    filename = \"%s/pythoninvoice-%s.pdf\" % (download_directory, invoice_id)\n    with open(filename, 'wb') as file:\n        file.write(invoice.data)\n        print(\"Saved Invoice PDF to %s\" % filename)\nexcept recurly.errors.NotFoundError:\n    # If the resource was not found, you may want to alert the user or\n    # just return nil\n    print(\"Resource Not Found\")\n"
          },
          {
            "lang": ".NET",
            "source": "try\n{\n    BinaryFile invoice = client.GetInvoicePdf(invoiceId);\n    string filename = $\"{downloadDirectory}/dotnetinvoice-{invoiceId}.pdf\";\n    System.IO.File.WriteAllBytes(filename, invoice.Data);\n    Console.WriteLine($\"Saved Invoice PDF to {filename}\");\n}\ncatch (Recurly.Errors.NotFound ex)\n{\n    // If the resource was not found\n    // we may want to alert the user or just return null\n    Console.WriteLine($\"Resource Not Found: {ex.Error.Message}\");\n}\ncatch (Recurly.Errors.ApiError ex)\n{\n    // Use ApiError to catch a generic error from the API\n    Console.WriteLine($\"Unexpected Recurly Error: {ex.Error.Message}\");\n}\n"
          },
          {
            "lang": "Ruby",
            "source": "begin\n  invoice = @client.get_invoice_pdf(invoice_id: invoice_id)\n  puts \"Got invoice #{invoice}\"\n  filename = \"#{download_directory}/rubyinvoice-#{invoice_id}.pdf\"\n  IO.write(filename, invoice.data)\n  puts \"Saved Invoice PDF to #{filename}\"\nrescue Recurly::Errors::NotFoundError\n  # If the resource was not found, you may want to alert the user or\n  # just return nil\n  puts \"Resource Not Found\"\nend\n"
          },
          {
            "lang": "Java",
            "source": "try {\n    final BinaryFile invoice = client.getInvoicePdf(invoiceId);\n    //System.out.println(\"Fetched invoice \" + invoice.getData());\n    String filename = downloadDirectory + \"/javainvoice-\" + invoiceId + \".pdf\";\n\n    FileOutputStream fos = new FileOutputStream(filename);\n    fos.write(invoice.getData());\n    fos.close();\n    System.out.println(\"Saved Invoice PDF to \" + filename);\n} catch (NotFoundException e) {\n    // If the resource was not found\n    // we may want to alert the user or just return null\n    System.out.println(\"Resource Not Found: \" + e.getError().getMessage());\n} catch (ApiException e) {\n    // Use ApiException to catch a generic error from the API\n    System.out.println(\"Unexpected Recurly Error: \" + e.getError().getMessage());\n} catch (java.io.IOException e) {\n    System.out.println(\"Unexpected File Writing Error: \" + e.toString());\n}\n"
          },
          {
            "lang": "PHP",
            "source": "try {\n    $invoice = $client->getInvoicePdf($invoice_id);\n    echo 'Got Invoice PDF:' . PHP_EOL;\n    var_dump($invoice);\n    $invoice_fp = fopen(\"php-invoice-\" . $invoice_id . \".pdf\", \"w\");\n    fwrite($invoice_fp, $invoice->getData());\n    fclose($invoice_fp);\n} catch (\\Recurly\\Errors\\NotFound $e) {\n    // Could not find the resource, you may want to inform the user\n    // or just return a NULL\n    echo 'Could not find resource.' . PHP_EOL;\n    var_dump($e);\n} catch (\\Recurly\\RecurlyError $e) {\n    // Something bad happened... tell the user so that they can fix it?\n    echo 'Some unexpected Recurly error happened. Try again later.' . PHP_EOL;\n}\n"
          }
        ]
      }
    },
    "/invoices/{invoice_id}/apply_credit_balance": {
      "put": {
        "tags": [
          "invoice"
        ],
        "operationId": "apply_credit_balance",
        "summary": "Apply available credit to a pending or past due charge invoice",
        "description": "Apply credit payment to the outstanding balance on an existing charge invoice from an accountâ€™s available balance from existing credit invoices.",
        "parameters": [
          {
            "$ref": "#/components/parameters/site_id"
          },
          {
            "$ref": "#/components/parameters/invoice_id"
          }
        ],
        "responses": {
          "200": {
            "description": "The updated invoice.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Invoice"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site or invoice ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "422": {
            "description": "Tried applying credit to a legacy or closed invoice or there was an error processing the credit payment, such as no available credit on the account.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": [
          {
            "lang": "Node.js",
            "source": "try {\n  const invoice = await client.applyCreditBalance(invoiceId)\n  console.log('Applied credit balance to invoice: ', invoice)\n} catch (err) {\n  if (err instanceof recurly.errors.ValidationError) {\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in err.params\n    console.log('Failed validation', err.params)\n  } else {\n    // If we don't know what to do with the err, we should\n    // probably re-raise and let our web framework and logger handle it\n    console.log('Unknown Error: ', err)\n  }\n}\n"
          },
          {
            "lang": "Python",
            "source": "try:\n    invoice = client.apply_credit_balance(invoice_id)\n    print(\"Applied credit balance to invoice %s\" % invoice.id)\nexcept recurly.errors.NotFoundError:\n    # If the resource was not found, you may want to alert the user or\n    # just return nil\n    print(\"Resource Not Found\")\n"
          },
          {
            "lang": ".NET",
            "source": "try\n{\n    Invoice invoice = client.ApplyCreditBalance(invoiceId);\n    Console.WriteLine($\"Applied credit balance to invoice #{invoice.Number}\");\n}\ncatch (Recurly.Errors.Validation ex)\n{\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in ex.Error.Params\n    Console.WriteLine($\"Failed validation: {ex.Error.Message}\");\n}\ncatch (Recurly.Errors.ApiError ex)\n{\n    // Use ApiError to catch a generic error from the API\n    Console.WriteLine($\"Unexpected Recurly Error: {ex.Error.Message}\");\n}\n"
          },
          {
            "lang": "Ruby",
            "source": "begin\n  invoice = @client.apply_credit_balance(invoice_id: invoice_id)\n  puts \"Applied credit balance to invoice #{invoice}\"\nrescue Recurly::Errors::NotFoundError\n  # If the resource was not found, you may want to alert the user or\n  # just return nil\n  puts \"Resource Not Found\"\nend\n"
          },
          {
            "lang": "Java",
            "source": "try {\n  final Invoice invoice = client.applyCreditBalance(invoiceId);\n  System.out.println(\"Applied credit balance to invoice \" + invoice.getId());\n} catch (final ValidationException e) {\n  // If the request was not valid, you may want to tell your user\n  // why. You can find the invalid params and reasons in e.getError().getParams()\n  System.out.println(\"Failed validation: \" + e.getError().getMessage());\n} catch (final ApiException e) {\n    // Use ApiException to catch a generic error from the API\n    System.out.println(\"Unexpected Recurly Error: \" + e.getError().getMessage());\n}\n"
          },
          {
            "lang": "PHP",
            "source": "try {\n    $invoice = $client->applyCreditBalance($invoice_id);\n\n    echo 'Applied credit balance to invoice:' . PHP_EOL;\n    var_dump($invoice);\n} catch (\\Recurly\\Errors\\Validation $e) {\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in err.params\n    var_dump($e);\n} catch (\\Recurly\\RecurlyError $e) {\n    // If we don't know what to do with the err, we should\n    // probably re-raise and let our web framework and logger handle it\n    var_dump($e);\n}\n"
          },
          {
            "lang": "Go",
            "source": "invoice, err := client.ApplyCreditBalance(invoiceID)\nif e, ok := err.(*recurly.Error); ok {\n\tif e.Type == recurly.ErrorTypeValidation {\n\t\tfmt.Printf(\"Failed validation: %v\", e)\n\t\treturn nil, err\n\t}\n\tfmt.Printf(\"Unexpected Recurly error: %v\", e)\n\treturn nil, err\n}\n\nfmt.Printf(\"Applied credit balance to invoice: %v\", invoice)"
          }
        ]
      }
    },
    "/invoices/{invoice_id}/collect": {
      "put": {
        "tags": [
          "invoice"
        ],
        "operationId": "collect_invoice",
        "summary": "Collect a pending or past due, automatic invoice",
        "description": "Force a collection attempt using the stored billing information. This will trigger a transaction outside of Recurly's normal retry logic.",
        "parameters": [
          {
            "$ref": "#/components/parameters/invoice_id"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/InvoiceCollect"
              }
            }
          },
          "required": false
        },
        "responses": {
          "200": {
            "description": "The updated invoice.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Invoice"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site or invoice ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "422": {
            "description": "Tried collecting a manual or closed invoice, or there was an error processing the transaction.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorMayHaveTransaction"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": [
          {
            "lang": "Node.js",
            "source": "try {\n  const invoice = await client.collectInvoice(invoiceId)\n  console.log('Collected invoice: ', invoice.number)\n} catch (err) {\n  if (err instanceof recurly.errors.ValidationError) {\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in err.params\n    console.log('Failed validation', err.params)\n  } else {\n    // If we don't know what to do with the err, we should\n    // probably re-raise and let our web framework and logger handle it\n    console.log('Unknown Error: ', err)\n  }\n}\n"
          },
          {
            "lang": "Python",
            "source": "try:\n    invoice = client.collect_invoice(invoice_id)\n    print(\"Collected Invoice %s\" % invoice)\nexcept recurly.errors.NotFoundError as e:\n    print(\"Invoice not found\")\n"
          },
          {
            "lang": ".NET",
            "source": "try\n{\n    Invoice invoice = client.CollectInvoice(invoiceId);\n    Console.WriteLine($\"Collected invoice #{invoice.Number}\");\n}\ncatch (Recurly.Errors.Validation ex)\n{\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in ex.Error.Params\n    Console.WriteLine($\"Failed validation: {ex.Error.Message}\");\n}\ncatch (Recurly.Errors.ApiError ex)\n{\n    // Use ApiError to catch a generic error from the API\n    Console.WriteLine($\"Unexpected Recurly Error: {ex.Error.Message}\");\n}\n"
          },
          {
            "lang": "Ruby",
            "source": "begin\n  invoice = @client.collect_invoice(invoice_id: invoice_id)\n  puts \"Collected invoice #{invoice}\"\nrescue Recurly::Errors::NotFoundError\n  # If the resource was not found, you may want to alert the user or\n  # just return nil\n  puts \"Resource Not Found\"\nend\n"
          },
          {
            "lang": "Java",
            "source": "try {\n    final Invoice invoice = client.collectInvoice(invoiceId);\n    System.out.println(\"Collected invoice: \" + invoice.getNumber());\n} catch (ValidationException e) {\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in e.getError().getParams()\n    System.out.println(\"Failed validation: \" + e.getError().getMessage());\n} catch (ApiException e) {\n    // Use ApiException to catch a generic error from the API\n    System.out.println(\"Unexpected Recurly Error: \" + e.getError().getMessage());\n}\n"
          },
          {
            "lang": "PHP",
            "source": "try {\n    $invoice = $client->collectInvoice($invoice_id);\n\n    echo 'Collected Invoice:' . PHP_EOL;\n    var_dump($invoice);\n} catch (\\Recurly\\Errors\\Validation $e) {\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in err.params\n    var_dump($e);\n} catch (\\Recurly\\RecurlyError $e) {\n    // If we don't know what to do with the err, we should\n    // probably re-raise and let our web framework and logger handle it\n    var_dump($e);\n}\n"
          },
          {
            "lang": "Go",
            "source": "collectInvoiceParams := &recurly.CollectInvoiceParams{\n\tBody: &recurly.InvoiceCollect{\n\t\tTransactionType: recurly.String(\"moto\"),\n\t},\n}\n\ncollectedInvoice, err := client.CollectInvoice(invoiceID, collectInvoiceParams)\nif e, ok := err.(*recurly.Error); ok {\n\tif e.Type == recurly.ErrorTypeValidation {\n\t\tfmt.Printf(\"Failed validation: %v\", e)\n\t\treturn nil, err\n\t}\n\tfmt.Printf(\"Unexpected Recurly error: %v\", e)\n\treturn nil, err\n}\nfmt.Printf(\"Collected Invoice: %v\", collectedInvoice)"
          }
        ]
      }
    },
    "/invoices/{invoice_id}/mark_failed": {
      "put": {
        "tags": [
          "invoice"
        ],
        "operationId": "mark_invoice_failed",
        "summary": "Mark an open invoice as failed",
        "description": "Indicates that the invoice was not successfully paid for and that collection attempts should stop. This functionality is mostly used to halt the dunning procedures for an invoice.\n\nOnly invoices with the `pending`, `processing` or `past_due` states can be marked as failed.\n",
        "parameters": [
          {
            "$ref": "#/components/parameters/invoice_id"
          }
        ],
        "responses": {
          "200": {
            "description": "The updated invoice.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Invoice"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site or invoice ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "422": {
            "description": "Tried marking a closed (successful or failed) invoice as failed.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": [
          {
            "lang": "Node.js",
            "source": "try {\n  const invoice = await client.markInvoiceFailed(invoiceId)\n  console.log('Failed invoice: ', invoice.number)\n} catch (err) {\n  if (err instanceof recurly.errors.ValidationError) {\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in err.params\n    console.log('Failed validation', err.params)\n  } else {\n    // If we don't know what to do with the err, we should\n    // probably re-raise and let our web framework and logger handle it\n    console.log('Unknown Error: ', err)\n  }\n}\n"
          },
          {
            "lang": "Python",
            "source": "try:\n    invoice = client.mark_invoice_failed(invoice_id)\n    print(\"Failed Invoice %s\" % invoice.id)\nexcept recurly.errors.NotFoundError:\n    # If the resource was not found, you may want to alert the user or\n    # just return nil\n    print(\"Resource Not Found\")\n"
          },
          {
            "lang": ".NET",
            "source": "try\n{\n    Invoice invoice = client.MarkInvoiceFailed(invoiceId);\n    Console.WriteLine($\"Failed invoice #{invoice.Number}\");\n}\ncatch (Recurly.Errors.Validation ex)\n{\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in ex.Error.Params\n    Console.WriteLine($\"Failed validation: {ex.Error.Message}\");\n}\ncatch (Recurly.Errors.ApiError ex)\n{\n    // Use ApiError to catch a generic error from the API\n    Console.WriteLine($\"Unexpected Recurly Error: {ex.Error.Message}\");\n}\n"
          },
          {
            "lang": "Ruby",
            "source": "begin\n  invoice = @client.mark_invoice_failed(invoice_id: invoice_id)\n  puts \"Failed invoice #{invoice}\"\nrescue Recurly::Errors::NotFoundError\n  # If the resource was not found, you may want to alert the user or\n  # just return nil\n  puts \"Resource Not Found\"\nend\n"
          },
          {
            "lang": "Java",
            "source": "try {\n    final Invoice invoice = client.markInvoiceFailed(invoiceId);\n    System.out.println(\"Failed invoice: \" + invoice.getNumber());\n} catch (ValidationException e) {\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in e.getError().getParams()\n    System.out.println(\"Failed validation: \" + e.getError().getMessage());\n} catch (ApiException e) {\n    // Use ApiException to catch a generic error from the API\n    System.out.println(\"Unexpected Recurly Error: \" + e.getError().getMessage());\n}\n"
          },
          {
            "lang": "PHP",
            "source": "try {\n    $invoice = $client->markInvoiceFailed($invoice_id);\n\n    echo 'Failed Invoice:' . PHP_EOL;\n    var_dump($invoice);\n} catch (\\Recurly\\Errors\\NotFound $e) {\n    // Could not find the resource, you may want to inform the user\n    // or just return a NULL\n    echo 'Could not find resource.' . PHP_EOL;\n    var_dump($e);\n} catch (\\Recurly\\RecurlyError $e) {\n    // Something bad happened... tell the user so that they can fix it?\n    echo 'Some unexpected Recurly error happened. Try again later.' . PHP_EOL;\n}\n"
          },
          {
            "lang": "Go",
            "source": "invoice, err := client.MarkInvoiceFailed(invoiceID)\nif e, ok := err.(*recurly.Error); ok {\n\tif e.Type == recurly.ErrorTypeValidation {\n\t\tfmt.Printf(\"Failed validation: %v\", e)\n\t\treturn nil, err\n\t}\n\tfmt.Printf(\"Unexpected Recurly error: %v\", e)\n\treturn nil, err\n}\nfmt.Printf(\"Invoice failed: %v\", invoice)"
          }
        ]
      }
    },
    "/invoices/{invoice_id}/mark_successful": {
      "put": {
        "tags": [
          "invoice"
        ],
        "operationId": "mark_invoice_successful",
        "summary": "Mark an open invoice as successful",
        "description": "Indicates that the invoice was successfully paid for and that automated collection attempts should stop - this functionality is typically used to indicate that payment was received via another method and that revenue should be recognized.\n\nOnly invoices with the `pending`, `processing`, `past_due` or `failed` states can be marked as paid.\n",
        "parameters": [
          {
            "$ref": "#/components/parameters/invoice_id"
          }
        ],
        "responses": {
          "200": {
            "description": "The updated invoice.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Invoice"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site or invoice ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "422": {
            "description": "Tried marking a closed (successful or failed) invoice as successful.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": [
          {
            "lang": "Node.js",
            "source": "try {\n  const invoice = await client.markInvoiceSuccessful(invoiceId)\n  console.log(`Marked invoice #${invoice.number} successful`)\n} catch(err) {\n\n  if (err instanceof recurly.errors.ValidationError) {\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in err.params\n    console.log('Failed validation', err.params)\n  } else {\n    // If we don't know what to do with the err, we should\n    // probably re-raise and let our web framework and logger handle it\n    console.log('Unknown Error: ', err)\n  }\n}\n"
          },
          {
            "lang": "Python",
            "source": "try:\n    params = {\"limit\": 200}\n    invoice = client.mark_invoice_successful(invoice_id, params=params)\n    print(\"Marked Invoice successful %s\" % invoice)\nexcept recurly.errors.ValidationError as e:\n    # If the request was invalid, you may want to tell your user\n    # why. You can find the invalid params and reasons in e.error.params\n    print(\"ValidationError: %s\" % e.error.message)\n    print(e.error.params)\n"
          },
          {
            "lang": ".NET",
            "source": "try\n{\n    Invoice invoice = client.MarkInvoiceSuccessful(invoiceId);\n    Console.WriteLine($\"Marked invoice #{invoice.Number} successful\");\n}\ncatch (Recurly.Errors.Validation ex)\n{\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in ex.Error.Params\n    Console.WriteLine($\"Failed validation: {ex.Error.Message}\");\n}\ncatch (Recurly.Errors.ApiError ex)\n{\n    // Use ApiError to catch a generic error from the API\n    Console.WriteLine($\"Unexpected Recurly Error: {ex.Error.Message}\");\n}\n"
          },
          {
            "lang": "Ruby",
            "source": "begin\n  invoice = @client.mark_invoice_successful(invoice_id: invoice_id)\n  puts \"Marked invoice sucessful #{invoice}\"\nrescue Recurly::Errors::NotFoundError\n  # If the resource was not found, you may want to alert the user or\n  # just return nil\n  puts \"Resource Not Found\"\nend\n"
          },
          {
            "lang": "Java",
            "source": "try {\n    final Invoice invoice = client.markInvoiceSuccessful(invoiceId);\n    System.out.println(\"Marked invoice \" + invoice.getNumber() + \" successful\");\n} catch (ValidationException e) {\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in e.getError().getParams()\n    System.out.println(\"Failed validation: \" + e.getError().getMessage());\n} catch (ApiException e) {\n    // Use ApiException to catch a generic error from the API\n    System.out.println(\"Unexpected Recurly Error: \" + e.getError().getMessage());\n}\n"
          },
          {
            "lang": "PHP",
            "source": "try {\n    $invoice = $client->markInvoiceSuccessful($invoice_id);\n\n    echo 'Marked Invoice Successful:' . PHP_EOL;\n    var_dump($invoice);\n} catch (\\Recurly\\Errors\\NotFound $e) {\n    // Could not find the resource, you may want to inform the user\n    // or just return a NULL\n    echo 'Could not find resource.' . PHP_EOL;\n    var_dump($e);\n} catch (\\Recurly\\RecurlyError $e) {\n    // Something bad happened... tell the user so that they can fix it?\n    echo 'Some unexpected Recurly error happened. Try again later.' . PHP_EOL;\n}\n"
          },
          {
            "lang": "Go",
            "source": "invoice, err := client.MarkInvoiceSuccessful(invoiceID)\nif e, ok := err.(*recurly.Error); ok {\n\tif e.Type == recurly.ErrorTypeValidation {\n\t\tfmt.Printf(\"Failed validation: %v\", e)\n\t\treturn nil, err\n\t}\n\tfmt.Printf(\"Unexpected Recurly error: %v\", e)\n\treturn nil, err\n}\n\nfmt.Printf(\"Marked Invoice Successful: %v\", invoice)"
          }
        ]
      }
    },
    "/invoices/{invoice_id}/reopen": {
      "put": {
        "tags": [
          "invoice"
        ],
        "operationId": "reopen_invoice",
        "summary": "Reopen a closed, manual invoice",
        "parameters": [
          {
            "$ref": "#/components/parameters/invoice_id"
          }
        ],
        "responses": {
          "200": {
            "description": "The updated invoice.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Invoice"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site or invoice ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "422": {
            "description": "Tried reopening an automatic transaction, or an invoice that wasn't closed (`successful` or `failed`).",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": [
          {
            "lang": "Node.js",
            "source": "try {\n  const invoice = await client.reopenInvoice(invoiceId)\n  console.log('Reopened invoice: ', invoice.number)\n} catch (err) {\n  if (err instanceof recurly.errors.NotFoundError) {\n    // If the request was not found, you may want to alert the user or\n    // just return null\n    console.log('Resource Not Found')\n  } else {\n    // If we don't know what to do with the err, we should\n    // probably re-raise and let our web framework and logger handle it\n    console.log('Unknown Error: ', err)\n  }\n}\n"
          },
          {
            "lang": "Python",
            "source": "try:\n    invoice = client.reopen_invoice(invoice_id)\n    print(\"Reopened Invoice %s\" % invoice.id)\nexcept recurly.errors.NotFoundError:\n    # If the resource was not found, you may want to alert the user or\n    # just return nil\n    print(\"Resource Not Found\")\n"
          },
          {
            "lang": ".NET",
            "source": "try\n{\n    Invoice invoice = client.ReopenInvoice(invoiceId);\n    Console.WriteLine($\"Reopened invoice #{invoice.Number}\");\n}\ncatch (Recurly.Errors.Validation ex)\n{\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in ex.Error.Params\n    Console.WriteLine($\"Failed validation: {ex.Error.Message}\");\n}\ncatch (Recurly.Errors.ApiError ex)\n{\n    // Use ApiError to catch a generic error from the API\n    Console.WriteLine($\"Unexpected Recurly Error: {ex.Error.Message}\");\n}\n"
          },
          {
            "lang": "Ruby",
            "source": "begin\n  invoice = @client.reopen_invoice(invoice_id: invoice_id)\n  puts \"Reopened invoice #{invoice}\"\nrescue Recurly::Errors::NotFoundError\n  # If the resource was not found, you may want to alert the user or\n  # just return nil\n  puts \"Resource Not Found\"\nend\n"
          },
          {
            "lang": "Java",
            "source": "try {\n    final Invoice invoice = client.reopenInvoice(invoiceId);\n    System.out.println(\"Reopened invoice: \" + invoice.getNumber());\n} catch (ValidationException e) {\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in e.getError().getParams()\n    System.out.println(\"Failed validation: \" + e.getError().getMessage());\n} catch (ApiException e) {\n    // Use ApiException to catch a generic error from the API\n    System.out.println(\"Unexpected Recurly Error: \" + e.getError().getMessage());\n}\n"
          },
          {
            "lang": "PHP",
            "source": "try {\n    $invoice = $client->reopenInvoice($invoice_id);\n\n    echo 'Reopened Invoice:' . PHP_EOL;\n    var_dump($invoice);\n} catch (\\Recurly\\Errors\\Validation $e) {\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in err.params\n    var_dump($e);\n} catch (\\Recurly\\RecurlyError $e) {\n    // If we don't know what to do with the err, we should\n    // probably re-raise and let our web framework and logger handle it\n    var_dump($e);\n}\n"
          },
          {
            "lang": "Go",
            "source": "invoice, err := client.ReopenInvoice(invoiceID)\nif e, ok := err.(*recurly.Error); ok {\n\tif e.Type == recurly.ErrorTypeNotFound {\n\t\tfmt.Printf(\"Resource not found: %v\", e)\n\t\treturn nil, err\n\t}\n\tfmt.Printf(\"Unexpected Recurly error: %v\", e)\n\treturn nil, err\n}\n\nfmt.Printf(\"Reopened Invoice: %v\", invoice)"
          }
        ]
      }
    },
    "/invoices/{invoice_id}/void": {
      "put": {
        "tags": [
          "invoice"
        ],
        "operationId": "void_invoice",
        "summary": "Void a credit invoice.",
        "description": "Invoice must be a credit invoice (`type=credit`) and cannot be closed (`state=closed`), processing (`state=processing`), or already voided.",
        "parameters": [
          {
            "$ref": "#/components/parameters/invoice_id"
          }
        ],
        "responses": {
          "200": {
            "description": "The updated invoice.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Invoice"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site or invoice ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "422": {
            "description": "Invoice did not meet the conditions to be voided.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": [
          {
            "lang": "Node.js",
            "source": "try {\n  const invoice = await client.voidInvoice(invoiceId)\n  console.log('Voided invoice: ', invoice)\n} catch (err) {\n  if (err instanceof recurly.errors.ValidationError) {\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in err.params\n    console.log('Failed validation', err.params)\n  } else {\n    // If we don't know what to do with the err, we should\n    // probably re-raise and let our web framework and logger handle it\n    console.log('Unknown Error: ', err)\n  }\n}\n"
          },
          {
            "lang": "Python",
            "source": "try:\n    invoice = client.void_invoice(invoice_id)\n    print(\"Voided Invoice %s\" % invoice.id)\nexcept recurly.errors.NotFoundError:\n    # If the resource was not found, you may want to alert the user or\n    # just return nil\n    print(\"Resource Not Found\")\n"
          },
          {
            "lang": "Ruby",
            "source": "begin\n  invoice = @client.void_invoice(invoice_id: invoice_id)\n  puts \"Voided invoice #{invoice}\"\nrescue Recurly::Errors::NotFoundError\n  # If the resource was not found, you may want to alert the user or\n  # just return nil\n  puts \"Resource Not Found\"\nend\n"
          },
          {
            "lang": "Java",
            "source": "try {\n  final Invoice invoice = client.voidInvoice(invoiceId);\n  System.out.println(\"Voided invoice \" + invoice.getId());\n} catch (final ValidationException e) {\n  // If the request was not valid, you may want to tell your user\n  // why. You can find the invalid params and reasons in e.getError().getParams()\n  System.out.println(\"Failed validation: \" + e.getError().getMessage());\n} catch (final ApiException e) {\n    // Use ApiException to catch a generic error from the API\n    System.out.println(\"Unexpected Recurly Error: \" + e.getError().getMessage());\n}\n"
          },
          {
            "lang": "PHP",
            "source": "try {\n    $invoice = $client->voidInvoice($invoice_id);\n\n    echo 'Voided Invoice:' . PHP_EOL;\n    var_dump($invoice);\n} catch (\\Recurly\\Errors\\Validation $e) {\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in err.params\n    var_dump($e);\n} catch (\\Recurly\\RecurlyError $e) {\n    // If we don't know what to do with the err, we should\n    // probably re-raise and let our web framework and logger handle it\n    var_dump($e);\n}\n"
          },
          {
            "lang": "Go",
            "source": "invoice, err := client.VoidInvoice(invoiceID)\nif e, ok := err.(*recurly.Error); ok {\n\tif e.Type == recurly.ErrorTypeValidation {\n\t\tfmt.Printf(\"Failed validation: %v\", e)\n\t\treturn nil, err\n\t}\n\tfmt.Printf(\"Unexpected Recurly error: %v\", e)\n\treturn nil, err\n}\n\nfmt.Printf(\"Voided Invoice: %v\", invoice)"
          }
        ]
      }
    },
    "/invoices/{invoice_id}/transactions": {
      "post": {
        "tags": [
          "invoice"
        ],
        "operationId": "record_external_transaction",
        "summary": "Record an external payment for a manual invoices.",
        "description": "This endpoint allows you to record an offline payment that was not captured through your gateway. It will throw an error for an auto-collecting invoice.",
        "parameters": [
          {
            "$ref": "#/components/parameters/invoice_id"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ExternalTransaction"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "The recorded transaction.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Transaction"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site or invoice ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "422": {
            "description": "Invoice did not meet the conditions for an offline transaction.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": [
          {
            "lang": "Node.js",
            "source": "try {\n  const externalTrx = {\n    description: \"A check collected outside of Recurly\",\n    amount: 10.0,\n    payment_method: 'check'\n  }\n  const transaction = await client.recordExternalTransaction(invoiceId, externalTrx)\n  console.log('External Transaction: ', transaction)\n} catch (err) {\n  if (err instanceof recurly.errors.NotFoundError) {\n    // If the request was not found, you may want to alert the user or\n    // just return null\n    console.log('Resource Not Found')\n  } else {\n    // If we don't know what to do with the err, we should\n    // probably re-raise and let our web framework and logger handle it\n    console.log('Unknown Error: ', err)\n  }\n}\n"
          }
        ]
      }
    },
    "/invoices/{invoice_id}/line_items": {
      "get": {
        "tags": [
          "line_item"
        ],
        "operationId": "list_invoice_line_items",
        "summary": "List an invoice's line items",
        "description": "See the [Pagination Guide](/developers/guides/pagination.html) to learn how to use pagination in the API and Client Libraries.",
        "parameters": [
          {
            "$ref": "#/components/parameters/invoice_id"
          },
          {
            "$ref": "#/components/parameters/ids"
          },
          {
            "$ref": "#/components/parameters/limit"
          },
          {
            "$ref": "#/components/parameters/order"
          },
          {
            "$ref": "#/components/parameters/sort_dates"
          },
          {
            "$ref": "#/components/parameters/filter_begin_time"
          },
          {
            "$ref": "#/components/parameters/filter_end_time"
          },
          {
            "$ref": "#/components/parameters/filter_line_item_original"
          },
          {
            "$ref": "#/components/parameters/filter_line_item_state"
          },
          {
            "$ref": "#/components/parameters/filter_line_item_type"
          }
        ],
        "responses": {
          "200": {
            "description": "A list of the invoice's line items.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LineItemList"
                }
              }
            }
          },
          "400": {
            "description": "Invalid or unpermitted parameter.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": [
          {
            "lang": "Node.js",
            "source": "const lineItems = client.listInvoiceLineItems(invoiceId, { params: { limit: 200 } })\n\nfor await (const lineItem of lineItems.each()) {\n  console.log(lineItem.id)\n}\n"
          },
          {
            "lang": "Python",
            "source": "try:\n    params = {\"limit\": 200}\n    line_items = client.list_invoice_line_items(invoice_id, params=params).items()\n    for item in line_items:\n        print(\"Invoice Line Items %s\" % item.id)\nexcept recurly.errors.NotFoundError:\n    # If the resource was not found, you may want to alert the user or\n    # just return nil\n    print(\"Resource Not Found\")\n"
          },
          {
            "lang": ".NET",
            "source": "var lineItems = client.ListInvoiceLineItems(invoiceId);\nforeach(LineItem lineItem in lineItems)\n{\n    Console.WriteLine(lineItem.Id);\n}\n"
          },
          {
            "lang": "Ruby",
            "source": "params = {\n  limit: 200\n}\nline_items = @client.list_invoice_line_items(\n  invoice_id: invoice_id,\n  params: params\n)\nline_items.each do |line_item|\n  puts \"Line Item: #{line_item.id}\"\nend\n"
          },
          {
            "lang": "Java",
            "source": "QueryParams params = new QueryParams();\nparams.setLimit(200);\nPager<LineItem> lineItems = client.listInvoiceLineItems(invoiceId, params);\n\nfor (LineItem lineItem : lineItems) {\n  System.out.println(lineItem.getId());\n}\n"
          },
          {
            "lang": "PHP",
            "source": "$options = [\n  'params' => [\n    'limit' => 200\n  ]\n];\n$invoice_line_items = $client->listInvoiceLineItems($invoice_id, $options);\n\nforeach($invoice_line_items as $line_item) {\n  echo 'Invoice Line Item: ' . $line_item->getId() . PHP_EOL;\n}\n"
          },
          {
            "lang": "Go",
            "source": "listParams := &recurly.ListInvoiceLineItemsParams{\n\tSort: recurly.String(\"created_at\"),\n}\nlineItems, err := client.ListInvoiceLineItems(invoiceID, listParams)\nif err != nil {\n\tfmt.Println(\"Unexpected error: %v\", err)\n\treturn\n}\n\nfor lineItems.HasMore() {\n\terr := lineItems.Fetch()\n\tif e, ok := err.(*recurly.Error); ok {\n\t\tfmt.Printf(\"Failed to retrieve next page: %v\", e)\n\t\tbreak\n\t}\n\tfor i, lineItem := range lineItems.Data() {\n\t\tfmt.Printf(\"Invoice Line Item %3d: %s\\n\",\n\t\t\ti,\n\t\t\tlineItem.Id,\n\t\t)\n\t}\n}"
          }
        ]
      }
    },
    "/invoices/{invoice_id}/coupon_redemptions": {
      "get": {
        "tags": [
          "coupon_redemption"
        ],
        "operationId": "list_invoice_coupon_redemptions",
        "summary": "List the coupon redemptions applied to an invoice",
        "description": "See the [Pagination Guide](/developers/guides/pagination.html) to learn how to use pagination in the API and Client Libraries.",
        "parameters": [
          {
            "$ref": "#/components/parameters/invoice_id"
          },
          {
            "$ref": "#/components/parameters/ids"
          },
          {
            "$ref": "#/components/parameters/sort_dates"
          },
          {
            "$ref": "#/components/parameters/filter_begin_time"
          },
          {
            "$ref": "#/components/parameters/filter_end_time"
          }
        ],
        "responses": {
          "200": {
            "description": "A list of the the coupon redemptions associated with the invoice.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CouponRedemptionList"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site or invoice ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": [
          {
            "lang": "Node.js",
            "source": "const redemptions = client.listInvoiceCouponRedemptions(invoiceId, { params: { limit: 200 } })\n\nfor await (const redemption of redemptions.each()) {\n  console.log(redemption.id)\n}\n"
          },
          {
            "lang": "Python",
            "source": "params = {\"limit\": 200}\nredemptions = client.list_invoice_coupon_redemptions(invoice_id, params=params).items()\nfor redemption in redemptions:\n    print(\"Invoice Coupon Redemption %s\" % redemption)\n"
          },
          {
            "lang": ".NET",
            "source": "var couponRedemptions = client.ListInvoiceCouponRedemptions(invoiceId);\nforeach(CouponRedemption redemption in couponRedemptions)\n{\n    Console.WriteLine(redemption.Id);\n}\n"
          },
          {
            "lang": "Ruby",
            "source": "params = {\n  limit: 200\n}\ncoupon_redemptions = @client.list_invoice_coupon_redemptions(\n  invoice_id: invoice_id,\n  params: params\n)\ncoupon_redemptions.each do |redemption|\n  puts \"CouponRedemption: #{redemption.id}\"\nend\n"
          },
          {
            "lang": "Java",
            "source": "QueryParams params = new QueryParams();\nparams.setLimit(200); // Pull 200 records at a time\nfinal Pager<CouponRedemption> redemptions = client.listInvoiceCouponRedemptions(invoiceId, params);\n\nfor (CouponRedemption redemption : redemptions) {\n    System.out.println(redemption.getId());\n}\n"
          },
          {
            "lang": "PHP",
            "source": "$options = [\n  'params' => [\n    'limit' => 200\n  ]\n];\n$invoice_coupon_redemptions = $client->listInvoiceCouponRedemptions($invoice_id, $options);\n\nforeach($invoice_coupon_redemptions as $redemption) {\n  echo 'Invoice Coupon Redemption: ' . $redemption->getId() . PHP_EOL;\n}\n"
          },
          {
            "lang": "Go",
            "source": "listParams := &recurly.ListInvoiceCouponRedemptionsParams{\n\tSort: recurly.String(\"created_at\"),\n}\nredemptions, err := client.ListInvoiceCouponRedemptions(invoiceID, listParams)\nif err != nil {\n\tfmt.Println(\"Unexpected error: %v\", err)\n\treturn\n}\n\nfor redemptions.HasMore() {\n\terr := redemptions.Fetch()\n\tif e, ok := err.(*recurly.Error); ok {\n\t\tfmt.Printf(\"Failed to retrieve next page: %v\", e)\n\t\tbreak\n\t}\n\tfor i, redemption := range redemptions.Data() {\n\t\tfmt.Printf(\"Invoice Coupon Redemption %3d: %s\\n\",\n\t\t\ti,\n\t\t\tredemption.Id,\n\t\t)\n\t}\n}"
          }
        ]
      }
    },
    "/invoices/{invoice_id}/related_invoices": {
      "get": {
        "tags": [
          "invoice"
        ],
        "operationId": "list_related_invoices",
        "summary": "List an invoice's related credit or charge invoices",
        "description": "Related invoices provide a link between credit invoices and the charge invoices that they are refunding.\nFor a charge invoice the related invoices will be credit invoices.\nFor a credit invoice the related invoices will be charge invoices.\n\nSee the [Pagination Guide](/developers/guides/pagination.html) to learn how to use pagination in the API and Client Libraries.\n",
        "parameters": [
          {
            "$ref": "#/components/parameters/invoice_id"
          }
        ],
        "responses": {
          "200": {
            "description": "A list of the credit or charge invoices associated with the invoice.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/InvoiceList"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site or invoice ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": [
          {
            "lang": "Node.js",
            "source": "const invoices = client.listRelatedInvoices(invoiceId, { params: { limit: 200 } })\n\nfor await (const invoice of invoices.each()) {\n  console.log(invoice.number)\n}\n"
          },
          {
            "lang": "Python",
            "source": "try:\n    params = {\"limit\": 200}\n    related_invoices = client.list_related_invoices(invoice_id, params=params).items()\n    for invoice in related_invoices:\n        print(\"Related invoice %s\" % invoice.id)\nexcept recurly.errors.NotFoundError:\n    # If the resource was not found, you may want to alert the user or\n    # just return nil\n    print(\"Resource Not Found\")\n"
          },
          {
            "lang": ".NET",
            "source": "var invoices = client.ListRelatedInvoices(invoiceId);\nforeach(Invoice invoice in invoices)\n{\n    Console.WriteLine(invoice.Number);\n}\n"
          },
          {
            "lang": "Ruby",
            "source": "params = {\n  limit: 200\n}\ninvoices = @client.list_related_invoices(\n  invoice_id: invoice_id,\n  params: params\n)\ninvoices.each do |invoice|\n  puts \"Invoice: #{invoice.number}\"\nend\n"
          },
          {
            "lang": "Java",
            "source": "final Pager<Invoice> invoices = client.listRelatedInvoices(invoiceId);\n\nfor (Invoice invoice : invoices) {\n    System.out.println(invoice.getNumber());\n}\n"
          },
          {
            "lang": "PHP",
            "source": "$related_invoices = $client->listRelatedInvoices($invoice_id);\n\nforeach($related_invoices as $invoice) {\n  echo 'Related Invoice: ' . $invoice->getId() . PHP_EOL;\n}\n"
          },
          {
            "lang": "Go",
            "source": "invoices, err := client.ListRelatedInvoices(invoiceID)\nif err != nil {\n\tfmt.Println(\"Unexpected error: %v\", err)\n\treturn\n}\n\nfor invoices.HasMore() {\n\terr := invoices.Fetch()\n\tif e, ok := err.(*recurly.Error); ok {\n\t\tfmt.Printf(\"Failed to retrieve next page: %v\", e)\n\t\tbreak\n\t}\n\tfor i, invoice := range invoices.Data() {\n\t\tfmt.Printf(\"Related Invoice %3d: %s, %s\\n\",\n\t\t\ti,\n\t\t\tinvoice.Id,\n\t\t\tinvoice.Number,\n\t\t)\n\t}\n}"
          }
        ]
      }
    },
    "/invoices/{invoice_id}/refund": {
      "post": {
        "tags": [
          "invoice"
        ],
        "operationId": "refund_invoice",
        "summary": "Refund an invoice",
        "description": "There are two ways to do a refund:\n* refund a specific amount which is divided across all the line items.\n* refund quantities of line items.\nIf you want to refund the entire refundable amount on the invoice, the\nsimplest way is to do `type=amount` without specifiying an `amount`.\n",
        "parameters": [
          {
            "$ref": "#/components/parameters/invoice_id"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/InvoiceRefund"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Returns the new credit invoice.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Invoice"
                }
              }
            }
          },
          "400": {
            "description": "Invalid or unpermitted parameter.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site or invoice ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": [
          {
            "lang": "Node.js",
            "source": "try {\n  const invoiceRefund = {\n    creditCustomerNotes: \"Notes on credits\",\n    type: \"amount\", // could also be \"line_items\"\n    amount: 100\n  }\n\n  const invoice = await client.refundInvoice(invoiceId, invoiceRefund)\n  console.log('Refunded invoice: ', invoice.number)\n} catch(err) {\n\n  if (err instanceof recurly.errors.ValidationError) {\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in err.params\n    console.log('Failed validation', err.params)\n  } else {\n    // If we don't know what to do with the err, we should\n    // probably re-raise and let our web framework and logger handle it\n    console.log('Unknown Error: ', err)\n  }\n}\n"
          },
          {
            "lang": "Python",
            "source": "try:\n    invoice_refund = {\"type\": \"amount\", \"amount\": 100}\n    invoice = client.refund_invoice(invoice_id, invoice_refund)\n    print(\"Refunded Invoice %s\" % invoice)\nexcept recurly.errors.ValidationError as e:\n    # If the request was invalid, you may want to tell your user\n    # why. You can find the invalid params and reasons in e.error.params\n    print(\"ValidationError: %s\" % e.error.message)\n    print(e.error.params)\n"
          },
          {
            "lang": ".NET",
            "source": "try\n{\n    var refundReq = new InvoiceRefund() {\n        CreditCustomerNotes = \"Notes on credits\",\n        Type = InvoiceRefundType.Amount, // could also be \"line_items\"\n        Amount = 100\n    };\n    Invoice invoice = client.RefundInvoice(invoiceId, refundReq);\n    Console.WriteLine($\"Refunded Invoice #{invoice.Number}\");\n}\ncatch (Recurly.Errors.Validation ex)\n{\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in ex.Error.Params\n    Console.WriteLine($\"Failed validation: {ex.Error.Message}\");\n}\ncatch (Recurly.Errors.ApiError ex)\n{\n    // Use ApiError to catch a generic error from the API\n    Console.WriteLine($\"Unexpected Recurly Error: {ex.Error.Message}\");\n}\n"
          },
          {
            "lang": "Ruby",
            "source": "begin\n  invoice_refund = {\n    type: \"amount\",\n    amount: 100,\n  }\n  invoice = @client.refund_invoice(\n    invoice_id: invoice_id,\n    body: invoice_refund\n  )\n  puts \"Refunded invoice #{invoice}\"\nrescue Recurly::Errors::ValidationError => e\n  # If the request was invalid, you may want to tell your user\n  # why. You can find the invalid params and reasons in e.recurly_error.params\n  puts \"ValidationError: #{e.recurly_error.params}\"\nend\n"
          },
          {
            "lang": "Java",
            "source": "try {\n    final InvoiceRefund invoiceRefund = new InvoiceRefund();\n    invoiceRefund.setCreditCustomerNotes(\"Notes on credits\");\n    invoiceRefund.setType(Constants.InvoiceRefundType.AMOUNT); // could also be \"line_items\"\n    invoiceRefund.setAmount(new BigDecimal(\"100\"));\n\n    final Invoice invoice = client.refundInvoice(invoiceId, invoiceRefund);\n    System.out.println(\"Refunded invoice \" + invoice.getNumber());\n} catch (ValidationException e) {\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in e.getError().getParams()\n    System.out.println(\"Failed validation: \" + e.getError().getMessage());\n} catch (ApiException e) {\n    // Use ApiException to catch a generic error from the API\n    System.out.println(\"Unexpected Recurly Error: \" + e.getError().getMessage());\n}\n"
          },
          {
            "lang": "PHP",
            "source": "try {\n    $refund = [\n        \"type\" => \"amount\",\n        \"amount\" => 1\n    ];\n    $invoice_collection = $client->refundInvoice($invoice_id, $refund);\n\n    echo 'Refunded Invoice:' . PHP_EOL;\n    var_dump($invoice_collection);\n} catch (\\Recurly\\Errors\\NotFound $e) {\n    // Could not find the resource, you may want to inform the user\n    // or just return a NULL\n    echo 'Could not find resource.' . PHP_EOL;\n    var_dump($e);\n} catch (\\Recurly\\RecurlyError $e) {\n    // Something bad happened... tell the user so that they can fix it?\n    echo 'Some unexpected Recurly error happened. Try again later.' . PHP_EOL;\n}\n"
          },
          {
            "lang": "Go",
            "source": "refundReq := &recurly.InvoiceRefund{\n\tType:   recurly.String(\"amount\"),\n\tAmount: recurly.Float(1),\n\tExternalRefund: &recurly.ExternalRefund{\n\t\tPaymentMethod: recurly.String(\"credit_card\"),\n\t},\n}\ninvoice, err := client.RefundInvoice(invoiceID, refundReq)\nif e, ok := err.(*recurly.Error); ok {\n\tif e.Type == recurly.ErrorTypeValidation {\n\t\tfmt.Printf(\"Failed validation: %v\", e)\n\t\treturn nil, err\n\t}\n\tfmt.Printf(\"Unexpected Recurly error: %v\", e)\n\treturn nil, err\n}\n\nfmt.Printf(\"Refunded Invoice: %v\", invoice)"
          }
        ]
      }
    },
    "/line_items": {
      "get": {
        "tags": [
          "line_item"
        ],
        "operationId": "list_line_items",
        "summary": "List a site's line items",
        "description": "See the [Pagination Guide](/developers/guides/pagination.html) to learn how to use pagination in the API and Client Libraries.",
        "parameters": [
          {
            "$ref": "#/components/parameters/ids"
          },
          {
            "$ref": "#/components/parameters/limit"
          },
          {
            "$ref": "#/components/parameters/order"
          },
          {
            "$ref": "#/components/parameters/sort_dates"
          },
          {
            "$ref": "#/components/parameters/filter_begin_time"
          },
          {
            "$ref": "#/components/parameters/filter_end_time"
          },
          {
            "$ref": "#/components/parameters/filter_line_item_original"
          },
          {
            "$ref": "#/components/parameters/filter_line_item_state"
          },
          {
            "$ref": "#/components/parameters/filter_line_item_type"
          }
        ],
        "responses": {
          "200": {
            "description": "A list of the site's line items.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LineItemList"
                }
              }
            }
          },
          "400": {
            "description": "Invalid or unpermitted parameter.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": [
          {
            "lang": "Node.js",
            "source": "const lineItems = client.listLineItems({ params: { limit: 200 } })\n\nfor await (const item of lineItems.each()) {\n  console.log(`Item ${item.id} for ${item.amount}`)\n}\n"
          },
          {
            "lang": "Python",
            "source": "params = {\"limit\": 200}\nline_items = client.list_line_items(params=params).items()\nfor line_item in line_items:\n    print(line_item.id)\n"
          },
          {
            "lang": ".NET",
            "source": "var optionalParams = new ListLineItemsParams()\n{\n    Limit = 200\n};\nvar lineItems = client.ListLineItems(optionalParams);\nforeach(LineItem item in lineItems)\n{\n    Console.WriteLine($\"Item {item.Uuid} for {item.Amount}\");\n}\n"
          },
          {
            "lang": "Ruby",
            "source": "params = {\n  limit: 200\n}\nline_items = @client.list_line_items(\n  params: params\n)\nline_items.each do |line_item|\n  puts \"LineItem: #{line_item.id}\"\nend\n"
          },
          {
            "lang": "Java",
            "source": "QueryParams params = new QueryParams();\nparams.setLimit(200); // Pull 200 records at a time\nfinal Pager<LineItem> lineItems = client.listLineItems(params);\n\nfor (LineItem lineItem : lineItems) {\n    System.out.println(\"Item \" + lineItem.getUuid() + \" for \" + lineItem.getAmount());\n}\n"
          },
          {
            "lang": "PHP",
            "source": "$options = [\n  'params' => [\n    'limit' => 200\n  ]\n];\n$line_items = $client->listLineItems($options);\n\nforeach($line_items as $line_item) {\n  echo 'Line item: ' . $line_item->getId() . PHP_EOL;\n}\n"
          },
          {
            "lang": "Go",
            "source": "listParams := &recurly.ListLineItemsParams{\n\tSort:  recurly.String(\"created_at\"),\n\tOrder: recurly.String(\"desc\"),\n\tLimit: recurly.Int(200),\n}\nlineItems, err := client.ListLineItems(listParams)\nif err != nil {\n\tfmt.Println(\"Unexpected error: %v\", err)\n\treturn\n}\n\nfor lineItems.HasMore() {\n\terr := lineItems.Fetch()\n\tif e, ok := err.(*recurly.Error); ok {\n\t\tfmt.Printf(\"Failed to retrieve next page: %v\", e)\n\t\tbreak\n\t}\n\tfor i, lineItem := range lineItems.Data() {\n\t\tfmt.Printf(\"Line Item %3d: %s\\n\",\n\t\t\ti,\n\t\t\tlineItem.Id,\n\t\t)\n\t}\n}"
          }
        ]
      }
    },
    "/line_items/{line_item_id}": {
      "get": {
        "tags": [
          "line_item"
        ],
        "operationId": "get_line_item",
        "summary": "Fetch a line item",
        "parameters": [
          {
            "$ref": "#/components/parameters/line_item_id"
          }
        ],
        "responses": {
          "200": {
            "description": "A line item.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LineItem"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site or line item ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": [
          {
            "lang": "Node.js",
            "source": "try {\n  const lineItem = await client.getLineItem(lineItemId)\n  console.log('Fetched line item: ', lineItem.uuid)\n} catch (err) {\n  if (err instanceof recurly.errors.NotFoundError) {\n    // If the request was not found, you may want to alert the user or\n    // just return null\n    console.log('Resource Not Found')\n  } else {\n    // If we don't know what to do with the err, we should\n    // probably re-raise and let our web framework and logger handle it\n    console.log('Unknown Error: ', err)\n  }\n}\n"
          },
          {
            "lang": "Python",
            "source": "try:\n    line_item = client.get_line_item(line_item_id)\n    print(\"Got LineItem %s\" % line_item)\nexcept recurly.errors.NotFoundError:\n    # If the resource was not found, you may want to alert the user or\n    # just return nil\n    print(\"Resource Not Found\")\n"
          },
          {
            "lang": ".NET",
            "source": "try\n{\n    LineItem lineItem = client.GetLineItem(lineItemId);\n    Console.WriteLine($\"Fetched line item {lineItem.Uuid}\");\n}\ncatch (Recurly.Errors.NotFound ex)\n{\n    // If the resource was not found\n    // we may want to alert the user or just return null\n    Console.WriteLine($\"Resource Not Found: {ex.Error.Message}\");\n}\ncatch (Recurly.Errors.ApiError ex)\n{\n    // Use ApiError to catch a generic error from the API\n    Console.WriteLine($\"Unexpected Recurly Error: {ex.Error.Message}\");\n}\n"
          },
          {
            "lang": "Ruby",
            "source": "begin\n  line_item = @client.get_line_item(line_item_id: line_item_id)\n  puts \"Got LineItem #{line_item}\"\nrescue Recurly::Errors::NotFoundError\n  # If the resource was not found, you may want to alert the user or\n  # just return nil\n  puts \"Resource Not Found\"\nend\n"
          },
          {
            "lang": "Java",
            "source": "try {\n    final LineItem lineItem = client.getLineItem(lineItemId);\n    System.out.println(\"Fetched line item \" + lineItem.getUuid());\n} catch (NotFoundException e) {\n    // If the resource was not found\n    // we may want to alert the user or just return null\n    System.out.println(\"Resource Not Found: \" + e.getError().getMessage());\n} catch (ApiException e) {\n    // Use ApiException to catch a generic error from the API\n    System.out.println(\"Unexpected Recurly Error: \" + e.getError().getMessage());\n}\n"
          },
          {
            "lang": "PHP",
            "source": "try {\n    $line_item = $client->getLineItem($line_item_id);\n\n    echo 'Got LineItem:' . PHP_EOL;\n    var_dump($line_item);\n} catch (\\Recurly\\Errors\\NotFound $e) {\n    // Could not find the resource, you may want to inform the user\n    // or just return a NULL\n    echo 'Could not find resource.' . PHP_EOL;\n    var_dump($e);\n} catch (\\Recurly\\RecurlyError $e) {\n    // Something bad happened... tell the user so that they can fix it?\n    echo 'Some unexpected Recurly error happened. Try again later.' . PHP_EOL;\n}\n"
          },
          {
            "lang": "Go",
            "source": "lineItem, err := client.GetLineItem(lineItemID)\nif e, ok := err.(*recurly.Error); ok {\n\tif e.Type == recurly.ErrorTypeNotFound {\n\t\tfmt.Printf(\"Resource not found: %v\", e)\n\t\treturn nil, err\n\t}\n\tfmt.Printf(\"Unexpected Recurly error: %v\", e)\n\treturn nil, err\n}\nfmt.Printf(\"Fetched Line Item: %v\", lineItem)"
          }
        ]
      },
      "delete": {
        "tags": [
          "line_item"
        ],
        "operationId": "remove_line_item",
        "summary": "Delete an uninvoiced line item",
        "parameters": [
          {
            "$ref": "#/components/parameters/line_item_id"
          }
        ],
        "responses": {
          "204": {
            "description": "Line item deleted."
          },
          "404": {
            "description": "Incorrect site or line item ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "422": {
            "description": "Only pending line items can be deleted.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": [
          {
            "lang": "Node.js",
            "source": "try {\n  await client.removeLineItem(lineItemId)\n  console.log('Removed line item: ', lineItemId)\n} catch (err) {\n  if (err instanceof recurly.errors.NotFoundError) {\n    // If the request was not found, you may want to alert the user or\n    // just return null\n    console.log('Resource Not Found')\n  } else {\n    // If we don't know what to do with the err, we should\n    // probably re-raise and let our web framework and logger handle it\n    console.log('Unknown Error: ', err)\n  }\n}\n"
          },
          {
            "lang": "Python",
            "source": "try:\n    client.remove_line_item(line_item_id)\n    print(\"Removed LineItem %s\" % line_item_id)\nexcept recurly.errors.NotFoundError:\n    # If the resource was not found, you may want to alert the user or\n    # just return nil\n    print(\"Resource Not Found\")\n"
          },
          {
            "lang": ".NET",
            "source": "try\n{\n    client.RemoveLineItem(lineItemId);\n    Console.WriteLine($\"Removed line item {lineItemId}\");\n}\ncatch (Recurly.Errors.Validation ex)\n{\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in ex.Error.Params\n    Console.WriteLine($\"Failed validation: {ex.Error.Message}\");\n}\ncatch (Recurly.Errors.ApiError ex)\n{\n    // Use ApiError to catch a generic error from the API\n    Console.WriteLine($\"Unexpected Recurly Error: {ex.Error.Message}\");\n}\n"
          },
          {
            "lang": "Ruby",
            "source": "begin\n  @client.remove_line_item(\n    line_item_id: line_item_id\n  )\n  puts \"Removed LineItem #{line_item_id}\"\nrescue Recurly::Errors::NotFoundError\n  # If the resource was not found, you may want to alert the user or\n  # just return nil\n  puts \"Resource Not Found\"\nend\n"
          },
          {
            "lang": "Java",
            "source": "try {\n    client.removeLineItem(lineItemId);\n    System.out.println(\"Removed line item \" + lineItemId);\n} catch (ValidationException e) {\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in e.getError().getParams()\n    System.out.println(\"Failed validation: \" + e.getError().getMessage());\n} catch (ApiException e) {\n    // Use ApiException to catch a generic error from the API\n    System.out.println(\"Unexpected Recurly Error: \" + e.getError().getMessage());\n}\n"
          },
          {
            "lang": "PHP",
            "source": "try {\n    $client->removeLineItem($line_item_id);\n    echo 'Removed LineItem: ' . $line_item_id . PHP_EOL;\n} catch (\\Recurly\\Errors\\Validation $e) {\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in err.params\n    var_dump($e);\n} catch (\\Recurly\\RecurlyError $e) {\n    // If we don't know what to do with the err, we should\n    // probably re-raise and let our web framework and logger handle it\n    var_dump($e);\n}\n"
          },
          {
            "lang": "Go",
            "source": "lineItem, err := client.RemoveLineItem(lineItemID)\nif e, ok := err.(*recurly.Error); ok {\n\tif e.Type == recurly.ErrorTypeNotFound {\n\t\tfmt.Printf(\"Resource not found: %v\", e)\n\t\treturn nil, err\n\t}\n\tfmt.Printf(\"Unexpected Recurly error: %v\", e)\n\treturn nil, err\n}\nfmt.Printf(\"Removed Line Item: %v\", lineItem)"
          }
        ]
      }
    },
    "/plans": {
      "get": {
        "tags": [
          "plan"
        ],
        "operationId": "list_plans",
        "summary": "List a site's plans",
        "description": "See the [Pagination Guide](/developers/guides/pagination.html) to learn how to use pagination in the API and Client Libraries.",
        "parameters": [
          {
            "$ref": "#/components/parameters/ids"
          },
          {
            "$ref": "#/components/parameters/limit"
          },
          {
            "$ref": "#/components/parameters/order"
          },
          {
            "$ref": "#/components/parameters/sort_dates"
          },
          {
            "$ref": "#/components/parameters/filter_begin_time"
          },
          {
            "$ref": "#/components/parameters/filter_end_time"
          },
          {
            "$ref": "#/components/parameters/filter_state"
          }
        ],
        "responses": {
          "200": {
            "description": "A list of plans.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PlanList"
                }
              }
            }
          },
          "400": {
            "description": "Invalid or unpermitted parameter.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": [
          {
            "lang": "Node.js",
            "source": "const plans = client.listPlans({ params: { limit: 200 } })\n\nfor await (const plan of plans.each()) {\n  console.log(plan.code)\n}\n"
          },
          {
            "lang": "Python",
            "source": "params = {\"limit\": 200}\nplans = client.list_plans(params=params).items()\nfor plan in plans:\n    print(plan.code)\n"
          },
          {
            "lang": ".NET",
            "source": "var optionalParams = new ListPlansParams()\n{\n    Limit = 200\n};\nvar plans = client.ListPlans(optionalParams);\nforeach(Plan plan in plans)\n{\n    Console.WriteLine(plan.Code);\n}\n"
          },
          {
            "lang": "Ruby",
            "source": "params = {\n  limit: 200\n}\nplans = @client.list_plans(params: params)\nplans.each do |plan|\n  puts \"Plan: #{plan.code}\"\nend\n"
          },
          {
            "lang": "Java",
            "source": "QueryParams params = new QueryParams();\nparams.setLimit(200); // Pull 200 records at a time\nfinal Pager<Plan> plans = client.listPlans(params);\n\nfor (Plan plan : plans) {\n    System.out.println(plan.getCode());\n}\n"
          },
          {
            "lang": "PHP",
            "source": "$options = [\n  'params' => [\n    'limit' => 200\n  ]\n];\n$plans = $client->listPlans($options);\n\nforeach($plans as $plan) {\n  echo 'Plan: ' . $plan->getCode() . PHP_EOL;\n}\n"
          },
          {
            "lang": "Go",
            "source": "listParams := &recurly.ListPlansParams{\n\tSort:  recurly.String(\"created_at\"),\n\tOrder: recurly.String(\"desc\"),\n\tLimit: recurly.Int(200),\n}\nplans, err := client.ListPlans(listParams)\nif err != nil {\n\tfmt.Println(\"Unexpected error: %v\", err)\n\treturn\n}\n\nfor plans.HasMore() {\n\terr := plans.Fetch()\n\tif e, ok := err.(*recurly.Error); ok {\n\t\tfmt.Printf(\"Failed to retrieve next page: %v\", e)\n\t\tbreak\n\t}\n\tfor i, plan := range plans.Data() {\n\t\tfmt.Printf(\"Plan %3d: %s, %s\\n\",\n\t\t\ti,\n\t\t\tplan.Id,\n\t\t\tplan.Code,\n\t\t)\n\t}\n}"
          }
        ]
      },
      "post": {
        "tags": [
          "plan"
        ],
        "operationId": "create_plan",
        "summary": "Create a plan",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PlanCreate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "A plan.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Plan"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "422": {
            "description": "A validation error such as 'Code has already been taken.'",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": [
          {
            "lang": "Node.js",
            "source": "try {\n  const planCreate = {\n    name: 'Monthly Coffee Subscription',\n    code: planCode,\n    currencies: [\n      {\n        currency: 'USD',\n        unitAmount: 10000\n      }\n    ]\n  }\n  const plan = await client.createPlan(planCreate)\n  console.log('Created Plan: ', plan.code)\n} catch (err) {\n  if (err instanceof recurly.errors.ValidationError) {\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in err.params\n    console.log('Failed validation', err.params)\n  } else {\n    // If we don't know what to do with the err, we should\n    // probably re-raise and let our web framework and logger handle it\n    console.log('Unknown Error: ', err)\n  }\n}\n"
          },
          {
            "lang": "Python",
            "source": "try:\n    plan_create = {\n        \"name\": \"Monthly Coffee Subscription\",\n        \"code\": plan_code,\n        \"currencies\": [{\"currency\": \"USD\", \"unit_amount\": 10000}],\n    }\n    plan = client.create_plan(plan_create)\n    print(\"Created Plan %s\" % plan)\nexcept recurly.errors.ValidationError as e:\n    # If the request was invalid, you may want to tell your user\n    # why. You can find the invalid params and reasons in e.error.params\n    print(\"ValidationError: %s\" % e.error.message)\n    print(e.error.params)\n"
          },
          {
            "lang": ".NET",
            "source": "try\n{\n    var planReq = new PlanCreate()\n    {\n        Name = \"Monthly Coffee Subscription\",\n        Code = planCode,\n        Currencies = new List<PlanPricing>() {\n            new PlanPricing() {\n                Currency = \"USD\",\n                UnitAmount = 10000\n            }\n        }\n    };\n    Plan plan = client.CreatePlan(planReq);\n    Console.WriteLine($\"Created plan {plan.Code}\");\n}\ncatch (Recurly.Errors.Validation ex)\n{\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in ex.Error.Params\n    Console.WriteLine($\"Failed validation: {ex.Error.Message}\");\n}\ncatch (Recurly.Errors.ApiError ex)\n{\n    // Use ApiError to catch a generic error from the API\n    Console.WriteLine($\"Unexpected Recurly Error: {ex.Error.Message}\");\n}\n"
          },
          {
            "lang": "Ruby",
            "source": "begin\n  plan_create = {\n    code: plan_code,\n    name: plan_name,\n    currencies: [\n      currency: \"USD\",\n      setup_fee: 1_000\n    ],\n    add_ons: [\n      {\n        name: 'Extra User',\n        code: 'extra_user',\n        currencies: [\n          { currency: 'USD', unit_amount: 10_000 }\n        ]\n      }\n    ]\n  }\n  plan = @client.create_plan(body: plan_create)\n  puts \"Created Plan #{plan}\"\nrescue Recurly::Errors::ValidationError => e\n  # If the request was invalid, you may want to tell your user\n  # why. You can find the invalid params and reasons in e.recurly_error.params\n  puts \"ValidationError: #{e.recurly_error.params}\"\nend\n"
          },
          {
            "lang": "Java",
            "source": "try {\n    PlanCreate planCreate = new PlanCreate();\n\n    planCreate.setName(\"Monthly Coffee Subscription\");\n    planCreate.setCode(planCode);\n\n    List<PlanPricing> currencies = new ArrayList<PlanPricing>();\n    PlanPricing planPrice = new PlanPricing();\n    planPrice.setCurrency(\"USD\");\n    planPrice.setUnitAmount(new BigDecimal(\"10000\"));\n    currencies.add(planPrice);\n\n    planCreate.setCurrencies(currencies);\n\n    Plan plan = client.createPlan(planCreate);\n    System.out.println(\"Created Plan \" + planCode);\n} catch (ValidationException e) {\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in e.getError().getParams()\n    System.out.println(\"Failed validation: \" + e.getError().getMessage());\n} catch (ApiException e) {\n    // Use ApiException to catch a generic error from the API\n    System.out.println(\"Unexpected Recurly Error: \" + e.getError().getMessage());\n}\n"
          },
          {
            "lang": "PHP",
            "source": "try {\n    $plan_create = [\n        \"name\" => \"Monthly Coffee Subscription\",\n        \"code\" => $plan_code,\n        \"currencies\" => [\n            [\n                \"currency\" => \"USD\",\n                \"unit_amount\" => 10000\n            ]\n        ]\n    ];\n\n    $plan = $client->createPlan($plan_create);\n\n    echo 'Created Plan:' . PHP_EOL;\n    var_dump($plan);\n} catch (\\Recurly\\Errors\\Validation $e) {\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in err.params\n    var_dump($e);\n} catch (\\Recurly\\RecurlyError $e) {\n    // If we don't know what to do with the err, we should\n    // probably re-raise and let our web framework and logger handle it\n    var_dump($e);\n}\n"
          },
          {
            "lang": "Go",
            "source": "planReq := &recurly.PlanCreate{\n\tCode: &planCode,\n\tName: recurly.String(\"Monthly Coffee Subscription\"),\n\tCurrencies: []recurly.PlanPricingCreate{\n\t\t{\n\t\t\tCurrency:   recurly.String(\"USD\"),\n\t\t\tUnitAmount: recurly.Float(10000),\n\t\t},\n\t},\n}\n\nplan, err := client.CreatePlan(planReq)\nif e, ok := err.(*recurly.Error); ok {\n\tif e.Type == recurly.ErrorTypeValidation {\n\t\tfmt.Printf(\"Failed validation: %v\", e)\n\t\treturn nil, err\n\t}\n\tfmt.Printf(\"Unexpected Recurly error: %v\", e)\n\treturn nil, err\n}\nfmt.Printf(\"Created Plan: %v\", plan.Id)"
          }
        ]
      }
    },
    "/plans/{plan_id}": {
      "get": {
        "tags": [
          "plan"
        ],
        "operationId": "get_plan",
        "summary": "Fetch a plan",
        "parameters": [
          {
            "$ref": "#/components/parameters/plan_id"
          }
        ],
        "responses": {
          "200": {
            "description": "A plan.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Plan"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site or plan ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": [
          {
            "lang": "Node.js",
            "source": "try {\n  const plan = await client.getPlan(planId)\n  console.log('Fetched plan: ', plan.code)\n} catch (err) {\n  if (err instanceof recurly.errors.NotFoundError) {\n    // If the request was not found, you may want to alert the user or\n    // just return null\n    console.log('Resource Not Found')\n  } else {\n    // If we don't know what to do with the err, we should\n    // probably re-raise and let our web framework and logger handle it\n    console.log('Unknown Error: ', err)\n  }\n}\n"
          },
          {
            "lang": "Python",
            "source": "try:\n    plan = client.get_plan(plan_id)\n    print(\"Got Plan %s\" % plan)\nexcept recurly.errors.NotFoundError:\n    # If the resource was not found, you may want to alert the user or\n    # just return nil\n    print(\"Resource Not Found\")\n"
          },
          {
            "lang": ".NET",
            "source": "try\n{\n    Plan plan = client.GetPlan(planId);\n    Console.WriteLine($\"Fetched plan {plan.Code}\");\n}\ncatch (Recurly.Errors.NotFound ex)\n{\n    // If the resource was not found\n    // we may want to alert the user or just return null\n    Console.WriteLine($\"Resource Not Found: {ex.Error.Message}\");\n}\ncatch (Recurly.Errors.ApiError ex)\n{\n    // Use ApiError to catch a generic error from the API\n    Console.WriteLine($\"Unexpected Recurly Error: {ex.Error.Message}\");\n}\n"
          },
          {
            "lang": "Ruby",
            "source": "begin\n  plan = @client.get_plan(plan_id: plan_id)\n  puts \"Got plan #{plan}\"\nrescue Recurly::Errors::NotFoundError\n  # If the resource was not found, you may want to alert the user or\n  # just return nil\n  puts \"Resource Not Found\"\nend\n"
          },
          {
            "lang": "Java",
            "source": "try {\n    final Plan plan = client.getPlan(planId);\n    System.out.println(\"Fetched plan \" + plan.getCode());\n} catch (NotFoundException e) {\n    // If the resource was not found\n    // we may want to alert the user or just return null\n    System.out.println(\"Resource Not Found: \" + e.getError().getMessage());\n} catch (ApiException e) {\n    // Use ApiException to catch a generic error from the API\n    System.out.println(\"Unexpected Recurly Error: \" + e.getError().getMessage());\n}\n"
          },
          {
            "lang": "PHP",
            "source": "try {\n    $plan = $client->getPlan($plan_id);\n\n    echo 'Got Plan:' . PHP_EOL;\n    var_dump($plan);\n} catch (\\Recurly\\Errors\\NotFound $e) {\n    // Could not find the resource, you may want to inform the user\n    // or just return a NULL\n    echo 'Could not find resource.' . PHP_EOL;\n    var_dump($e);\n} catch (\\Recurly\\RecurlyError $e) {\n    // Something bad happened... tell the user so that they can fix it?\n    echo 'Some unexpected Recurly error happened. Try again later.' . PHP_EOL;\n}\n"
          },
          {
            "lang": "Go",
            "source": "plan, err := client.GetPlan(planID)\nif e, ok := err.(*recurly.Error); ok {\n\tif e.Type == recurly.ErrorTypeNotFound {\n\t\tfmt.Printf(\"Resource not found: %v\", e)\n\t\treturn nil, err\n\t}\n\tfmt.Printf(\"Unexpected Recurly error: %v\", e)\n\treturn nil, err\n}\n\nfmt.Printf(\"Fetched Plan: %s\", plan.Id)"
          }
        ]
      },
      "put": {
        "tags": [
          "plan"
        ],
        "operationId": "update_plan",
        "summary": "Update a plan",
        "parameters": [
          {
            "$ref": "#/components/parameters/plan_id"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PlanUpdate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "A plan.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Plan"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "422": {
            "description": "A validation error such as 'Code has already been taken.'",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": [
          {
            "lang": "Node.js",
            "source": "try {\n  const planUpdate = {\n    name: 'New monthly coffee subscription'\n  }\n  const plan = await client.updatePlan(planId, planUpdate)\n  console.log('Updated plan: ', plan.code)\n} catch (err) {\n  if (err instanceof recurly.errors.ValidationError) {\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in err.params\n    console.log('Failed validation', err.params)\n  } else {\n    // If we don't know what to do with the err, we should\n    // probably re-raise and let our web framework and logger handle it\n    console.log('Unknown Error: ', err)\n  }\n}\n"
          },
          {
            "lang": "Python",
            "source": "try:\n    plan_update = {\n      \"name\": \"Monthly Kombucha Subscription\",\n    }\n    plan = client.update_plan(plan_id, plan_update)\n    print(\"Updated Plan %s\" % plan)\nexcept recurly.errors.NotFoundError:\n    # If the resource was not found, you may want to alert the user or\n    # just return nil\n    print(\"Resource Not Found\")\n"
          },
          {
            "lang": ".NET",
            "source": "try\n{\n    var planReq = new PlanUpdate() {\n        Name = \"New Monthly Coffee Subscription\"\n    };\n    Plan plan = client.UpdatePlan(planId, planReq);\n    Console.WriteLine($\"Updated plan {plan.Code}\");\n}\ncatch (Recurly.Errors.Validation ex)\n{\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in ex.Error.Params\n    Console.WriteLine($\"Failed validation: {ex.Error.Message}\");\n}\ncatch (Recurly.Errors.ApiError ex)\n{\n    // Use ApiError to catch a generic error from the API\n    Console.WriteLine($\"Unexpected Recurly Error: {ex.Error.Message}\");\n}\n"
          },
          {
            "lang": "Ruby",
            "source": "begin\n  plan_update = {\n    name: \"Monthly Kombucha Subscription\"\n  }\n  plan = @client.update_plan(plan_id: plan_id, body: plan_update)\n  puts \"Updated plan #{plan}\"\nrescue Recurly::Errors::NotFoundError\n  # If the resource was not found, you may want to alert the user or\n  # just return nil\n  puts \"Resource Not Found\"\nend\n"
          },
          {
            "lang": "Java",
            "source": "try {\n    final PlanUpdate planUpdate = new PlanUpdate();\n    planUpdate.setName(\"New Monthly Coffee Subscription\");\n\n    final Plan plan = client.updatePlan(planId, planUpdate);\n    System.out.println(\"Updated plan \" + plan.getCode());\n} catch (ValidationException e) {\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in e.getError().getParams()\n    System.out.println(\"Failed validation: \" + e.getError().getMessage());\n} catch (ApiException e) {\n    // Use ApiException to catch a generic error from the API\n    System.out.println(\"Unexpected Recurly Error: \" + e.getError().getMessage());\n}\n"
          },
          {
            "lang": "PHP",
            "source": "try {\n    $plan_update = [\n        \"name\" => \"Monthly Tea Subscription\"\n    ];\n    $plan = $client->updatePlan($plan_id, $plan_update);\n\n    echo 'Updated Plan:' . PHP_EOL;\n    var_dump($plan);\n} catch (\\Recurly\\Errors\\Validation $e) {\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in err.params\n    var_dump($e);\n} catch (\\Recurly\\RecurlyError $e) {\n    // If we don't know what to do with the err, we should\n    // probably re-raise and let our web framework and logger handle it\n    var_dump($e);\n}\n"
          },
          {
            "lang": "Go",
            "source": "updateReq := &recurly.PlanUpdate{\n\tName: recurly.String(\"Monthly Houseplant Subscription\"),\n}\nplan, err := client.UpdatePlan(planID, updateReq)\nif e, ok := err.(*recurly.Error); ok {\n\tif e.Type == recurly.ErrorTypeValidation {\n\t\tfmt.Printf(\"Failed validation: %v\", e)\n\t\treturn nil, err\n\t}\n\tfmt.Printf(\"Unexpected Recurly error: %v\", e)\n\treturn nil, err\n}\n\nfmt.Printf(\"Updated Plan: %s\", plan.Id)"
          }
        ]
      },
      "delete": {
        "tags": [
          "plan"
        ],
        "operationId": "remove_plan",
        "summary": "Remove a plan",
        "parameters": [
          {
            "$ref": "#/components/parameters/plan_id"
          }
        ],
        "responses": {
          "200": {
            "description": "Plan deleted",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Plan"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site or plan ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": [
          {
            "lang": "Node.js",
            "source": "try {\n  const plan = await client.removePlan(planId)\n  console.log('Removed plan: ', plan.code)\n} catch (err) {\n  if (err instanceof recurly.errors.NotFoundError) {\n    // If the request was not found, you may want to alert the user or\n    // just return null\n    console.log('Resource Not Found')\n  } else {\n    // If we don't know what to do with the err, we should\n    // probably re-raise and let our web framework and logger handle it\n    console.log('Unknown Error: ', err)\n  }\n}\n"
          },
          {
            "lang": "Python",
            "source": "try:\n    plan = client.remove_plan(plan_id)\n    print(\"Removed Plan %s\" % plan)\nexcept recurly.errors.NotFoundError:\n    # If the resource was not found, you may want to alert the user or\n    # just return nil\n    print(\"Resource Not Found\")\n"
          },
          {
            "lang": ".NET",
            "source": "try\n{\n    Plan plan = client.RemovePlan(planId);\n    Console.WriteLine($\"Removed plan {plan.Code}\");\n}\ncatch (Recurly.Errors.Validation ex)\n{\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in ex.Error.Params\n    Console.WriteLine($\"Failed validation: {ex.Error.Message}\");\n}\ncatch (Recurly.Errors.ApiError ex)\n{\n    // Use ApiError to catch a generic error from the API\n    Console.WriteLine($\"Unexpected Recurly Error: {ex.Error.Message}\");\n}\n"
          },
          {
            "lang": "Ruby",
            "source": "begin\n  plan = @client.remove_plan(plan_id: plan_id)\n  puts \"Removed plan #{plan}\"\nrescue Recurly::Errors::NotFoundError\n  # If the resource was not found, you may want to alert the user or\n  # just return nil\n  puts \"Resource Not Found\"\nend\n"
          },
          {
            "lang": "Java",
            "source": "try {\n    final Plan plan = client.removePlan(planId);\n    System.out.println(\"Removed plan \" + plan.getCode());\n} catch (ValidationException e) {\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in e.getError().getParams()\n    System.out.println(\"Failed validation: \" + e.getError().getMessage());\n} catch (ApiException e) {\n    // Use ApiException to catch a generic error from the API\n    System.out.println(\"Unexpected Recurly Error: \" + e.getError().getMessage());\n}\n"
          },
          {
            "lang": "PHP",
            "source": "try {\n    $plan = $client->removePlan($plan_id);\n    echo 'Removed Plan: ' . $plan_id . PHP_EOL;\n} catch (\\Recurly\\Errors\\Validation $e) {\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in err.params\n    var_dump($e);\n} catch (\\Recurly\\RecurlyError $e) {\n    // If we don't know what to do with the err, we should\n    // probably re-raise and let our web framework and logger handle it\n    var_dump($e);\n}\n"
          },
          {
            "lang": "Go",
            "source": "plan, err := client.RemovePlan(planID)\nif e, ok := err.(*recurly.Error); ok {\n\tif e.Type == recurly.ErrorTypeNotFound {\n\t\tfmt.Printf(\"Resource not found: %v\", e)\n\t\treturn nil, err\n\t}\n\tfmt.Printf(\"Unexpected Recurly error: %v\", e)\n\treturn nil, err\n}\n\nfmt.Printf(\"Removed Plan: %s\", plan.Id)"
          }
        ]
      }
    },
    "/plans/{plan_id}/add_ons": {
      "get": {
        "tags": [
          "add-on"
        ],
        "operationId": "list_plan_add_ons",
        "summary": "List a plan's add-ons",
        "description": "See the [Pagination Guide](/developers/guides/pagination.html) to learn how to use pagination in the API and Client Libraries.",
        "parameters": [
          {
            "$ref": "#/components/parameters/plan_id"
          },
          {
            "$ref": "#/components/parameters/ids"
          },
          {
            "$ref": "#/components/parameters/limit"
          },
          {
            "$ref": "#/components/parameters/order"
          },
          {
            "$ref": "#/components/parameters/sort_dates"
          },
          {
            "$ref": "#/components/parameters/filter_begin_time"
          },
          {
            "$ref": "#/components/parameters/filter_end_time"
          },
          {
            "$ref": "#/components/parameters/filter_state"
          }
        ],
        "responses": {
          "200": {
            "description": "A list of add-ons.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AddOnList"
                }
              }
            }
          },
          "400": {
            "description": "Invalid or unpermitted parameter.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site or plan ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": [
          {
            "lang": "Node.js",
            "source": "const addOns = client.listPlanAddOns(planId, { params: { limit: 200 } })\n\nfor await (const addOn of addOns.each()) {\n  console.log(addOn.code)\n}\n"
          },
          {
            "lang": "Python",
            "source": "params = {\"limit\": 200}\nadd_ons = client.list_plan_add_ons(plan_id, params=params).items()\nfor add_on in add_ons:\n    print(add_on.code)\n"
          },
          {
            "lang": ".NET",
            "source": "var addOns = client.ListPlanAddOns(planId);\nforeach(AddOn addOn in addOns)\n{\n    Console.WriteLine(addOn.Code);\n}\n"
          },
          {
            "lang": "Ruby",
            "source": "params = {\n  limit: 200\n}\nadd_ons = @client.list_plan_add_ons(\n  plan_id: plan_id,\n  params: params\n)\nadd_ons.each do |add_on|\n  puts \"AddOn: #{add_on.code}\"\nend\n"
          },
          {
            "lang": "Java",
            "source": "QueryParams params = new QueryParams();\nparams.setLimit(200); // Pull 200 records at a time\nfinal Pager<AddOn> addOns = client.listPlanAddOns(planId, params);\n\nfor (AddOn addOn : addOns) {\n    System.out.println(addOn.getCode());\n}\n"
          },
          {
            "lang": "PHP",
            "source": "$options = [\n  'params' => [\n    'limit' => 200\n  ]\n];\n$plan_add_ons = $client->listPlanAddOns($plan_id, $options);\n\nforeach($plan_add_ons as $add_on) {\n  echo 'Plan add-on: ' . $add_on->getCode() . PHP_EOL;\n}\n"
          },
          {
            "lang": "Go",
            "source": "listParams := &recurly.ListPlanAddOnsParams{\n\tSort:  recurly.String(\"created_at\"),\n\tOrder: recurly.String(\"desc\"),\n\tLimit: recurly.Int(200),\n}\naddOns, err := client.ListPlanAddOns(planID, listParams)\nif err != nil {\n\tfmt.Println(\"Unexpected error: %v\", err)\n\treturn\n}\n\nfor addOns.HasMore() {\n\terr := addOns.Fetch()\n\tif e, ok := err.(*recurly.Error); ok {\n\t\tfmt.Printf(\"Failed to retrieve next page: %v\", e)\n\t\tbreak\n\t}\n\tfor i, addOn := range addOns.Data() {\n\t\tfmt.Printf(\"Add-On %3d: %s, %s\\n\",\n\t\t\ti,\n\t\t\taddOn.Id,\n\t\t\taddOn.Code,\n\t\t)\n\t}\n}"
          }
        ]
      },
      "post": {
        "tags": [
          "add-on"
        ],
        "operationId": "create_plan_add_on",
        "summary": "Create an add-on",
        "parameters": [
          {
            "$ref": "#/components/parameters/plan_id"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AddOnCreate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "An add-on.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AddOn"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site ID or plan ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "422": {
            "description": "A validation error such as 'Code has already been taken.'",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": [
          {
            "lang": "Node.js",
            "source": "try {\n  const addOnCreate = {\n    code: 'coffee_grinder',\n    name: 'A quality grinder for your beans',\n    defaultQuantity: 1,\n    currencies: [\n      {\n        currency: 'USD',\n        unitAmount: 10000\n      }\n    ]\n  }\n\n  const addOn = await client.createPlanAddOn(planId, addOnCreate)\n  console.log('Created add-on: ', addOn.code)\n} catch (err) {\n  if (err instanceof recurly.errors.ValidationError) {\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in err.params\n    console.log('Failed validation', err.params)\n  } else {\n    // If we don't know what to do with the err, we should\n    // probably re-raise and let our web framework and logger handle it\n    console.log('Unknown Error: ', err)\n  }\n}\n"
          },
          {
            "lang": "Python",
            "source": "try:\n    add_on_create = {\n        \"code\": \"coffee_grinder\",\n        \"name\": \"A quality grinder for your beans\",\n        \"default_quantity\": 1,\n        \"currencies\": [{\"currency\": \"USD\", \"unit_amount\": 10000}],\n    }\n    add_on = client.create_plan_add_on(plan_id, add_on_create)\n    print(\"Created PlanAddOn %s\" % add_on)\nexcept recurly.errors.ValidationError as e:\n    # If the request was invalid, you may want to tell your user\n    # why. You can find the invalid params and reasons in e.error.params\n    print(\"ValidationError: %s\" % e.error.message)\n    print(e.error.params)\n"
          },
          {
            "lang": ".NET",
            "source": "try\n{\n    var addOnReq = new AddOnCreate() {\n        Code = \"coffee_grinder\",\n        Name = \"A quality grinder for your beans\",\n        DefaultQuantity = 1,\n        Currencies = new List<AddOnPricing>() {\n            new AddOnPricing() {\n                Currency = \"USD\",\n                UnitAmount = 10000\n            }\n        }\n    };\n    AddOn addOn = client.CreatePlanAddOn(planId, addOnReq);\n    Console.WriteLine($\"Created add-on {addOn.Code}\");\n}\ncatch (Recurly.Errors.Validation ex)\n{\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in ex.Error.Params\n    Console.WriteLine($\"Failed validation: {ex.Error.Message}\");\n}\ncatch (Recurly.Errors.ApiError ex)\n{\n    // Use ApiError to catch a generic error from the API\n    Console.WriteLine($\"Unexpected Recurly Error: {ex.Error.Message}\");\n}\n"
          },
          {
            "lang": "Ruby",
            "source": "begin\n  new_add_on = {\n    code: 'coffee_grinder',\n    name: 'A quality grinder for your beans',\n    default_quantity: 1,\n    currencies: [\n      {\n        currency: 'USD',\n        unit_amount: 10_000\n      }\n    ]\n  }\n  add_on = @client.create_plan_add_on(plan_id: plan_id, body: new_add_on)\n  puts \"Created plan add-on #{add_on}\"\nrescue Recurly::Errors::NotFoundError\n  # If the resource was not found, you may want to alert the user or\n  # just return nil\n  puts \"Resource Not Found\"\nend\n"
          },
          {
            "lang": "Java",
            "source": "try {\n    AddOnCreate addOnCreate = new AddOnCreate();\n\n    addOnCreate.setCode(\"coffee-grinder\");\n    addOnCreate.setName(\"A quality grinder for your beans\");\n    addOnCreate.setDefaultQuantity(1);\n\n    List<AddOnPricing> currencies = new ArrayList<AddOnPricing>();\n    AddOnPricing addOnPrice = new AddOnPricing();\n    addOnPrice.setCurrency(\"USD\");\n    addOnPrice.setUnitAmount(new BigDecimal(\"10000.0\"));\n    currencies.add(addOnPrice);\n\n    addOnCreate.setCurrencies(currencies);\n\n    AddOn addOn = client.createPlanAddOn(planId, addOnCreate);\n    System.out.println(\"Created add-on \" + addOn.getCode());\n} catch (ValidationException e) {\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in e.getError().getParams()\n    System.out.println(\"Failed validation: \" + e.getError().getMessage());\n} catch (ApiException e) {\n    // Use ApiException to catch a generic error from the API\n    System.out.println(\"Unexpected Recurly Error: \" + e.getError().getMessage());\n}\n"
          },
          {
            "lang": "PHP",
            "source": "try {\n    $add_on_create = [\n        \"code\" => $add_on_code,\n        \"name\" => \"Fresh beans shipped monthly\",\n        \"currencies\" => [\n            [\n                \"currency\" => \"USD\",\n                \"unit_amount\" => 10\n            ]\n        ]\n    ];\n\n    $add_on = $client->createPlanAddOn($plan_id, $add_on_create);\n\n    echo 'Created Plan:' . PHP_EOL;\n    var_dump($plan);\n} catch (\\Recurly\\Errors\\Validation $e) {\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in err.params\n    var_dump($e);\n} catch (\\Recurly\\RecurlyError $e) {\n    // If we don't know what to do with the err, we should\n    // probably re-raise and let our web framework and logger handle it\n    var_dump($e);\n}\n"
          },
          {
            "lang": "Go",
            "source": "addOnReq := &recurly.AddOnCreate{\n\tCode: &addOnCode,\n\tName: recurly.String(\"Fresh beans shipped monthly\"),\n\tCurrencies: []recurly.AddOnPricingCreate{\n\t\t{\n\t\t\tCurrency:   recurly.String(\"USD\"),\n\t\t\tUnitAmount: recurly.Float(10),\n\t\t},\n\t},\n}\n\nplanAddOn, err := client.CreatePlanAddOn(planID, addOnReq)\nif e, ok := err.(*recurly.Error); ok {\n\tif e.Type == recurly.ErrorTypeValidation {\n\t\tfmt.Printf(\"Failed validation: %v\", e)\n\t\treturn nil, err\n\t}\n\tfmt.Printf(\"Unexpected Recurly error: %v\", e)\n\treturn nil, err\n}\nfmt.Printf(\"Created Plan Add-On: %v\", planAddOn.Id)"
          }
        ]
      }
    },
    "/plans/{plan_id}/add_ons/{add_on_id}": {
      "get": {
        "tags": [
          "add-on"
        ],
        "operationId": "get_plan_add_on",
        "summary": "Fetch a plan's add-on",
        "parameters": [
          {
            "$ref": "#/components/parameters/plan_id"
          },
          {
            "$ref": "#/components/parameters/add_on_id"
          }
        ],
        "responses": {
          "200": {
            "description": "An add-on.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AddOn"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site, plan or add-on ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": [
          {
            "lang": "Node.js",
            "source": "try {\n  const addOn = await client.getPlanAddOn(planId, addOnId)\n  console.log('Fetched add-on: ', addOn.code)\n} catch (err) {\n  if (err instanceof recurly.errors.NotFoundError) {\n    // If the request was not found, you may want to alert the user or\n    // just return null\n    console.log('Resource Not Found')\n  } else {\n    // If we don't know what to do with the err, we should\n    // probably re-raise and let our web framework and logger handle it\n    console.log('Unknown Error: ', err)\n  }\n}\n"
          },
          {
            "lang": "Python",
            "source": "try:\n    add_on = client.get_plan_add_on(plan_id, add_on_id)\n    print(\"Got Plan Add-On %s\" % add_on)\nexcept recurly.errors.NotFoundError:\n    # If the resource was not found, you may want to alert the user or\n    # just return nil\n    print(\"Resource Not Found\")\n"
          },
          {
            "lang": ".NET",
            "source": "try\n{\n    AddOn addOn = client.GetPlanAddOn(planId, addOnId);\n    Console.WriteLine($\"Fetched add-on {addOn.Code}\");\n}\ncatch (Recurly.Errors.NotFound ex)\n{\n    // If the resource was not found\n    // we may want to alert the user or just return null\n    Console.WriteLine($\"Resource Not Found: {ex.Error.Message}\");\n}\ncatch (Recurly.Errors.ApiError ex)\n{\n    // Use ApiError to catch a generic error from the API\n    Console.WriteLine($\"Unexpected Recurly Error: {ex.Error.Message}\");\n}\n"
          },
          {
            "lang": "Ruby",
            "source": "begin\n  add_on = @client.get_plan_add_on(\n    plan_id: plan_id, add_on_id: add_on_id\n  )\n  puts \"Got plan add-on #{add_on}\"\nrescue Recurly::Errors::NotFoundError\n  # If the resource was not found, you may want to alert the user or\n  # just return nil\n  puts \"Resource Not Found\"\nend\n"
          },
          {
            "lang": "Java",
            "source": "try {\n    final AddOn addOn = client.getPlanAddOn(planId, addOnId);\n    System.out.println(\"Fetched add-on \" + addOn.getCode());\n} catch (NotFoundException e) {\n    // If the resource was not found\n    // we may want to alert the user or just return null\n    System.out.println(\"Resource Not Found: \" + e.getError().getMessage());\n} catch (ApiException e) {\n    // Use ApiException to catch a generic error from the API\n    System.out.println(\"Unexpected Recurly Error: \" + e.getError().getMessage());\n}\n"
          },
          {
            "lang": "PHP",
            "source": "try {\n    $add_on = $client->getPlanAddOn($plan_id, $add_on_id);\n\n    echo 'Got Plan Add-On:' . PHP_EOL;\n    var_dump($add_on);\n} catch (\\Recurly\\Errors\\NotFound $e) {\n    // Could not find the resource, you may want to inform the user\n    // or just return a NULL\n    echo 'Could not find resource.' . PHP_EOL;\n    var_dump($e);\n} catch (\\Recurly\\RecurlyError $e) {\n    // Something bad happened... tell the user so that they can fix it?\n    echo 'Some unexpected Recurly error happened. Try again later.' . PHP_EOL;\n}\n"
          },
          {
            "lang": "Go",
            "source": "planAddOn, err := client.GetPlanAddOn(planID, planAddOnID)\nif e, ok := err.(*recurly.Error); ok {\n\tif e.Type == recurly.ErrorTypeNotFound {\n\t\tfmt.Printf(\"Resource not found: %v\", e)\n\t\treturn nil, err\n\t}\n\tfmt.Printf(\"Unexpected Recurly error: %v\", e)\n\treturn nil, err\n}\nfmt.Printf(\"Fetched Plan Add-On: %v\", planAddOn)"
          }
        ]
      },
      "put": {
        "tags": [
          "add-on"
        ],
        "operationId": "update_plan_add_on",
        "summary": "Update an add-on",
        "parameters": [
          {
            "$ref": "#/components/parameters/plan_id"
          },
          {
            "$ref": "#/components/parameters/add_on_id"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AddOnUpdate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "An add-on.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AddOn"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site, plan, or add-on ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "422": {
            "description": "A validation error such as 'Code has already been taken.'",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": [
          {
            "lang": "Node.js",
            "source": "try {\n  const addOnUpdate = {\n    name: 'New AddOn Name',\n  }\n  const addOn = await client.updatePlanAddOn(planId, addOnId, addOnUpdate)\n  console.log('Updated add-on: ', addOn)\n} catch (err) {\n  if (err instanceof recurly.errors.ValidationError) {\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in err.params\n    console.log('Failed validation', err.params)\n  } else {\n    // If we don't know what to do with the err, we should\n    // probably re-raise and let our web framework and logger handle it\n    console.log('Unknown Error: ', err)\n  }\n}\n"
          },
          {
            "lang": "Python",
            "source": "try:\n    add_on_update = {\n      \"name\": \"New Add-On Name\",\n    }\n    add_on = client.update_plan_add_on(plan_id, add_on_id, add_on_update)\n    print(\"Updated Plan Add-On %s\" % add_on)\nexcept recurly.errors.NotFoundError:\n    # If the resource was not found, you may want to alert the user or\n    # just return nil\n    print(\"Resource Not Found\")\n"
          },
          {
            "lang": ".NET",
            "source": "try\n{\n    var addOnReq = new AddOnUpdate {\n      Name = \"New Add-On Name\"\n    };\n    AddOn addOn = client.UpdatePlanAddOn(planId, planAddOnId, addOnReq);\n    Console.WriteLine($\"Updated add-on: {addOn.Code}\");\n}\ncatch (Recurly.Errors.NotFound ex)\n{\n    // If the resource was not found\n    // we may want to alert the user or just return null\n    Console.WriteLine($\"Resource Not Found: {ex.Error.Message}\");\n}\ncatch (Recurly.Errors.ApiError ex)\n{\n    // Use ApiError to catch a generic error from the API\n    Console.WriteLine($\"Unexpected Recurly Error: {ex.Error.Message}\");\n}\n"
          },
          {
            "lang": "Ruby",
            "source": "begin\n  add_on_update = {\n    name: \"A quality grinder for your finest beans\"\n  }\n  add_on = @client.update_plan_add_on(\n    plan_id: plan_id, \n    add_on_id: add_on_id, \n    body: add_on_update\n  )\n  puts \"Updated add-on #{add_on}\"\nrescue Recurly::Errors::NotFoundError\n  # If the resource was not found, you may want to alert the user or\n  # just return nil\n  puts \"Resource Not Found\"\nend\n"
          },
          {
            "lang": "Java",
            "source": "try {\n    final AddOnUpdate addOnUpdate = new AddOnUpdate();\n    addOnUpdate.setName(\"New Add-On Name\");\n\n    final AddOn addOn = client.updatePlanAddOn(planId, addOnId, addOnUpdate);\n    System.out.println(\"Updated add-on \" + addOn.getCode());\n    System.out.println(addOn.getName());\n} catch (NotFoundException e) {\n    // If the resource was not found\n    // we may want to alert the user or just return null\n    System.out.println(\"Resource Not Found: \" + e.getError().getMessage());\n} catch (ApiException e) {\n    // Use ApiException to catch a generic error from the API\n    System.out.println(\"Unexpected Recurly Error: \" + e.getError().getMessage());\n}\n"
          },
          {
            "lang": "PHP",
            "source": "try {\n    $add_on_update = [\n        \"name\" => \"New AddOn Name\",\n    ];\n    $add_on = $client->updatePlanAddOn($plan_id, $add_on_id, $add_on_update);\n\n    echo ' Updated Plan AddOn:' . PHP_EOL;\n    var_dump($add_on);\n} catch (\\Recurly\\Errors\\Validation $e) {\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in err.params\n    var_dump($e);\n} catch (\\Recurly\\RecurlyError $e) {\n    // If we don't know what to do with the err, we should\n    // probably re-raise and let our web framework and logger handle it\n    var_dump($e);\n}\n"
          },
          {
            "lang": "Go",
            "source": "updateReq := &recurly.AddOnUpdate{\n\tName: recurly.String(\"New Add-On Name\"),\n}\nplanAddOn, err := client.UpdatePlanAddOn(planID, planAddOnID, updateReq)\nif e, ok := err.(*recurly.Error); ok {\n\tif e.Type == recurly.ErrorTypeNotFound {\n\t\tfmt.Printf(\"Resource not found: %v\", e)\n\t\treturn nil, err\n\t}\n\tfmt.Printf(\"Unexpected Recurly error: %v\", e)\n\treturn nil, err\n}\nfmt.Printf(\"Updated Plan Add-On: %v\", planAddOn)"
          }
        ]
      },
      "delete": {
        "tags": [
          "add-on"
        ],
        "operationId": "remove_plan_add_on",
        "summary": "Remove an add-on",
        "parameters": [
          {
            "$ref": "#/components/parameters/plan_id"
          },
          {
            "$ref": "#/components/parameters/add_on_id"
          }
        ],
        "responses": {
          "200": {
            "description": "Add-on deleted",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AddOn"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site, plan, or add-on ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": [
          {
            "lang": "Node.js",
            "source": "try {\n  const addOn = await client.removePlanAddOn(planId, addOnId)\n  console.log('Removed plan add-on: ', addOn)\n} catch (err) {\n  if (err instanceof recurly.errors.NotFoundError) {\n    // If the request was not found, you may want to alert the user or\n    // just return null\n    console.log('Resource Not Found')\n  } else {\n    // If we don't know what to do with the err, we should\n    // probably re-raise and let our web framework and logger handle it\n    console.log('Unknown Error: ', err)\n  }\n}\n"
          },
          {
            "lang": "Python",
            "source": "try:\n    add_on = client.remove_plan_add_on(plan_id, add_on_id)\n    print(\"Removed Plan Add-On %s\" % add_on_id)\nexcept recurly.errors.NotFoundError:\n    # If the resource was not found, you may want to alert the user or\n    # just return nil\n    print(\"Resource Not Found\")\n"
          },
          {
            "lang": ".NET",
            "source": "try\n{\n    AddOn addOn = client.RemovePlanAddOn(planId, planAddOnId);\n    Console.WriteLine($\"Removed Plan Add-On: {addOn.Code}\");\n}\ncatch (Recurly.Errors.NotFound ex)\n{\n    // If the resource was not found\n    // we may want to alert the user or just return null\n    Console.WriteLine($\"Resource Not Found: {ex.Error.Message}\");\n}\ncatch (Recurly.Errors.ApiError ex)\n{\n    // Use ApiError to catch a generic error from the API\n    Console.WriteLine($\"Unexpected Recurly Error: {ex.Error.Message}\");\n}\n"
          },
          {
            "lang": "Ruby",
            "source": "begin\n  add_on = @client.remove_plan_add_on(\n    plan_id: plan_id, \n    add_on_id: add_on_id\n  )\n  puts \"Removed add-on #{add_on}\"\nrescue Recurly::Errors::NotFoundError\n  # If the resource was not found, you may want to alert the user or\n  # just return nil\n  puts \"Resource Not Found\"\nend\n"
          },
          {
            "lang": "Java",
            "source": "try {\n  final AddOn addOn = client.removePlanAddOn(planId, addOnId);\n  System.out.println(\"Removed add-on \" + addOn.getCode());\n} catch (ValidationException e) {\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in e.getError().getParams()\n    System.out.println(\"Failed validation: \" + e.getError().getMessage());\n} catch (ApiException e) {\n    // Use ApiException to catch a generic error from the API\n    System.out.println(\"Unexpected Recurly Error: \" + e.getError().getMessage());\n}"
          },
          {
            "lang": "PHP",
            "source": "try {\n    $add_on = $client->removePlanAddOn($plan_id, $add_on_id);\n\n    echo 'Removed Plan AddOn:' . PHP_EOL;\n    var_dump($add_on);\n} catch (\\Recurly\\Errors\\Validation $e) {\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in err.params\n    var_dump($e);\n} catch (\\Recurly\\RecurlyError $e) {\n    // If we don't know what to do with the err, we should\n    // probably re-raise and let our web framework and logger handle it\n    var_dump($e);\n}\n"
          },
          {
            "lang": "Go",
            "source": "planAddOn, err := client.RemovePlanAddOn(planID, planAddOnID)\nif e, ok := err.(*recurly.Error); ok {\n\tif e.Type == recurly.ErrorTypeNotFound {\n\t\tfmt.Printf(\"Resource not found: %v\", e)\n\t\treturn nil, err\n\t}\n\tfmt.Printf(\"Unexpected Recurly error: %v\", e)\n\treturn nil, err\n}\nfmt.Printf(\"Removed Plan Add-On: %v\", planAddOn)"
          }
        ]
      }
    },
    "/add_ons": {
      "get": {
        "tags": [
          "add-on"
        ],
        "operationId": "list_add_ons",
        "summary": "List a site's add-ons",
        "description": "See the [Pagination Guide](/developers/guides/pagination.html) to learn how to use pagination in the API and Client Libraries.",
        "parameters": [
          {
            "$ref": "#/components/parameters/ids"
          },
          {
            "$ref": "#/components/parameters/limit"
          },
          {
            "$ref": "#/components/parameters/order"
          },
          {
            "$ref": "#/components/parameters/sort_dates"
          },
          {
            "$ref": "#/components/parameters/filter_begin_time"
          },
          {
            "$ref": "#/components/parameters/filter_end_time"
          },
          {
            "$ref": "#/components/parameters/filter_state"
          }
        ],
        "responses": {
          "200": {
            "description": "A list of add-ons.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AddOnList"
                }
              }
            }
          },
          "400": {
            "description": "Invalid or unpermitted parameter.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site or add-on ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": [
          {
            "lang": "Node.js",
            "source": "const addOns = client.listAddOns({ params: { limit: 200 } })\n\nfor await (const addOn of addOns.each()) {\n  console.log(addOn.code)\n}\n"
          },
          {
            "lang": "Python",
            "source": "params = {\"limit\": 200}\nadd_ons = client.list_add_ons(params=params).items()\nfor add_on in add_ons:\n    print(\"Add-On %s\" % add_on.code)\n"
          },
          {
            "lang": ".NET",
            "source": "var addOns = client.ListAddOns();\nforeach(AddOn addOn in addOns)\n{\n    Console.WriteLine(addOn.Code);\n}\n"
          },
          {
            "lang": "Ruby",
            "source": "params = {\n  limit: 200\n}\nadd_ons = @client.list_add_ons(\n  params: params\n)\nadd_ons.each do |add_on|\n  puts \"AddOn: #{add_on.code}\"\nend\n"
          },
          {
            "lang": "Java",
            "source": "QueryParams params = new QueryParams();\nparams.setLimit(200); // Pull 200 records at a time\nfinal Pager<AddOn> addOns = client.listAddOns(params);\n\nfor (AddOn addOn : addOns) {\n    System.out.println(addOn.getCode());\n}\n"
          },
          {
            "lang": "PHP",
            "source": "$options = [\n  'params' => [\n    'limit' => 200\n  ]\n];\n$add_ons = $client->listAddOns($options);\n\nforeach($add_ons as $addon) {\n  echo 'Add-on: ' . $addon->getCode() . PHP_EOL;\n}\n"
          },
          {
            "lang": "Go",
            "source": "listParams := &recurly.ListAddOnsParams{\n\tSort:  recurly.String(\"created_at\"),\n\tOrder: recurly.String(\"desc\"),\n\tLimit: recurly.Int(200),\n}\naddOns, err := client.ListAddOns(listParams)\nif err != nil {\n\tfmt.Println(\"Unexpected error: %v\", err)\n\treturn\n}\n\nfor addOns.HasMore() {\n\terr := addOns.Fetch()\n\tif e, ok := err.(*recurly.Error); ok {\n\t\tfmt.Printf(\"Failed to retrieve next page: %v\", e)\n\t\tbreak\n\t}\n\tfor i, addOn := range addOns.Data() {\n\t\tfmt.Printf(\"Add On %3d: %s, %s\\n\",\n\t\t\ti,\n\t\t\taddOn.Id,\n\t\t\taddOn.Code,\n\t\t)\n\t}\n}"
          }
        ]
      }
    },
    "/add_ons/{add_on_id}": {
      "get": {
        "tags": [
          "add-on"
        ],
        "operationId": "get_add_on",
        "summary": "Fetch an add-on",
        "parameters": [
          {
            "$ref": "#/components/parameters/add_on_id"
          }
        ],
        "responses": {
          "200": {
            "description": "An add-on.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AddOn"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site or add-on ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": [
          {
            "lang": "Node.js",
            "source": "try {\n  const addOn = await client.getAddOn(addOnId)\n  console.log('Fetched add-on: ', addOn)\n} catch (err) {\n  if (err instanceof recurly.errors.NotFoundError) {\n    // If the request was not found, you may want to alert the user or\n    // just return null\n    console.log('Resource Not Found')\n  } else {\n    // If we don't know what to do with the err, we should\n    // probably re-raise and let our web framework and logger handle it\n    console.log('Unknown Error: ', err)\n  }\n}\n"
          },
          {
            "lang": "Python",
            "source": "try:\n    add_on = client.get_add_on(add_on_id)\n    print(\"Got Add-On %s\" % add_on)\nexcept recurly.errors.NotFoundError:\n    # If the resource was not found, you may want to alert the user or\n    # just return nil\n    print(\"Resource Not Found\")\n"
          },
          {
            "lang": ".NET",
            "source": "try\n{\n    AddOn addOn = client.GetAddOn(addOnId);\n    Console.WriteLine($\"Fetched add-on: {addOn.Code}\");\n}\ncatch (Recurly.Errors.NotFound ex)\n{\n    // If the resource was not found\n    // we may want to alert the user or just return null\n    Console.WriteLine($\"Resource Not Found: {ex.Error.Message}\");\n}\ncatch (Recurly.Errors.ApiError ex)\n{\n    // Use ApiError to catch a generic error from the API\n    Console.WriteLine($\"Unexpected Recurly Error: {ex.Error.Message}\");\n}\n"
          },
          {
            "lang": "Ruby",
            "source": "begin\n  add_on = @client.get_add_on(add_on_id: add_on_id)\n  puts \"Got add-on #{add_on}\"\nrescue Recurly::Errors::NotFoundError\n  # If the resource was not found, you may want to alert the user or\n  # just return nil\n  puts \"Resource Not Found\"\nend\n"
          },
          {
            "lang": "Java",
            "source": "try {\n    final AddOn addOn = client.getAddOn(addOnId);\n    System.out.println(\"Fetched add-on \" + addOn.getCode());\n} catch (NotFoundException e) {\n    // If the resource was not found\n    // we may want to alert the user or just return null\n    System.out.println(\"Resource Not Found: \" + e.getError().getMessage());\n} catch (ApiException e) {\n    // Use ApiException to catch a generic error from the API\n    System.out.println(\"Unexpected Recurly Error: \" + e.getError().getMessage());\n}\n"
          },
          {
            "lang": "PHP",
            "source": "try {\n    $add_on = $client->getAddOn($add_on_id);\n\n    echo 'Got Plan Add-On:' . PHP_EOL;\n    var_dump($add_on);\n} catch (\\Recurly\\Errors\\NotFound $e) {\n    // Could not find the resource, you may want to inform the user\n    // or just return a NULL\n    echo 'Could not find resource.' . PHP_EOL;\n    var_dump($e);\n} catch (\\Recurly\\RecurlyError $e) {\n    // Something bad happened... tell the user so that they can fix it?\n    echo 'Some unexpected Recurly error happened. Try again later.' . PHP_EOL;\n}\n"
          },
          {
            "lang": "Go",
            "source": "addOn, err := client.GetAddOn(planAddOnID)\nif e, ok := err.(*recurly.Error); ok {\n\tif e.Type == recurly.ErrorTypeNotFound {\n\t\tfmt.Printf(\"Resource not found: %v\", e)\n\t\treturn nil, err\n\t}\n\tfmt.Printf(\"Unexpected Recurly error: %v\", e)\n\treturn nil, err\n}\n\nfmt.Printf(\"Fetched Add-On: %s\", addOn.Id)"
          }
        ]
      }
    },
    "/shipping_methods": {
      "get": {
        "tags": [
          "shipping_method"
        ],
        "operationId": "list_shipping_methods",
        "summary": "List a site's shipping methods",
        "description": "See the [Pagination Guide](/developers/guides/pagination.html) to learn how to use pagination in the API and Client Libraries.",
        "parameters": [
          {
            "$ref": "#/components/parameters/ids"
          },
          {
            "$ref": "#/components/parameters/limit"
          },
          {
            "$ref": "#/components/parameters/order"
          },
          {
            "$ref": "#/components/parameters/sort_dates"
          },
          {
            "$ref": "#/components/parameters/filter_begin_time"
          },
          {
            "$ref": "#/components/parameters/filter_end_time"
          }
        ],
        "responses": {
          "200": {
            "description": "A list of the site's shipping methods.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ShippingMethodList"
                }
              }
            }
          },
          "400": {
            "description": "Invalid or unpermitted parameter.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": [
          {
            "lang": "Node.js",
            "source": "const methods = client.listShippingMethods({ params: { limit: 200 } })\n\nfor await (const method of methods.each()) {\n  console.log(method.code)\n}\n"
          },
          {
            "lang": "Python",
            "source": "params = {\"limit\": 200}\nshipping_methods = client.list_shipping_methods(params=params).items()\nfor shipping_method in shipping_methods:\n    print(\"Shipping Method %s\" % shipping_method.code)\n"
          },
          {
            "lang": ".NET",
            "source": "var shippingMethods = client.ListShippingMethods();\nforeach(ShippingMethod shippingMethod in shippingMethods)\n{\n    Console.WriteLine(shippingMethod.Code);\n}\n"
          },
          {
            "lang": "Ruby",
            "source": "params = {\n  limit: 200\n}\nshipping_methods = @client.list_shipping_methods(\n  params: params\n)\nshipping_methods.each do |shipping_method|\n  puts \"Shipping Method: #{shipping_method.code}\"\nend\n"
          },
          {
            "lang": "Java",
            "source": "QueryParams params = new QueryParams();\nparams.setLimit(200); // Pull 200 records at a time\nfinal Pager<ShippingMethod> shippingMethods = client.listShippingMethods(params);\n\nfor (ShippingMethod shippingMethod : shippingMethods) {\n    System.out.println(shippingMethod.getCode());\n}\n"
          },
          {
            "lang": "PHP",
            "source": "$options = [\n  'params' => [\n    'limit' => 200\n  ]\n];\n$shipping_methods = $client->listShippingMethods($options);\n\nforeach($shipping_methods as $shipping_method) {\n  echo 'Shipping Method: ' . $shipping_method->getCode() . PHP_EOL;\n}\n"
          },
          {
            "lang": "Go",
            "source": "listParams := &recurly.ListShippingMethodsParams{\n\tSort:  recurly.String(\"created_at\"),\n\tOrder: recurly.String(\"desc\"),\n\tLimit: recurly.Int(200),\n}\nshippingMethods, err := client.ListShippingMethods(listParams)\nif err != nil {\n\tfmt.Println(\"Unexpected error: %v\", err)\n\treturn\n}\n\nfor shippingMethods.HasMore() {\n\terr := shippingMethods.Fetch()\n\tif e, ok := err.(*recurly.Error); ok {\n\t\tfmt.Printf(\"Failed to retrieve next page: %v\", e)\n\t\tbreak\n\t}\n\tfor i, method := range shippingMethods.Data() {\n\t\tfmt.Printf(\"Shipping Method %3d: %s, %s\\n\",\n\t\t\ti,\n\t\t\tmethod.Id,\n\t\t\tmethod.Code,\n\t\t)\n\t}\n}"
          }
        ]
      },
      "post": {
        "tags": [
          "shipping_method"
        ],
        "operationId": "create_shipping_method",
        "summary": "Create a new shipping method",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ShippingMethodCreate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "A new shipping method.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ShippingMethod"
                }
              }
            }
          },
          "400": {
            "description": "Bad request, perhaps invalid JSON?",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "422": {
            "description": "Invalid request parameters.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": []
      }
    },
    "/shipping_methods/{shipping_method_id}": {
      "get": {
        "tags": [
          "shipping_method"
        ],
        "operationId": "get_shipping_method",
        "summary": "Fetch a shipping method",
        "parameters": [
          {
            "$ref": "#/components/parameters/shipping_method_id"
          }
        ],
        "responses": {
          "200": {
            "description": "A shipping method.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ShippingMethod"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site or shipping method ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": []
      },
      "put": {
        "tags": [
          "shipping_method"
        ],
        "operationId": "update_shipping_method",
        "summary": "Update an active Shipping Method",
        "parameters": [
          {
            "$ref": "#/components/parameters/shipping_method_id"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ShippingMethodUpdate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "The updated shipping method.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ShippingMethod"
                }
              }
            }
          },
          "400": {
            "description": "Bad request, perhaps invalid JSON?",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site or shipping method ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "422": {
            "description": "Invalid request parameters",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": []
      },
      "delete": {
        "tags": [
          "shipping_method"
        ],
        "operationId": "deactivate_shipping_method",
        "summary": "Deactivate a shipping method",
        "parameters": [
          {
            "$ref": "#/components/parameters/shipping_method_id"
          }
        ],
        "description": "Deactivating a shipping method makes it unavailable for new subscriptions or purchases. It will not affect existing subscriptions.",
        "responses": {
          "200": {
            "description": "A shipping method.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ShippingMethod"
                }
              }
            }
          },
          "422": {
            "description": "Shipping method may already be inactive.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": []
      }
    },
    "/subscriptions": {
      "get": {
        "tags": [
          "subscription"
        ],
        "operationId": "list_subscriptions",
        "summary": "List a site's subscriptions",
        "description": "See the [Pagination Guide](/developers/guides/pagination.html) to learn how to use pagination in the API and Client Libraries.",
        "parameters": [
          {
            "$ref": "#/components/parameters/ids"
          },
          {
            "$ref": "#/components/parameters/limit"
          },
          {
            "$ref": "#/components/parameters/order"
          },
          {
            "$ref": "#/components/parameters/sort_dates"
          },
          {
            "$ref": "#/components/parameters/filter_begin_time"
          },
          {
            "$ref": "#/components/parameters/filter_end_time"
          },
          {
            "$ref": "#/components/parameters/filter_subscription_state"
          }
        ],
        "responses": {
          "200": {
            "description": "A list of the site's subscriptions.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SubscriptionList"
                }
              }
            }
          },
          "400": {
            "description": "Invalid or unpermitted parameter.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": [
          {
            "lang": "Node.js",
            "source": "const subscriptions = client.listSubscriptions({ params: { limit: 200 } })\n\nfor await (const subscription of subscriptions.each()) {\n  console.log(subscription.uuid)\n}\n"
          },
          {
            "lang": "Python",
            "source": "params = {\"limit\": 200}\nsubscriptions = client.list_subscriptions(params=params).items()\nfor subscription in subscriptions:\n    print(subscription.uuid)\n"
          },
          {
            "lang": ".NET",
            "source": "var optionalParams = new ListSubscriptionsParams()\n{\n    Limit = 200\n};\nvar subscriptions = client.ListSubscriptions(optionalParams);\nforeach(Subscription subscription in subscriptions)\n{\n    Console.WriteLine(subscription.Uuid);\n}\n"
          },
          {
            "lang": "Ruby",
            "source": "params = {\n  limit: 200\n}\nsubscriptions = @client.list_subscriptions(params: params)\nsubscriptions.each do |subscription|\n  puts \"Subscription: #{subscription.uuid}\"\nend\n"
          },
          {
            "lang": "Java",
            "source": "QueryParams params = new QueryParams();\nparams.setLimit(200); // Pull 200 records at a time\nfinal Pager<Subscription> subscriptions = client.listSubscriptions(params);\n\nfor (Subscription subscription : subscriptions) {\n    System.out.println(subscription.getUuid());\n}\n"
          },
          {
            "lang": "PHP",
            "source": "$options = [\n  'params' => [\n    'limit' => 200\n  ]\n];\n$subscriptions = $client->listSubscriptions($options);\n\nforeach($subscriptions as $sub) {\n  echo 'Subscription: ' . $sub->getUuid() . PHP_EOL;\n}\n"
          },
          {
            "lang": "Go",
            "source": "listParams := &recurly.ListSubscriptionsParams{\n\tSort:  recurly.String(\"created_at\"),\n\tOrder: recurly.String(\"desc\"),\n\tLimit: recurly.Int(200),\n}\nsubscriptions, err := client.ListSubscriptions(listParams)\nif err != nil {\n\tfmt.Println(\"Unexpected error: %v\", err)\n\treturn\n}\n\nfor subscriptions.HasMore() {\n\terr := subscriptions.Fetch()\n\tif e, ok := err.(*recurly.Error); ok {\n\t\tfmt.Printf(\"Failed to retrieve next page: %v\", e)\n\t\tbreak\n\t}\n\tfor i, subscription := range subscriptions.Data() {\n\t\tfmt.Printf(\"Subscription %3d: %s\\n\",\n\t\t\ti,\n\t\t\tsubscription.Id,\n\t\t)\n\t}\n}"
          }
        ]
      },
      "post": {
        "tags": [
          "subscription"
        ],
        "operationId": "create_subscription",
        "summary": "Create a new subscription",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SubscriptionCreate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "A subscription.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Subscription"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "422": {
            "description": "A validation error such as 'You already have a subscription to this plan.' error running the verification transaction.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorMayHaveTransaction"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": [
          {
            "lang": "Node.js",
            "source": "try {\n  let subscriptionReq = {\n    planCode: planCode,\n    currency: `USD`,\n    account: {\n      code: accountCode\n    }\n  }\n  let sub = await client.createSubscription(subscriptionReq)\n  console.log('Created subscription: ', sub.uuid)\n} catch (err) {\n  if (err instanceof recurly.errors.ValidationError) {\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in err.params\n    console.log('Failed validation', err.params)\n  } else {\n    // If we don't know what to do with the err, we should\n    // probably re-raise and let our web framework and logger handle it\n    console.log('Unknown Error: ', err)\n  }\n}\n"
          },
          {
            "lang": "Python",
            "source": "try:\n    sub_create = {\n        \"plan_code\": plan_code,\n        \"currency\": \"USD\",\n        \"account\": {\"code\": account_code},\n    }\n    sub = client.create_subscription(sub_create)\n    print(\"Created Subscription %s\" % sub)\nexcept recurly.errors.ValidationError as e:\n    # If the request was invalid, you may want to tell your user\n    # why. You can find the invalid params and reasons in e.error.params\n    print(\"ValidationError: %s\" % e.error.message)\n    print(e.error.params)\n"
          },
          {
            "lang": ".NET",
            "source": "try\n{\n    var subReq = new SubscriptionCreate()\n    {\n        Currency = \"USD\",\n        Account = new AccountCreate()\n        {\n            Code = accountCode\n        },\n        PlanCode = planCode,\n    };\n    Subscription subscription = client.CreateSubscription(subReq);\n    Console.WriteLine($\"Created Subscription with Id: {subscription.Uuid}\");\n}\ncatch (Recurly.Errors.Validation ex)\n{\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in ex.Error.Params\n    Console.WriteLine($\"Failed validation: {ex.Error.Message}\");\n}\ncatch (Recurly.Errors.ApiError ex)\n{\n    // Use ApiError to catch a generic error from the API\n    Console.WriteLine($\"Unexpected Recurly Error: {ex.Error.Message}\");\n}\n"
          },
          {
            "lang": "Ruby",
            "source": "begin\n  subscription_create = {\n    plan_code: plan_code,\n    currency: \"USD\",\n    # This can be an existing account or a new account\n    account: {\n      code: account_code,\n    }\n  }\n  subscription = @client.create_subscription(\n    body: subscription_create\n  )\n  puts \"Created Subscription #{subscription}\"\nrescue Recurly::Errors::ValidationError => e\n  # If the request was invalid, you may want to tell your user\n  # why. You can find the invalid params and reasons in e.recurly_error.params\n  puts \"ValidationError: #{e.recurly_error.params}\"\nend\n"
          },
          {
            "lang": "Java",
            "source": "try {\n    SubscriptionCreate subscriptionCreate = new SubscriptionCreate();\n    AccountCreate accountCreate = new AccountCreate();\n\n    accountCreate.setCode(accountCode);\n    subscriptionCreate.setCurrency(\"USD\");\n    subscriptionCreate.setAccount(accountCreate);\n    subscriptionCreate.setPlanCode(planCode);\n\n    Subscription subscription = client.createSubscription(subscriptionCreate);\n    System.out.println(\"Created Subscription with Id: \" + subscription.getUuid());\n} catch (ValidationException e) {\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in e.getError().getParams()\n    System.out.println(\"Failed validation: \" + e.getError().getMessage());\n} catch (ApiException e) {\n    // Use ApiException to catch a generic error from the API\n    System.out.println(\"Unexpected Recurly Error: \" + e.getError().getMessage());\n}\n"
          },
          {
            "lang": "PHP",
            "source": "try {\n    $sub_create = [\n        \"plan_code\" => $plan_code,\n        \"currency\" => \"USD\",\n        \"account\" => [\n            \"code\" => $account_code\n        ],\n    ];\n\n    $subscription = $client->createSubscription($sub_create);\n\n    echo 'Created Subscription:' . PHP_EOL;\n    var_dump($subscription);\n} catch (\\Recurly\\Errors\\Validation $e) {\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in err.params\n    var_dump($e);\n} catch (\\Recurly\\RecurlyError $e) {\n    // If we don't know what to do with the err, we should\n    // probably re-raise and let our web framework and logger handle it\n    var_dump($e);\n}\n"
          },
          {
            "lang": "Go",
            "source": "subReq := &recurly.SubscriptionCreate{\n\tPlanCode: recurly.String(planCode),\n\tAccount: &recurly.AccountCreate{\n\t\tCode: recurly.String(accountCode),\n\t},\n\tCurrency: recurly.String(\"USD\"),\n}\n\nsubscription, err := client.CreateSubscription(subReq)\nif e, ok := err.(*recurly.Error); ok {\n\tif e.Type == recurly.ErrorTypeValidation {\n\t\tfmt.Printf(\"Failed validation: %v\", e)\n\t\treturn nil, err\n\t}\n\tfmt.Printf(\"Unexpected Recurly error: %v\", e)\n\treturn nil, err\n}\nfmt.Printf(\"Created Subscription: %s\", subscription.Id)"
          }
        ]
      }
    },
    "/subscriptions/{subscription_id}": {
      "get": {
        "tags": [
          "subscription"
        ],
        "operationId": "get_subscription",
        "summary": "Fetch a subscription",
        "parameters": [
          {
            "$ref": "#/components/parameters/subscription_id"
          }
        ],
        "responses": {
          "200": {
            "description": "A subscription.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Subscription"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site or subscription ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": [
          {
            "lang": "Node.js",
            "source": "try {\n  const subscription = await client.getSubscription(subscriptionId)\n  console.log('Fetched subscription: ', subscription.uuid)\n} catch (err) {\n  if (err instanceof recurly.errors.NotFoundError) {\n    // If the request was not found, you may want to alert the user or\n    // just return null\n    console.log('Resource Not Found')\n  } else {\n    // If we don't know what to do with the err, we should\n    // probably re-raise and let our web framework and logger handle it\n    console.log('Unknown Error: ', err)\n  }\n}\n"
          },
          {
            "lang": "Python",
            "source": "try:\n    subscription = client.get_subscription(subscription_id)\n    print(\"Got Subscription %s\" % subscription)\nexcept recurly.errors.NotFoundError:\n    # If the resource was not found, you may want to alert the user or\n    # just return nil\n    print(\"Resource Not Found\")\n"
          },
          {
            "lang": ".NET",
            "source": "try\n{\n    Subscription subscription = client.GetSubscription(sub.Id);\n    Console.WriteLine($\"Fetched Subscription {subscription.Id}\");\n}\ncatch (Recurly.Errors.NotFound ex)\n{\n    // If the resource was not found\n    // we may want to alert the user or just return null\n    Console.WriteLine($\"Resource Not Found: {ex.Error.Message}\");\n}\ncatch (Recurly.Errors.ApiError ex)\n{\n    // Use ApiError to catch a generic error from the API\n    Console.WriteLine($\"Unexpected Recurly Error: {ex.Error.Message}\");\n}\n"
          },
          {
            "lang": "Ruby",
            "source": "begin\n  subscription = @client.get_subscription(\n    subscription_id: subscription_id\n  )\n  puts \"Got Subscription #{subscription}\"\nrescue Recurly::Errors::NotFoundError\n  # If the resource was not found, you may want to alert the user or\n  # just return nil\n  puts \"Resource Not Found\"\nend\n"
          },
          {
            "lang": "Java",
            "source": "try {\n    final Subscription subscription = client.getSubscription(subscriptionId);\n    System.out.println(\"Fetched Subscription: \" + subscription.getUuid());\n} catch (ValidationException e) {\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in e.getError().getParams()\n    System.out.println(\"Failed validation: \" + e.getError().getMessage());\n} catch (ApiException e) {\n    // Use ApiException to catch a generic error from the API\n    System.out.println(\"Unexpected Recurly Error: \" + e.getError().getMessage());\n}\n"
          },
          {
            "lang": "PHP",
            "source": "try {\n    $subscription = $client->getSubscription($subscription_id);\n\n    echo 'Got Subscription:' . PHP_EOL;\n    var_dump($subscription);\n} catch (\\Recurly\\Errors\\NotFound $e) {\n    // Could not find the resource, you may want to inform the user\n    // or just return a NULL\n    echo 'Could not find resource.' . PHP_EOL;\n    var_dump($e);\n} catch (\\Recurly\\RecurlyError $e) {\n    // Something bad happened... tell the user so that they can fix it?\n    echo 'Some unexpected Recurly error happened. Try again later.' . PHP_EOL;\n}\n"
          },
          {
            "lang": "Go",
            "source": "sub, err := client.GetSubscription(subID)\nif e, ok := err.(*recurly.Error); ok {\n\tif e.Type == recurly.ErrorTypeNotFound {\n\t\tfmt.Printf(\"Resource not found: %v\", e)\n\t\treturn nil, err\n\t}\n\tfmt.Printf(\"Unexpected Recurly error: %v\", e)\n\treturn nil, err\n}\nfmt.Printf(\"Fetched Subscription: %s\", sub.Id)"
          }
        ]
      },
      "put": {
        "tags": [
          "subscription"
        ],
        "operationId": "update_subscription",
        "summary": "Update a subscription",
        "description": "This only lets you change the subscription settings that have no impact on the billed amount. Use the [Create Subscription Change](#operation/create_subscription_change) endpoint to make those changes.",
        "parameters": [
          {
            "$ref": "#/components/parameters/subscription_id"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SubscriptionUpdate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "A subscription.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Subscription"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": [
          {
            "lang": "Node.js",
            "source": "try {\n  const update = {\n    termsAndConditions: \"Some new terms and conditions\",\n    customerNotes: \"Some new customer notes\"\n  }\n  const subscription = await client.updateSubscription(subscriptionId, update)\n  console.log('Modified subscription: ', subscription.uuid)\n} catch(err) {\n\n  if (err instanceof recurly.errors.ValidationError) {\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in err.params\n    console.log('Failed validation', err.params)\n  } else {\n    // If we don't know what to do with the err, we should\n    // probably re-raise and let our web framework and logger handle it\n    console.log('Unknown Error: ', err)\n  }\n}\n"
          },
          {
            "lang": "Python",
            "source": "try:\n    sub_update = {\"customer_notes\": \"New Notes\", \"terms_and_conditions\": \"New TaC\"}\n    subscription = client.update_subscription(subscription_id, sub_update)\n    print(\"Modified Subscription %s\" % subscription)\nexcept recurly.errors.ValidationError as e:\n    # If the request was invalid, you may want to tell your user\n    # why. You can find the invalid params and reasons in e.error.params\n    print(\"ValidationError: %s\" % e.error.message)\n    print(e.error.params)\n"
          },
          {
            "lang": ".NET",
            "source": "try\n{\n    var updateReq = new SubscriptionUpdate()\n    {\n        TermsAndConditions = \"Some New Terms and Conditions\",\n        CustomerNotes = \"Some New Customer Notes\"\n    };\n    Subscription subscription = client.UpdateSubscription(subscriptionId, updateReq);\n    Console.WriteLine($\"Modified Subscription {subscription.Uuid}\");\n}\ncatch (Recurly.Errors.Validation ex)\n{\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in ex.Error.Params\n    Console.WriteLine($\"Failed validation: {ex.Error.Message}\");\n}\ncatch (Recurly.Errors.ApiError ex)\n{\n    // Use ApiError to catch a generic error from the API\n    Console.WriteLine($\"Unexpected Recurly Error: {ex.Error.Message}\");\n}\n"
          },
          {
            "lang": "Ruby",
            "source": "begin\n  subscription_update = {\n    customer_notes: \"New Notes\",\n    terms_and_conditions: \"New ToC\"\n  }\n  subscription = @client.update_subscription(\n    subscription_id: subscription_id,\n    body: subscription_update\n  )\n  puts \"Modified Subscription #{subscription}\"\nrescue Recurly::Errors::ValidationError => e\n  # If the request was invalid, you may want to tell your user\n  # why. You can find the invalid params and reasons in e.recurly_error.params\n  puts \"ValidationError: #{e.recurly_error.params}\"\nend\n"
          },
          {
            "lang": "Java",
            "source": "try {\n    final SubscriptionUpdate subUpdate = new SubscriptionUpdate();\n    subUpdate.setTermsAndConditions(\"Some new terms and conditions\");\n    subUpdate.setCustomerNotes(\"Some new customer notes\");\n    final Subscription subscription = client.updateSubscription(subscriptionId, subUpdate);\n    System.out.println(\"Modified Subscription: \" + subscription.getUuid());\n} catch (ValidationException e) {\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in e.getError().getParams()\n    System.out.println(\"Failed validation: \" + e.getError().getMessage());\n} catch (ApiException e) {\n    // Use ApiException to catch a generic error from the API\n    System.out.println(\"Unexpected Recurly Error: \" + e.getError().getMessage());\n}\n"
          },
          {
            "lang": "PHP",
            "source": "try {\n    $changes = [\n        \"terms_and_conditions\" => \"Some new terms and conditions\",\n        \"customer_notes\" => \"Some new customer notes\"\n    ];\n\n    $subscription = $client->updateSubscription($subscription_id, $changes);\n\n    echo 'Modified Subscription:' . PHP_EOL;\n    var_dump($subscription);\n} catch (\\Recurly\\Errors\\Validation $e) {\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in err.params\n    var_dump($e);\n} catch (\\Recurly\\RecurlyError $e) {\n    // If we don't know what to do with the err, we should\n    // probably re-raise and let our web framework and logger handle it\n    var_dump($e);\n}\n"
          },
          {
            "lang": "Go",
            "source": "updateReq := &recurly.SubscriptionUpdate{\n\tTermsAndConditions: recurly.String(\"Some new terms and conditions\"),\n\tCustomerNotes:      recurly.String(\"Some new customer notes\"),\n}\nsub, err := client.UpdateSubscription(subID, updateReq)\nif e, ok := err.(*recurly.Error); ok {\n\tif e.Type == recurly.ErrorTypeValidation {\n\t\tfmt.Printf(\"Failed validation: %v\", e)\n\t\treturn nil, err\n\t}\n\tfmt.Printf(\"Unexpected Recurly error: %v\", e)\n\treturn nil, err\n}\nfmt.Printf(\"Modified Subscription: %s\", sub.Id)"
          }
        ]
      },
      "delete": {
        "tags": [
          "subscription"
        ],
        "operationId": "terminate_subscription",
        "summary": "Terminate a subscription",
        "description": "Immediately expires the subscription.\n\nIf the subscription has a paid invoice you may choose to refund all, part or none of last invoice's amount.\n",
        "parameters": [
          {
            "$ref": "#/components/parameters/subscription_id"
          },
          {
            "name": "refund",
            "in": "query",
            "description": "The type of refund to perform:\n\n* `full` - Performs a full refund of the last invoice for the current subscription term.\n* `partial` - Prorates a refund based on the amount of time remaining in the current bill cycle.\n* `none` - Terminates the subscription without a refund.\n\nIn the event that the most recent invoice is a $0 invoice paid entirely by credit, Recurly will apply the credit back to the customerâ€™s account.\n\nYou may also terminate a subscription with no refund and then manually refund specific invoices.\n",
            "schema": {
              "default": "none",
              "type": "string",
              "enum": [
                "full",
                "none",
                "partial"
              ]
            }
          },
          {
            "name": "charge",
            "in": "query",
            "description": "Applicable only if the subscription has usage based add-ons and unbilled usage logged for the current billing cycle. If true, current billing cycle unbilled usage is billed on the final invoice. If false, Recurly will create a negative usage record for current billing cycle usage that will zero out the final invoice line items.",
            "schema": {
              "default": true,
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "An expired subscription.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Subscription"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site ID or subscription ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "422": {
            "description": "A validation error such as \"Cannot expire an inactive subscription.\" or \"Please provide valid values for these parameters: refund.\"",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": [
          {
            "lang": "Node.js",
            "source": "try {\n  const subscription = await client.terminateSubscription(subscriptionId)\n  console.log('Terminated subscription: ', subscription.uuid)\n} catch (err) {\n  if (err instanceof recurly.errors.ValidationError) {\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in err.params\n    console.log('Failed validation', err.params)\n  } else {\n    // If we don't know what to do with the err, we should\n    // probably re-raise and let our web framework and logger handle it\n    console.log('Unknown Error: ', err)\n  }\n}\n"
          },
          {
            "lang": "Python",
            "source": "try:\n    subscription = client.terminate_subscription(subscription_id)\n    print(\"Terminated Subscription %s\" % subscription)\nexcept recurly.errors.NotFoundError:\n    # If the resource was not found, you may want to alert the user or\n    # just return nil\n    print(\"Resource Not Found\")\n"
          },
          {
            "lang": ".NET",
            "source": "try\n{\n    var optionalParams = new TerminateSubscriptionParams()\n    {\n        Refund = RefundType.None\n    };\n    Subscription subscription = client.TerminateSubscription(subscriptionId, optionalParams);\n    Console.WriteLine($\"Terminated Subscription {subscription.Uuid}\");\n}\ncatch (Recurly.Errors.Validation ex)\n{\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in ex.Error.Params\n    Console.WriteLine($\"Failed validation: {ex.Error.Message}\");\n}\ncatch (Recurly.Errors.ApiError ex)\n{\n    // Use ApiError to catch a generic error from the API\n    Console.WriteLine($\"Unexpected Recurly Error: {ex.Error.Message}\");\n}\n"
          },
          {
            "lang": "Ruby",
            "source": "begin\n  subscription = @client.terminate_subscription(\n    subscription_id: subscription_id,\n  )\n  puts \"Terminated Subscription #{subscription}\"\nrescue Recurly::Errors::NotFoundError\n  # If the resource was not found, you may want to alert the user or\n  # just return nil\n  puts \"Resource Not Found\"\nend\n"
          },
          {
            "lang": "Java",
            "source": "try {\n    QueryParams queryParams = new QueryParams();\n    queryParams.setRefund(Constants.RefundType.NONE); // \"full\" for a full refund, \"partial\" for prorated refund\n    client.terminateSubscription(subscriptionId, queryParams);\n    System.out.println(\"Terminated Subscription: \" + subscriptionId);\n} catch (ValidationException e) {\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in e.getError().getParams()\n    System.out.println(\"Failed validation: \" + e.getError().getMessage());\n} catch (ApiException e) {\n    // Use ApiException to catch a generic error from the API\n    System.out.println(\"Unexpected Recurly Error: \" + e.getError().getMessage());\n}\n"
          },
          {
            "lang": "PHP",
            "source": "try {\n    $subscription = $client->terminateSubscription($subscription_id);\n\n    echo 'Terminated Subscription:' . PHP_EOL;\n    var_dump($subscription);\n} catch (\\Recurly\\Errors\\Validation $e) {\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in err.params\n    var_dump($e);\n} catch (\\Recurly\\RecurlyError $e) {\n    // If we don't know what to do with the err, we should\n    // probably re-raise and let our web framework and logger handle it\n    var_dump($e);\n}\n"
          },
          {
            "lang": "Go",
            "source": "terminateParams := &recurly.TerminateSubscriptionParams{}\nsubscription, err := client.TerminateSubscription(subID, terminateParams)\nif e, ok := err.(*recurly.Error); ok {\n\tif e.Type == recurly.ErrorTypeNotFound {\n\t\tfmt.Printf(\"Resource not found: %v\", e)\n\t\treturn nil, err\n\t}\n\tfmt.Printf(\"Unexpected Recurly error: %v\", e)\n\treturn nil, err\n}\n\nfmt.Printf(\"Terminated Subscription: %v\", subscription)"
          }
        ]
      }
    },
    "/subscriptions/{subscription_id}/cancel": {
      "put": {
        "tags": [
          "subscription"
        ],
        "operationId": "cancel_subscription",
        "summary": "Cancel a subscription",
        "description": "A canceled subscription will continue through its current billing cycle. At the end of the current billing cycle the subscription will expire and the customer will no longer be billed. Canceled subscriptions can be reactivated until the end of the billing cycle. When a future subscription (`state=future`) is canceled it becomes failed `state=failed` and cannot be reactivated.",
        "parameters": [
          {
            "$ref": "#/components/parameters/subscription_id"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SubscriptionCancel"
              }
            }
          },
          "required": false
        },
        "responses": {
          "200": {
            "description": "A canceled or failed subscription.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Subscription"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site or subscription ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "422": {
            "description": "A validation error such as \"Only active and future subscriptions can be canceled\".",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": [
          {
            "lang": "Node.js",
            "source": "try {\n  let expiredSub = await client.cancelSubscription(subscriptionId)\n  console.log('Canceled Subscription: ', expiredSub.uuid)\n} catch (err) {\n  if (err instanceof recurly.errors.ValidationError) {\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in err.params\n    console.log('Failed validation', err.params)\n  } else {\n    // If we don't know what to do with the err, we should\n    // probably re-raise and let our web framework and logger handle it\n    console.log('Unknown Error: ', err)\n  }\n}\n"
          },
          {
            "lang": "Python",
            "source": "try:\n    subscription = client.cancel_subscription(subscription_id)\n    print(\"Canceled Subscription %s\" % subscription)\nexcept recurly.errors.NotFoundError:\n    # If the resource was not found, you may want to alert the user or\n    # just return nil\n    print(\"Resource Not Found\")\n"
          },
          {
            "lang": ".NET",
            "source": "try\n{\n    Subscription subscription = client.CancelSubscription(subscriptionId);\n    Console.WriteLine($\"Canceled Subscription {subscription.Uuid}\");\n}\ncatch (Recurly.Errors.Validation ex)\n{\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in ex.Error.Params\n    Console.WriteLine($\"Failed validation: {ex.Error.Message}\");\n}\ncatch (Recurly.Errors.ApiError ex)\n{\n    // Use ApiError to catch a generic error from the API\n    Console.WriteLine($\"Unexpected Recurly Error: {ex.Error.Message}\");\n}\n"
          },
          {
            "lang": "Ruby",
            "source": "begin\n  subscription = @client.cancel_subscription(\n    subscription_id: subscription_id\n  )\n  puts \"Canceled Subscription #{subscription}\"\nrescue Recurly::Errors::NotFoundError\n  # If the resource was not found, you may want to alert the user or\n  # just return nil\n  puts \"Resource Not Found\"\nend\n"
          },
          {
            "lang": "Java",
            "source": "try {\n    final Subscription subscription = client.cancelSubscription(subscriptionId);\n    System.out.println(\"Canceled Subscription: \" + subscription.getUuid());\n} catch (ValidationException e) {\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in e.getError().getParams()\n    System.out.println(\"Failed validation: \" + e.getError().getMessage());\n} catch (ApiException e) {\n    // Use ApiException to catch a generic error from the API\n    System.out.println(\"Unexpected Recurly Error: \" + e.getError().getMessage());\n}\n"
          },
          {
            "lang": "PHP",
            "source": "try {\n    $subscription = $client->cancelSubscription($subscription_id);\n\n    echo 'Canceled Subscription:' . PHP_EOL;\n    var_dump($subscription);\n} catch (\\Recurly\\Errors\\Validation $e) {\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in err.params\n    var_dump($e);\n} catch (\\Recurly\\RecurlyError $e) {\n    // If we don't know what to do with the err, we should\n    // probably re-raise and let our web framework and logger handle it\n    var_dump($e);\n}\n"
          },
          {
            "lang": "Go",
            "source": "cancelParams := &recurly.CancelSubscriptionParams{\n\tBody: &recurly.SubscriptionCancel{\n\t\tTimeframe: recurly.String(\"bill_date\"),\n\t},\n}\n\nsubscription, err := client.CancelSubscription(subID, cancelParams)\nif e, ok := err.(*recurly.Error); ok {\n\tif e.Type == recurly.ErrorTypeValidation {\n\t\tfmt.Printf(\"Failed validation: %v\", e)\n\t\treturn nil, err\n\t}\n\tfmt.Printf(\"Unexpected Recurly error: %v\", e)\n\treturn nil, err\n}\nfmt.Printf(\"Canceled Subscription: %s\", subscription.Id)"
          }
        ]
      }
    },
    "/subscriptions/{subscription_id}/reactivate": {
      "put": {
        "tags": [
          "subscription"
        ],
        "operationId": "reactivate_subscription",
        "summary": "Reactivate a canceled subscription",
        "description": "This will bring the subscription back to an active, renewing state on the customer's original billing cycle.\n\nExpired or failed subscriptions cannot be reactivated; instead a new subscription plan will need to be applied to the account.\n",
        "parameters": [
          {
            "$ref": "#/components/parameters/subscription_id"
          }
        ],
        "responses": {
          "200": {
            "description": "An active subscription.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Subscription"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site or subscription ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "422": {
            "description": "A validation error such as \"Only canceled subscriptions can be reactivated\".",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": [
          {
            "lang": "Node.js",
            "source": "try {\n  const subscription = await client.reactivateSubscription(subscriptionId)\n  console.log('Reactivated subscription: ', subscription.uuid)\n} catch(err) {\n\n  if (err instanceof recurly.errors.ValidationError) {\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in err.params\n    console.log('Failed validation', err.params)\n  } else {\n    // If we don't know what to do with the err, we should\n    // probably re-raise and let our web framework and logger handle it\n    console.log('Unknown Error: ', err)\n  }\n}\n"
          },
          {
            "lang": "Python",
            "source": "try:\n    subscription = client.reactivate_subscription(subscription_id)\n    print(\"Reactivated Subscription %s\" % subscription)\nexcept recurly.errors.NotFoundError:\n    # If the resource was not found, you may want to alert the user or\n    # just return nil\n    print(\"Resource Not Found\")\n"
          },
          {
            "lang": ".NET",
            "source": "try\n{\n    Subscription subscription = client.ReactivateSubscription(subscriptionId);\n    Console.WriteLine($\"Reactivated Subscription {subscription.Uuid}\");\n}\ncatch (Recurly.Errors.Validation ex)\n{\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in ex.Error.Params\n    Console.WriteLine($\"Failed validation: {ex.Error.Message}\");\n}\ncatch (Recurly.Errors.ApiError ex)\n{\n    // Use ApiError to catch a generic error from the API\n    Console.WriteLine($\"Unexpected Recurly Error: {ex.Error.Message}\");\n}\n"
          },
          {
            "lang": "Ruby",
            "source": "begin\n  subscription = @client.reactivate_subscription(\n    subscription_id: subscription_id\n  )\n  puts \"Reactivated Canceled Subscription #{subscription}\"\nrescue Recurly::Errors::NotFoundError\n  # If the resource was not found, you may want to alert the user or\n  # just return nil\n  puts \"Resource Not Found\"\nend\n"
          },
          {
            "lang": "Java",
            "source": "try {\n    final Subscription subscription = client.reactivateSubscription(subscriptionId);\n    System.out.println(\"Reactivated Subscription: \" + subscription.getUuid());\n} catch (ValidationException e) {\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in e.getError().getParams()\n    System.out.println(\"Failed validation: \" + e.getError().getMessage());\n} catch (ApiException e) {\n    // Use ApiException to catch a generic error from the API\n    System.out.println(\"Unexpected Recurly Error: \" + e.getError().getMessage());\n}\n"
          },
          {
            "lang": "PHP",
            "source": "try {\n    $subscription = $client->reactivateSubscription($subscription_id);\n\n    echo 'Reactivated Subscription:' . PHP_EOL;\n    var_dump($subscription);\n} catch (\\Recurly\\Errors\\Validation $e) {\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in err.params\n    var_dump($e);\n} catch (\\Recurly\\RecurlyError $e) {\n    // If we don't know what to do with the err, we should\n    // probably re-raise and let our web framework and logger handle it\n    var_dump($e);\n}\n"
          },
          {
            "lang": "Go",
            "source": "sub, err := client.ReactivateSubscription(subID)\nif e, ok := err.(*recurly.Error); ok {\n\tif e.Type == recurly.ErrorTypeValidation {\n\t\tfmt.Printf(\"Failed validation: %v\", e)\n\t\treturn nil, err\n\t}\n\tfmt.Printf(\"Unexpected Recurly error: %v\", e)\n\treturn nil, err\n}\nfmt.Printf(\"Reactivated Subscription: %s\", sub.Id)"
          }
        ]
      }
    },
    "/subscriptions/{subscription_id}/pause": {
      "put": {
        "tags": [
          "subscription"
        ],
        "operationId": "pause_subscription",
        "summary": "Pause subscription",
        "description": "This will put a subscription into the pause state at the next renewal. The body\nof the request must contain the `remaining_pause_cycles` parameter. If the\nsubscription is currently paused and `remaining_pause_cycles` is 0, the subscription\nwill be resumed.\n\nExpired, cancelled, or failed subscriptions cannot be paused.\n",
        "parameters": [
          {
            "$ref": "#/components/parameters/subscription_id"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SubscriptionPause"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "A subscription.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Subscription"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site or subscription ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "422": {
            "description": "A validation error such as \"remaining_pause_cycles is required\".",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": [
          {
            "lang": "Node.js",
            "source": "try {\n  let pauseReq = {\n    remaining_pause_cycles: 2,\n  }\n  const subscription = await client.pauseSubscription(subscriptionId, pauseReq)\n  console.log('Paused subscription: ', subscription.id)\n} catch (err) {\n  if (err instanceof recurly.errors.ValidationError) {\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in err.params\n    console.log('Failed validation', err.params)\n  } else {\n    // If we don't know what to do with the err, we should\n    // probably re-raise and let our web framework and logger handle it\n    console.log('Unknown Error: ', err)\n  }\n}\n"
          },
          {
            "lang": "Python",
            "source": "try:\n    sub_pause = {\"remaining_pause_cycles\": 10}\n    subscription = client.pause_subscription(subscription_id, sub_pause)\n    print(\"Paused Subscription %s\" % subscription)\nexcept recurly.errors.ValidationError as e:\n    # If the request was invalid, you may want to tell your user\n    # why. You can find the invalid params and reasons in e.error.params\n    print(\"ValidationError: %s\" % e.error.message)\n    print(e.error.params)\n"
          },
          {
            "lang": ".NET",
            "source": "try\n{\n    var pauseReq = new SubscriptionPause() {\n      RemainingPauseCycles = 2\n    };\n    Subscription subscription = client.PauseSubscription(subscriptionId, pauseReq);\n    Console.WriteLine($\"Paused Subscription {subscription.Id}\");\n}\ncatch (Recurly.Errors.NotFound ex)\n{\n    // If the resource was not found\n    // we may want to alert the user or just return null\n    Console.WriteLine($\"Resource Not Found: {ex.Error.Message}\");\n}\ncatch (Recurly.Errors.ApiError ex)\n{\n    // Use ApiError to catch a generic error from the API\n    Console.WriteLine($\"Unexpected Recurly Error: {ex.Error.Message}\");\n}\n"
          },
          {
            "lang": "Ruby",
            "source": "begin\n  subscription_pause = {\n    remaining_pause_cycles: 10\n  }\n  subscription = @client.pause_subscription(\n    subscription_id: subscription_id,\n    body: subscription_pause\n  )\n  puts \"Paused Subscription #{subscription}\"\nrescue Recurly::Errors::NotFoundError\n  # If the resource was not found, you may want to alert the user or\n  # just return nil\n  puts \"Resource Not Found\"\nend\n"
          },
          {
            "lang": "Java",
            "source": "try {\n    final SubscriptionPause subPause = new SubscriptionPause();\n    subPause.setRemainingPauseCycles(10);\n\n    final Subscription subscription = client.pauseSubscription(subscriptionId, subPause);\n    System.out.println(\"Paused Subscription: \" + subscription.getUuid());\n} catch (ValidationException e) {\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in e.getError().getParams()\n    System.out.println(\"Failed validation: \" + e.getError().getMessage());\n} catch (ApiException e) {\n    // Use ApiException to catch a generic error from the API\n    System.out.println(\"Unexpected Recurly Error: \" + e.getError().getMessage());\n}\n"
          },
          {
            "lang": "PHP",
            "source": "try {\n    $sub_pause = [ \"remaining_pause_cycles\" => 10 ];\n    $subscription = $client->pauseSubscription($subscription_id, $sub_pause);\n\n    echo 'Paused Subscription:' . PHP_EOL;\n    var_dump($subscription);\n} catch (\\Recurly\\Errors\\Validation $e) {\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in err.params\n    var_dump($e);\n} catch (\\Recurly\\RecurlyError $e) {\n    // If we don't know what to do with the err, we should\n    // probably re-raise and let our web framework and logger handle it\n    var_dump($e);\n}\n"
          },
          {
            "lang": "Go",
            "source": "pauseReq := &recurly.SubscriptionPause{\n\tRemainingPauseCycles: recurly.Int(1),\n}\nsub, err := client.PauseSubscription(subID, pauseReq)\nif e, ok := err.(*recurly.Error); ok {\n\tif e.Type == recurly.ErrorTypeValidation {\n\t\tfmt.Printf(\"Failed validation: %v\", e)\n\t\treturn nil, err\n\t}\n\tfmt.Printf(\"Unexpected Recurly error: %v\", e)\n\treturn nil, err\n}\nfmt.Printf(\"Paused Subscription: %s\", sub.Id)"
          }
        ]
      }
    },
    "/subscriptions/{subscription_id}/resume": {
      "put": {
        "tags": [
          "subscription"
        ],
        "operationId": "resume_subscription",
        "summary": "Resume subscription",
        "description": "This will immediately resume a paused subscription and move it into the\nactive state.\n\nThe subscription must be in the paused state. Active, expired, cancelled,\nor failed subscriptions cannot be resumed.\n",
        "parameters": [
          {
            "$ref": "#/components/parameters/subscription_id"
          }
        ],
        "responses": {
          "200": {
            "description": "A subscription.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Subscription"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site or subscription ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "422": {
            "description": "A validation error such as \"Unable to resume active subscription\".",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": [
          {
            "lang": "Node.js",
            "source": "try {\n  const subscription = await client.resumeSubscription(subscriptionId)\n  console.log('Resumed subscription: ', subscription.id)\n} catch (err) {\n  if (err instanceof recurly.errors.ValidationError) {\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in err.params\n    console.log('Failed validation', err.params)\n  } else {\n    // If we don't know what to do with the err, we should\n    // probably re-raise and let our web framework and logger handle it\n    console.log('Unknown Error: ', err)\n  }\n}\n"
          },
          {
            "lang": "Python",
            "source": "try:\n    subscription = client.resume_subscription(subscription_id)\n    print(\"Resumed Subscription %s\" % subscription)\nexcept recurly.errors.ValidationError as e:\n    # If the request was invalid, you may want to tell your user\n    # why. You can find the invalid params and reasons in e.error.params\n    print(\"ValidationError: %s\" % e.error.message)\n    print(e.error.params)\n"
          },
          {
            "lang": ".NET",
            "source": "try\n{\n    Subscription subscription = client.ResumeSubscription(subscriptionId);\n    Console.WriteLine($\"Resumed Subscription {subscription.Id}\");\n}\ncatch (Recurly.Errors.NotFound ex)\n{\n    // If the resource was not found\n    // we may want to alert the user or just return null\n    Console.WriteLine($\"Resource Not Found: {ex.Error.Message}\");\n}\ncatch (Recurly.Errors.ApiError ex)\n{\n    // Use ApiError to catch a generic error from the API\n    Console.WriteLine($\"Unexpected Recurly Error: {ex.Error.Message}\");\n}\n"
          },
          {
            "lang": "Ruby",
            "source": "begin\n  subscription = @client.resume_subscription(\n    subscription_id: subscription_id\n  )\n  puts \"Resumed Subscription #{subscription}\"\nrescue Recurly::Errors::NotFoundError\n  # If the resource was not found, you may want to alert the user or\n  # just return nil\n  puts \"Resource Not Found\"\nend\n"
          },
          {
            "lang": "Java",
            "source": "try {\n    final Subscription subscription = client.resumeSubscription(subscriptionId);\n    System.out.println(\"Resumed Subscription: \" + subscription.getUuid());\n} catch (ValidationException e) {\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in e.getError().getParams()\n    System.out.println(\"Failed validation: \" + e.getError().getMessage());\n} catch (ApiException e) {\n    // Use ApiException to catch a generic error from the API\n    System.out.println(\"Unexpected Recurly Error: \" + e.getError().getMessage());\n}\n"
          },
          {
            "lang": "PHP",
            "source": "try {\n    $subscription = $client->resumeSubscription($subscription_id);\n\n    echo 'Resumed Subscription:' . PHP_EOL;\n    var_dump($subscription);\n} catch (\\Recurly\\Errors\\Validation $e) {\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in err.params\n    var_dump($e);\n} catch (\\Recurly\\RecurlyError $e) {\n    // If we don't know what to do with the err, we should\n    // probably re-raise and let our web framework and logger handle it\n    var_dump($e);\n}\n"
          },
          {
            "lang": "Go",
            "source": "sub, err := client.ResumeSubscription(subID)\nif e, ok := err.(*recurly.Error); ok {\n\tif e.Type == recurly.ErrorTypeValidation {\n\t\tfmt.Printf(\"Failed validation: %v\", e)\n\t\treturn nil, err\n\t}\n\tfmt.Printf(\"Unexpected Recurly error: %v\", e)\n\treturn nil, err\n}\nfmt.Printf(\"Resumed Subscription: %s\", sub.Id)"
          }
        ]
      }
    },
    "/subscriptions/{subscription_id}/convert_trial": {
      "put": {
        "tags": [
          "subscription"
        ],
        "operationId": "convert_trial",
        "summary": "Convert trial subscription",
        "description": "This will immediately convert a trial subscription to a fully active paid subscription, creating and collecting an invoice for auto-collecting subsriptions.  If the invoice cannot be collected, the subscription will remain in trial. The subscription must be in a trial. Active, paused, expired, cancelled, or failed subscriptions cannot be converted.",
        "parameters": [
          {
            "$ref": "#/components/parameters/subscription_id"
          }
        ],
        "responses": {
          "200": {
            "description": "A subscription.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Subscription"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site or subscription ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "422": {
            "description": "A validation error such as \"Unable to convert active subscription\", or a transaction error if the invoice could not be collected.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorMayHaveTransaction"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": []
      }
    },
    "/subscriptions/{subscription_id}/preview_renewal": {
      "get": {
        "tags": [
          "subscription"
        ],
        "operationId": "get_preview_renewal",
        "summary": "Fetch a preview of a subscription's renewal invoice(s)",
        "description": "The subscriptions's renewal invoice(s) will be returned if they exist; if they don't (for example, if the subscription is not set to renew), it will return an result with no invoices.",
        "parameters": [
          {
            "$ref": "#/components/parameters/subscription_id"
          }
        ],
        "responses": {
          "200": {
            "description": "A preview of the subscription's renewal invoice(s).",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/InvoiceCollection"
                }
              }
            }
          },
          "400": {
            "description": "Invalid or unpermitted parameter.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site ID or subscription ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": [
          {
            "lang": "Node.js",
            "source": "try {\n  const invoiceCollection = await client.getPreviewRenewal(subscriptionId)\n  console.log('Fetched Renewal Preview with total: ', invoiceCollection.chargeInvoice.total)\n} catch (err) {\n  if (err instanceof recurly.errors.NotFoundError) {\n    // If the request was not found, you may want to alert the user or\n    // just return null\n    console.log('Resource Not Found')\n  } else {\n    // If we don't know what to do with the err, we should\n    // probably re-raise and let our web framework and logger handle it\n    console.log('Unknown Error: ', err)\n  }\n}\n"
          },
          {
            "lang": "Python",
            "source": "try:\n    invoice_collection = client.get_preview_renewal(subscription_id)\n    print(\"Fetched Renewal Preview with total: %s\" % invoice_collection.charge_invoice.total)\nexcept recurly.errors.NotFoundError:\n    # If the resource was not found, you may want to alert the user or\n    # just return nil\n    print(\"Resource Not Found\")\n"
          },
          {
            "lang": ".NET",
            "source": "try\n{\n    InvoiceCollection invoiceCollection = client.GetPreviewRenewal(subscriptionId);\n    Console.WriteLine($\"Fetched Renewal Preview with total {invoiceCollection.ChargeInvoice.Total}\");\n}\ncatch (Recurly.Errors.NotFound ex)\n{\n    // If the resource was not found\n    // we may want to alert the user or just return null\n    Console.WriteLine($\"Resource Not Found: {ex.Error.Message}\");\n}\ncatch (Recurly.Errors.ApiError ex)\n{\n    // Use ApiError to catch a generic error from the API\n    Console.WriteLine($\"Unexpected Recurly Error: {ex.Error.Message}\");\n}\n"
          },
          {
            "lang": "Ruby",
            "source": "begin\n  invoice_collection = @client.get_preview_renewal(\n    subscription_id: subscription_id\n  )\n  puts \"Fetched Renewal Preview with total: #{invoice_collection.charge_invoice.total}\"\nrescue Recurly::Errors::NotFoundError\n  # If the resource was not found, you may want to alert the user or\n  # just return nil\n  puts \"Resource Not Found\"\nend\n"
          },
          {
            "lang": "Java",
            "source": "try {\n    final InvoiceCollection invoiceCollection = client.getPreviewRenewal(subscriptionId);\n    System.out.println(\"Fetched Renewal Preview with total: \" + invoiceCollection.getChargeInvoice().getTotal());\n} catch (ValidationException e) {\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in e.getError().getParams()\n    System.out.println(\"Failed validation: \" + e.getError().getMessage());\n} catch (ApiException e) {\n    // Use ApiException to catch a generic error from the API\n    System.out.println(\"Unexpected Recurly Error: \" + e.getError().getMessage());\n}\n"
          },
          {
            "lang": "PHP",
            "source": "try {\n    $invoiceCollection = $client->getPreviewRenewal($subscription_id);\n\n    echo 'Fetched Renewal Preview with total: ' . $invoiceCollection->getChargeInvoice()->getTotal() . PHP_EOL;\n    var_dump($invoiceCollection);\n} catch (\\Recurly\\Errors\\NotFound $e) {\n    // Could not find the resource, you may want to inform the user\n    // or just return a NULL\n    echo 'Could not find resource.' . PHP_EOL;\n    var_dump($e);\n} catch (\\Recurly\\RecurlyError $e) {\n    // Something bad happened... tell the user so that they can fix it?\n    echo 'Some unexpected Recurly error happened. Try again later.' . PHP_EOL;\n}\n"
          },
          {
            "lang": "Go",
            "source": "invoiceCollection, err := client.GetPreviewRenewal(subID)\nif e, ok := err.(*recurly.Error); ok {\n\tif e.Type == recurly.ErrorTypeNotFound {\n\t\tfmt.Printf(\"Resource not found: %v\", e)\n\t\treturn nil, err\n\t}\n\tfmt.Printf(\"Unexpected Recurly error: %v\", e)\n\treturn nil, err\n}\nfmt.Printf(\"Fetched Renewal Preview with total: %f\", invoiceCollection.ChargeInvoice.Total)"
          }
        ]
      }
    },
    "/subscriptions/{subscription_id}/change": {
      "get": {
        "tags": [
          "subscription_change"
        ],
        "operationId": "get_subscription_change",
        "summary": "Fetch a subscription's pending change",
        "parameters": [
          {
            "$ref": "#/components/parameters/subscription_id"
          }
        ],
        "responses": {
          "200": {
            "description": "A subscription's pending change.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SubscriptionChange"
                }
              }
            }
          },
          "400": {
            "description": "Invalid or unpermitted parameter.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site ID or subscription ID or the subscription has no pending change.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "422": {
            "description": "Expired subscriptions cannot be changed.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": [
          {
            "lang": "Node.js",
            "source": "try {\n  const change = await client.getSubscriptionChange(subscriptionId)\n  console.log('Fetched subscription change: ', change.id)\n} catch (err) {\n  if (err instanceof recurly.errors.NotFoundError) {\n    // If the request was not found, you may want to alert the user or\n    // just return null\n    console.log('Resource Not Found')\n  } else {\n    // If we don't know what to do with the err, we should\n    // probably re-raise and let our web framework and logger handle it\n    console.log('Unknown Error: ', err)\n  }\n}\n"
          },
          {
            "lang": "Python",
            "source": "try:\n    change = client.get_subscription_change(subscription_id)\n    print(\"Got SubscriptionChange %s\" % change)\nexcept recurly.errors.NotFoundError:\n    # If the resource was not found, you may want to alert the user or\n    # just return nil\n    print(\"Resource Not Found\")\n"
          },
          {
            "lang": ".NET",
            "source": "try\n{\n    SubscriptionChange change = client.GetSubscriptionChange(subscriptionId);\n    Console.WriteLine($\"Fetched subscription change {change.Id}\");\n}\ncatch (Recurly.Errors.NotFound ex)\n{\n    // If the resource was not found\n    // we may want to alert the user or just return null\n    Console.WriteLine($\"Resource Not Found: {ex.Error.Message}\");\n}\ncatch (Recurly.Errors.ApiError ex)\n{\n    // Use ApiError to catch a generic error from the API\n    Console.WriteLine($\"Unexpected Recurly Error: {ex.Error.Message}\");\n}\n"
          },
          {
            "lang": "Ruby",
            "source": "begin\n  change = @client.get_subscription_change(\n    subscription_id: subscription_id\n  )\n  puts \"Got SubscriptionChange #{change}\"\nrescue Recurly::Errors::NotFoundError\n  # If the resource was not found, you may want to alert the user or\n  # just return nil\n  puts \"Resource Not Found\"\nend\n"
          },
          {
            "lang": "Java",
            "source": "try {\n    final SubscriptionChange change = client.getSubscriptionChange(subscriptionId);\n    System.out.println(\"Fetched Subscription change \" + change.getId());\n} catch (ValidationException e) {\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in e.getError().getParams()\n    System.out.println(\"Failed validation: \" + e.getError().getMessage());\n} catch (ApiException e) {\n    // Use ApiException to catch a generic error from the API\n    System.out.println(\"Unexpected Recurly Error: \" + e.getError().getMessage());\n}\n"
          },
          {
            "lang": "PHP",
            "source": "try {\n    $change = $client->getSubscriptionChange($subscription_id);\n\n    echo 'Got Pending Subscription Change:' . PHP_EOL;\n    var_dump($change);\n} catch (\\Recurly\\Errors\\NotFound $e) {\n    // Could not find the resource, you may want to inform the user\n    // or just return a NULL\n    echo 'Could not find resource.' . PHP_EOL;\n    var_dump($e);\n} catch (\\Recurly\\RecurlyError $e) {\n    // Something bad happened... tell the user so that they can fix it?\n    echo 'Some unexpected Recurly error happened. Try again later.' . PHP_EOL;\n}\n"
          },
          {
            "lang": "Go",
            "source": "subscriptionChange, err := client.GetSubscriptionChange(subID)\nif e, ok := err.(*recurly.Error); ok {\n\tif e.Type == recurly.ErrorTypeNotFound {\n\t\tfmt.Printf(\"Resource not found: %v\", e)\n\t\treturn nil, err\n\t}\n\tfmt.Printf(\"Unexpected Recurly error: %v\", e)\n\treturn nil, err\n}\nfmt.Printf(\"Fetched subscription change: %s\", subscriptionChange.Id)"
          }
        ]
      },
      "post": {
        "tags": [
          "subscription_change"
        ],
        "operationId": "create_subscription_change",
        "summary": "Create a new subscription change",
        "description": "Calling this will overwrite an existing, pending subscription change.\n\nIf a subscription has a pending change, and a change is submitted which matches\nthe subscription as it currently exists, the pending change will be deleted,\nand you will receive a 204 No Content response.\n\nIf a subscription has no pending\nchange, and a change is submitted which matches the subscription as it currently\nexists, a 422 Unprocessable Entity validation error will be returned.\n",
        "parameters": [
          {
            "$ref": "#/components/parameters/subscription_id"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SubscriptionChangeCreate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "A subscription change.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SubscriptionChange"
                }
              }
            }
          },
          "204": {
            "description": "The previous pending change was reverted."
          },
          "404": {
            "description": "Incorrect site ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "422": {
            "description": "A validation error such as \"Subscription hasn't been changed\" or error running the verification transaction.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorMayHaveTransaction"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": [
          {
            "lang": "Node.js",
            "source": "try {\n  const subscriptionChangeCreate = {\n    planCode: newPlanCode,\n    timeframe: 'now'\n  }\n\n  const change = await client.createSubscriptionChange(subscriptionId, subscriptionChangeCreate)\n  console.log('Created subscription change: ', change.id)\n} catch (err) {\n  if (err instanceof recurly.errors.ValidationError) {\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in err.params\n    console.log('Failed validation', err.params)\n  } else {\n    // If we don't know what to do with the err, we should\n    // probably re-raise and let our web framework and logger handle it\n    console.log('Unknown Error: ', err)\n  }\n}\n"
          },
          {
            "lang": "Python",
            "source": "try:\n    sub_change_create = {\"plan_code\": new_plan_code, \"timeframe\": \"now\"}\n    change = client.create_subscription_change(subscription_id, sub_change_create)\n    print(\"Created SubscriptionChange %s\" % change)\nexcept recurly.errors.ValidationError as e:\n    # If the request was invalid, you may want to tell your user\n    # why. You can find the invalid params and reasons in e.error.params\n    print(\"ValidationError: %s\" % e.error.message)\n    print(e.error.params)\n"
          },
          {
            "lang": ".NET",
            "source": "try\n{\n    var changeReq = new SubscriptionChangeCreate()\n    {\n        PlanCode = newPlanCode,\n        Timeframe = ChangeTimeframe.Now // choose \"now\" or \"renewal\"\n    };\n    SubscriptionChange change = client.CreateSubscriptionChange(subscriptionId, changeReq);\n    Console.WriteLine($\"Created subscription change {change.Id}\");\n}\ncatch (Recurly.Errors.Validation ex)\n{\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in ex.Error.Params\n    Console.WriteLine($\"Failed validation: {ex.Error.Message}\");\n}\ncatch (Recurly.Errors.ApiError ex)\n{\n    // Use ApiError to catch a generic error from the API\n    Console.WriteLine($\"Unexpected Recurly Error: {ex.Error.Message}\");\n}\n"
          },
          {
            "lang": "Ruby",
            "source": "begin\n  change_create = {\n    timeframe: \"now\",\n    plan_code: new_plan_code\n  }\n  change = @client.create_subscription_change(\n    subscription_id: subscription_id,\n    body: change_create\n  )\n  puts \"Created SubscriptionChange #{change}\"\nrescue Recurly::Errors::ValidationError => e\n  # If the request was invalid, you may want to tell your user\n  # why. You can find the invalid params and reasons in e.recurly_error.params\n  puts \"ValidationError: #{e.recurly_error.params}\"\nend\n"
          },
          {
            "lang": "Java",
            "source": "try {\n    SubscriptionChangeCreate changeCreate = new SubscriptionChangeCreate();\n\n    changeCreate.setPlanCode(newPlanCode);\n    changeCreate.setTimeframe(Constants.ChangeTimeframe.NOW); // choose \"now\" or \"renewal\"\n\n    SubscriptionChange change = client.createSubscriptionChange(subscriptionId, changeCreate);\n    System.out.println(\"Created subscription \" + change.getId());\n} catch (ValidationException e) {\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in e.getError().getParams()\n    System.out.println(\"Failed validation: \" + e.getError().getMessage());\n} catch (ApiException e) {\n    // Use ApiException to catch a generic error from the API\n    System.out.println(\"Unexpected Recurly Error: \" + e.getError().getMessage());\n}\n"
          },
          {
            "lang": "PHP",
            "source": "try {\n    $change_create = [\n        \"plan_code\" => $new_plan_code,\n        \"timeframe\" => \"now\"\n    ];\n    $change = $client->createSubscriptionChange($subscription_id, $change_create);\n\n    echo 'Created Subscription Change:' . PHP_EOL;\n    var_dump($change);\n} catch (\\Recurly\\Errors\\Validation $e) {\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in err.params\n    var_dump($e);\n} catch (\\Recurly\\RecurlyError $e) {\n    // If we don't know what to do with the err, we should\n    // probably re-raise and let our web framework and logger handle it\n    var_dump($e);\n}\n"
          },
          {
            "lang": "Go",
            "source": "changeReq := &recurly.SubscriptionChangeCreate{\n\tPlanCode:  recurly.String(newPlanCode),\n\tTimeframe: recurly.String(\"now\"),\n}\nsubscriptionChange, err := client.CreateSubscriptionChange(subID, changeReq)\nif e, ok := err.(*recurly.Error); ok {\n\tif e.Type == recurly.ErrorTypeValidation {\n\t\tfmt.Printf(\"Failed validation: %v\", e)\n\t\treturn nil, err\n\t}\n\tfmt.Printf(\"Unexpected Recurly error: %v\", e)\n\treturn nil, err\n}\nfmt.Printf(\"Subscription changed: %s\", subscriptionChange.Id)"
          }
        ]
      },
      "delete": {
        "tags": [
          "subscription_change"
        ],
        "operationId": "remove_subscription_change",
        "summary": "Delete the pending subscription change",
        "parameters": [
          {
            "$ref": "#/components/parameters/subscription_id"
          }
        ],
        "description": "Deleting the pending subscription change will cause the current subscription settings to be used on the next renewal.",
        "responses": {
          "204": {
            "description": "Subscription change was deleted."
          },
          "422": {
            "description": "Activated subscription changes cannot be deleted.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": [
          {
            "lang": "Node.js",
            "source": "try {\n  await client.removeSubscriptionChange(subscriptionId)\n  console.log('Removed subscription change: ', subscriptionId)\n} catch (err) {\n  if (err instanceof recurly.errors.NotFoundError) {\n    // If the request was not found, you may want to alert the user or\n    // just return null\n    console.log('Resource Not Found')\n  } else {\n    // If we don't know what to do with the err, we should\n    // probably re-raise and let our web framework and logger handle it\n    console.log('Unknown Error: ', err)\n  }\n}\n"
          },
          {
            "lang": "Python",
            "source": "try:\n    client.remove_subscription_change(subscription_id)\n    print(\"Removed SubscriptionChange from Subscription id=%s\" % subscription_id)\nexcept recurly.errors.NotFoundError:\n    # If the resource was not found, you may want to alert the user or\n    # just return nil\n    print(\"Resource Not Found\")\n"
          },
          {
            "lang": ".NET",
            "source": "try\n{\n    client.RemoveSubscriptionChange(subscriptionId);\n    Console.WriteLine($\"Removed subscription change from {subscriptionId}\");\n}\ncatch (Recurly.Errors.Validation ex)\n{\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in ex.Error.Params\n    Console.WriteLine($\"Failed validation: {ex.Error.Message}\");\n}\ncatch (Recurly.Errors.ApiError ex)\n{\n    // Use ApiError to catch a generic error from the API\n    Console.WriteLine($\"Unexpected Recurly Error: {ex.Error.Message}\");\n}\n"
          },
          {
            "lang": "Ruby",
            "source": "begin\n  @client.remove_subscription_change(\n    subscription_id: subscription_id\n  )\n  puts \"Removed SubscriptionChange #{subscription_id}\"\nrescue Recurly::Errors::NotFoundError\n  # If the resource was not found, you may want to alert the user or\n  # just return nil\n  puts \"Resource Not Found\"\nend\n"
          },
          {
            "lang": "Java",
            "source": "try {\n    client.removeSubscriptionChange(subscriptionId);\n    System.out.println(\"Removed Subscription change from \" + subscriptionId);\n} catch (ValidationException e) {\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in e.getError().getParams()\n    System.out.println(\"Failed validation: \" + e.getError().getMessage());\n} catch (ApiException e) {\n    // Use ApiException to catch a generic error from the API\n    System.out.println(\"Unexpected Recurly Error: \" + e.getError().getMessage());\n}\n"
          },
          {
            "lang": "PHP",
            "source": "try {\n    $client->removeSubscriptionChange($subscription_id);\n    echo 'Removed Subscription Change: ' . $subscription_id . PHP_EOL;\n} catch (\\Recurly\\Errors\\Validation $e) {\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in err.params\n    var_dump($e);\n} catch (\\Recurly\\RecurlyError $e) {\n    // If we don't know what to do with the err, we should\n    // probably re-raise and let our web framework and logger handle it\n    var_dump($e);\n}\n"
          },
          {
            "lang": "Go",
            "source": "subscriptionChange, err := client.RemoveSubscriptionChange(subID)\nif e, ok := err.(*recurly.Error); ok {\n\tif e.Type == recurly.ErrorTypeNotFound {\n\t\tfmt.Printf(\"Resource not found: %v\", e)\n\t\treturn nil, err\n\t}\n\tfmt.Printf(\"Unexpected Recurly error: %v\", e)\n\treturn nil, err\n}\n\nfmt.Printf(\"Removed Subscription Change: %v\", subscriptionChange)"
          }
        ]
      }
    },
    "/subscriptions/{subscription_id}/change/preview": {
      "post": {
        "tags": [
          "subscription_change"
        ],
        "operationId": "preview_subscription_change",
        "summary": "Preview a new subscription change",
        "description": "Calling this will not save the subscription change or overwrite an existing change.",
        "parameters": [
          {
            "$ref": "#/components/parameters/subscription_id"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SubscriptionChangeCreate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "A subscription change.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SubscriptionChange"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "422": {
            "description": "A validation error such as \"Subscription hasn't been changed\" or error running the verification transaction.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorMayHaveTransaction"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": []
      }
    },
    "/subscriptions/{subscription_id}/invoices": {
      "get": {
        "tags": [
          "invoice"
        ],
        "operationId": "list_subscription_invoices",
        "summary": "List a subscription's invoices",
        "description": "See the [Pagination Guide](/developers/guides/pagination.html) to learn how to use pagination in the API and Client Libraries.",
        "parameters": [
          {
            "$ref": "#/components/parameters/subscription_id"
          },
          {
            "$ref": "#/components/parameters/ids"
          },
          {
            "$ref": "#/components/parameters/invoice_state"
          },
          {
            "$ref": "#/components/parameters/limit"
          },
          {
            "$ref": "#/components/parameters/order"
          },
          {
            "$ref": "#/components/parameters/sort_dates"
          },
          {
            "$ref": "#/components/parameters/filter_begin_time"
          },
          {
            "$ref": "#/components/parameters/filter_end_time"
          },
          {
            "$ref": "#/components/parameters/filter_invoice_type"
          }
        ],
        "responses": {
          "200": {
            "description": "A list of the subscription's invoices.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/InvoiceList"
                }
              }
            }
          },
          "400": {
            "description": "Invalid or unpermitted parameter.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site or subscription ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": [
          {
            "lang": "Node.js",
            "source": "const invoices = client.listSubscriptionInvoices(subscriptionId, { params: { limit: 200 } })\n\nfor await (const invoice of invoices.each()) {\n  console.log(invoice.number)\n}\n"
          },
          {
            "lang": "Python",
            "source": "params = {\"limit\": 200}\ninvoices = client.list_subscription_invoices(subscription_id, params=params).items()\nfor invoice in invoices:\n    print(invoice.number)\n"
          },
          {
            "lang": ".NET",
            "source": "var subscriptionInvoices = client.ListSubscriptionInvoices(subscriptionId);\nforeach(Invoice invoice in subscriptionInvoices)\n{\n    Console.WriteLine(invoice.Number);\n}\n"
          },
          {
            "lang": "Ruby",
            "source": "params = {\n  limit: 200\n}\ninvoices = @client.list_subscription_invoices(\n  subscription_id: subscription_id,\n  params: params\n)\ninvoices.each do |invoice|\n  puts \"Invoice: #{invoice.number}\"\nend\n"
          },
          {
            "lang": "Java",
            "source": "QueryParams params = new QueryParams();\nparams.setLimit(200); // Pull 200 records at a time\nfinal Pager<Invoice> invoices = client.listSubscriptionInvoices(subscriptionId, params);\n\nfor (Invoice invoice : invoices) {\n    System.out.println(invoice.getNumber());\n}\n"
          },
          {
            "lang": "PHP",
            "source": "$options = [\n  'params' => [\n    'limit' => 200\n  ]\n];\n$subscription_invoices = $client->listSubscriptionInvoices($subscription_id, $options);\n\nforeach($subscription_invoices as $sub_invoice) {\n  echo 'Subscription Invoice: ' . $sub_invoice->getNumber() . PHP_EOL;\n}\n"
          },
          {
            "lang": "Go",
            "source": "listParams := &recurly.ListSubscriptionInvoicesParams{\n\tSort:  recurly.String(\"created_at\"),\n\tOrder: recurly.String(\"desc\"),\n\tLimit: recurly.Int(200),\n}\nsubInvoices, err := client.ListSubscriptionInvoices(subID, listParams)\nif err != nil {\n\tfmt.Println(\"Unexpected error: %v\", err)\n\treturn\n}\n\nfor subInvoices.HasMore() {\n\terr := subInvoices.Fetch()\n\tif e, ok := err.(*recurly.Error); ok {\n\t\tfmt.Printf(\"Failed to retrieve next page: %v\", e)\n\t\tbreak\n\t}\n\tfor i, invoice := range subInvoices.Data() {\n\t\tfmt.Printf(\"Subscription Invoice %3d: %s\\n\",\n\t\t\ti,\n\t\t\tinvoice.Id,\n\t\t)\n\t}\n}"
          }
        ]
      }
    },
    "/subscriptions/{subscription_id}/line_items": {
      "get": {
        "tags": [
          "line_item"
        ],
        "operationId": "list_subscription_line_items",
        "summary": "List a subscription's line items",
        "description": "See the [Pagination Guide](/developers/guides/pagination.html) to learn how to use pagination in the API and Client Libraries.",
        "parameters": [
          {
            "$ref": "#/components/parameters/subscription_id"
          },
          {
            "$ref": "#/components/parameters/ids"
          },
          {
            "$ref": "#/components/parameters/limit"
          },
          {
            "$ref": "#/components/parameters/order"
          },
          {
            "$ref": "#/components/parameters/sort_dates"
          },
          {
            "$ref": "#/components/parameters/filter_begin_time"
          },
          {
            "$ref": "#/components/parameters/filter_end_time"
          },
          {
            "$ref": "#/components/parameters/filter_line_item_original"
          },
          {
            "$ref": "#/components/parameters/filter_line_item_state"
          },
          {
            "$ref": "#/components/parameters/filter_line_item_type"
          }
        ],
        "responses": {
          "200": {
            "description": "A list of the subscription's line items.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LineItemList"
                }
              }
            }
          },
          "400": {
            "description": "Invalid or unpermitted parameter.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site or subscription ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": [
          {
            "lang": "Node.js",
            "source": "const lineItems = client.listSubscriptionLineItems(subscriptionId, { params: { limit: 200 } })\n\nfor await (const lineItem of lineItems.each()) {\n  console.log(lineItem.id)\n}\n"
          },
          {
            "lang": "Python",
            "source": "params = {\"limit\": 200}\nline_items = client.list_subscription_line_items(subscription_id, params=params).items()\nfor line_item in line_items:\n    print(line_item.id)\n"
          },
          {
            "lang": ".NET",
            "source": "var subscriptionLineItems = client.ListSubscriptionLineItems(subscriptionId);\nforeach(LineItem lineItem in subscriptionLineItems)\n{\n    Console.WriteLine(lineItem.Id);\n}\n"
          },
          {
            "lang": "Ruby",
            "source": "params = {\n  limit: 200\n}\nline_items = @client.list_subscription_line_items(\n  subscription_id: subscription_id,\n  params: params\n)\nline_items.each do |line_item|\n  puts \"LineItem: #{line_item.id}\"\nend\n"
          },
          {
            "lang": "Java",
            "source": "QueryParams params = new QueryParams();\nparams.setLimit(200); // Pull 200 records at a time\nfinal Pager<LineItem> lineItems = client.listSubscriptionLineItems(subscriptionId, params);\n\nfor (LineItem lineItem : lineItems) {\n    System.out.println(lineItem.getId());\n}\n"
          },
          {
            "lang": "PHP",
            "source": "$options = [\n  'params' => [\n    'limit' => 200\n  ]\n];\n$subscription_line_items = $client->listSubscriptionLineItems($subscription_id, $options);\n\nforeach($subscription_line_items as $line_item) {\n  echo 'Subscription Invoice: ' . $line_item->getId() . PHP_EOL;\n}\n"
          },
          {
            "lang": "Go",
            "source": "listParams := &recurly.ListSubscriptionLineItemsParams{\n\tSort:  recurly.String(\"created_at\"),\n\tOrder: recurly.String(\"desc\"),\n\tLimit: recurly.Int(200),\n}\nsubLineItems, err := client.ListSubscriptionLineItems(subID, listParams)\nif err != nil {\n\tfmt.Println(\"Unexpected error: %v\", err)\n\treturn\n}\n\nfor subLineItems.HasMore() {\n\terr := subLineItems.Fetch()\n\tif e, ok := err.(*recurly.Error); ok {\n\t\tfmt.Printf(\"Failed to retrieve next page: %v\", e)\n\t\tbreak\n\t}\n\tfor i, lineItem := range subLineItems.Data() {\n\t\tfmt.Printf(\"Subscription Line Item %3d: %s\\n\",\n\t\t\ti,\n\t\t\tlineItem.Id,\n\t\t)\n\t}\n}"
          }
        ]
      }
    },
    "/subscriptions/{subscription_id}/coupon_redemptions": {
      "get": {
        "tags": [
          "coupon_redemption"
        ],
        "operationId": "list_subscription_coupon_redemptions",
        "summary": "List the coupon redemptions for a subscription",
        "description": "See the [Pagination Guide](/developers/guides/pagination.html) to learn how to use pagination in the API and Client Libraries.",
        "parameters": [
          {
            "$ref": "#/components/parameters/subscription_id"
          },
          {
            "$ref": "#/components/parameters/ids"
          },
          {
            "$ref": "#/components/parameters/sort_dates"
          },
          {
            "$ref": "#/components/parameters/filter_begin_time"
          },
          {
            "$ref": "#/components/parameters/filter_end_time"
          }
        ],
        "responses": {
          "200": {
            "description": "A list of the the coupon redemptions on a subscription.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CouponRedemptionList"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site or subscription ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": [
          {
            "lang": "Node.js",
            "source": "const redemptions = client.listSubscriptionCouponRedemptions(subscriptionId, { params: { limit: 200 } })\n\nfor await (const redemption of redemptions.each()) {\n  console.log(redemption.id)\n}\n"
          },
          {
            "lang": "Python",
            "source": "params = {\"limit\": 200}\nredemptions = client.list_subscription_coupon_redemptions(\n    subscription_id, params=params\n).items()\nfor redemption in redemptions:\n    print(redemption.uuid)\n"
          },
          {
            "lang": ".NET",
            "source": "var subscriptionCouponRedemptions = client.ListSubscriptionCouponRedemptions(subscriptionId);\nforeach(CouponRedemption redemption in subscriptionCouponRedemptions)\n{\n    Console.WriteLine(redemption.Id);\n}\n"
          },
          {
            "lang": "Ruby",
            "source": "params = {\n  limit: 200\n}\ncoupon_redemptions = @client.list_subscription_coupon_redemptions(\n  subscription_id: subscription_id,\n  params: params\n)\ncoupon_redemptions.each do |redemption|\n  puts \"CouponRedemption: #{redemption.id}\"\nend\n"
          },
          {
            "lang": "Java",
            "source": "QueryParams params = new QueryParams();\nparams.setLimit(200); // Pull 200 records at a time\nfinal Pager<CouponRedemption> redemptions = client.listSubscriptionCouponRedemptions(subscriptionId, params);\n\nfor (CouponRedemption redemption : redemptions) {\n    System.out.println(redemption.getId());\n}\n"
          },
          {
            "lang": "PHP",
            "source": "$options = [\n  'params' => [\n    'limit' => 200\n  ]\n];\n$subscription_coupon_redemptions = $client->listSubscriptionCouponRedemptions($subscription_id, $options);\n\nforeach($subscription_coupon_redemptions as $redemption) {\n  echo 'Subscription Coupon Redemption: ' . $redemption->getId() . PHP_EOL;\n}\n"
          },
          {
            "lang": "Go",
            "source": "listParams := &recurly.ListSubscriptionCouponRedemptionsParams{\n\tSort: recurly.String(\"created_at\"),\n}\nsubCouponRedemptions, err := client.ListSubscriptionCouponRedemptions(subID, listParams)\nif err != nil {\n\tfmt.Println(\"Unexpected error: %v\", err)\n\treturn\n}\n\nfor subCouponRedemptions.HasMore() {\n\terr := subCouponRedemptions.Fetch()\n\tif e, ok := err.(*recurly.Error); ok {\n\t\tfmt.Printf(\"Failed to retrieve next page: %v\", e)\n\t\tbreak\n\t}\n\tfor i, redemption := range subCouponRedemptions.Data() {\n\t\tfmt.Printf(\"Subscription Coupon Redemption %3d: %s\\n\",\n\t\t\ti,\n\t\t\tredemption.Id,\n\t\t)\n\t}\n}"
          }
        ]
      }
    },
    "/subscriptions/{subscription_id}/add_ons/{add_on_id}/usage": {
      "get": {
        "tags": [
          "usage"
        ],
        "operationId": "list_usage",
        "summary": "List a subscription add-on's usage records",
        "parameters": [
          {
            "$ref": "#/components/parameters/subscription_id"
          },
          {
            "$ref": "#/components/parameters/add_on_id"
          },
          {
            "$ref": "#/components/parameters/ids"
          },
          {
            "$ref": "#/components/parameters/limit"
          },
          {
            "$ref": "#/components/parameters/order"
          },
          {
            "$ref": "#/components/parameters/usage_sort_dates"
          },
          {
            "$ref": "#/components/parameters/filter_usage_begin_time"
          },
          {
            "$ref": "#/components/parameters/filter_usage_end_time"
          },
          {
            "$ref": "#/components/parameters/billing_status"
          }
        ],
        "responses": {
          "200": {
            "description": "A list of the subscription add-on's usage records.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UsageList"
                }
              }
            }
          },
          "400": {
            "description": "Invalid or unpermitted parameter.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site or subscription ID or add-on id.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": []
      },
      "post": {
        "tags": [
          "usage"
        ],
        "operationId": "create_usage",
        "summary": "Log a usage record on this subscription add-on",
        "parameters": [
          {
            "$ref": "#/components/parameters/subscription_id"
          },
          {
            "$ref": "#/components/parameters/add_on_id"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UsageCreate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "The created usage record.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Usage"
                }
              }
            }
          },
          "400": {
            "description": "Invalid or unpermitted parameter.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site or subscription ID or add-on id.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "422": {
            "description": "A validation error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": []
      }
    },
    "/usage/{usage_id}": {
      "get": {
        "tags": [
          "usage"
        ],
        "operationId": "get_usage",
        "summary": "Get a usage record",
        "parameters": [
          {
            "$ref": "#/components/parameters/usage_id"
          }
        ],
        "responses": {
          "200": {
            "description": "The usage record.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Usage"
                }
              }
            }
          },
          "400": {
            "description": "Invalid or unpermitted parameter.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site or subscription, add-on, or usage ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": []
      },
      "put": {
        "tags": [
          "usage"
        ],
        "operationId": "update_usage",
        "summary": "Update a usage record",
        "parameters": [
          {
            "$ref": "#/components/parameters/usage_id"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UsageCreate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "The updated usage record.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Usage"
                }
              }
            }
          },
          "400": {
            "description": "Invalid or unpermitted parameter.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site or subscription, add-on, or usage ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "422": {
            "description": "A validation error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": []
      },
      "delete": {
        "tags": [
          "usage"
        ],
        "operationId": "remove_usage",
        "summary": "Delete a usage record.",
        "parameters": [
          {
            "$ref": "#/components/parameters/usage_id"
          }
        ],
        "responses": {
          "204": {
            "description": "Usage was successfully deleted."
          },
          "400": {
            "description": "Invalid or unpermitted parameter.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site or subscription, add-on, or usage ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "422": {
            "description": "A validation error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": []
      }
    },
    "/transactions": {
      "get": {
        "tags": [
          "transaction"
        ],
        "operationId": "list_transactions",
        "summary": "List a site's transactions",
        "description": "See the [Pagination Guide](/developers/guides/pagination.html) to learn how to use pagination in the API and Client Libraries.",
        "parameters": [
          {
            "$ref": "#/components/parameters/ids"
          },
          {
            "$ref": "#/components/parameters/limit"
          },
          {
            "$ref": "#/components/parameters/order"
          },
          {
            "$ref": "#/components/parameters/sort_dates"
          },
          {
            "$ref": "#/components/parameters/filter_begin_time"
          },
          {
            "$ref": "#/components/parameters/filter_end_time"
          },
          {
            "$ref": "#/components/parameters/filter_transaction_type"
          },
          {
            "$ref": "#/components/parameters/filter_transaction_success"
          }
        ],
        "responses": {
          "200": {
            "description": "A list of the site's transactions.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TransactionList"
                }
              }
            }
          },
          "400": {
            "description": "Invalid or unpermitted parameter.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site or subscription ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": [
          {
            "lang": "Node.js",
            "source": "const transactions = client.listTransactions({ params: { limit: 200 } })\n\nfor await (const transaction of transactions.each()) {\n  console.log(transaction.uuid)\n}\n"
          },
          {
            "lang": "Python",
            "source": "params = {\"limit\": 200}\ntransactions = client.list_transactions(params=params).items()\nfor transaction in transactions:\n    print(transaction.uuid)\n"
          },
          {
            "lang": ".NET",
            "source": "var optionalParams = new ListTransactionsParams()\n{\n    Limit = 200\n};\nvar transactions = client.ListTransactions(optionalParams);\nforeach(Transaction transaction in transactions)\n{\n    Console.WriteLine(transaction.Uuid);\n}\n"
          },
          {
            "lang": "Ruby",
            "source": "params = {\n  limit: 200\n}\ntransactions = @client.list_transactions(params: params)\ntransactions.each do |transaction|\n  puts \"Transaction: #{transaction.uuid}\"\nend\n"
          },
          {
            "lang": "Java",
            "source": "QueryParams params = new QueryParams();\nparams.setLimit(200); // Pull 200 records at a time\nfinal Pager<Transaction> transactions = client.listTransactions(params);\n\nfor (Transaction transaction : transactions) {\n    System.out.println(transaction.getUuid());\n}\n"
          },
          {
            "lang": "PHP",
            "source": "$options = [\n  'params' => [\n    'limit' => 200\n  ]\n];\n$transactions = $client->listTransactions($options);\n\nforeach($transactions as $transaction) {\n  echo 'Transaction: ' . $transaction->getUuid() . PHP_EOL;\n}\n"
          },
          {
            "lang": "Go",
            "source": "listParams := &recurly.ListTransactionsParams{\n\tSort:  recurly.String(\"created_at\"),\n\tOrder: recurly.String(\"desc\"),\n\tLimit: recurly.Int(200),\n}\ntransactions, err := client.ListTransactions(listParams)\nif err != nil {\n\tfmt.Println(\"Unexpected error: %v\", err)\n\treturn\n}\n\nfor transactions.HasMore() {\n\terr := transactions.Fetch()\n\tif e, ok := err.(*recurly.Error); ok {\n\t\tfmt.Printf(\"Failed to retrieve next page: %v\", e)\n\t\tbreak\n\t}\n\tfor i, transaction := range transactions.Data() {\n\t\tfmt.Printf(\"Transaction %3d: %s\\n\",\n\t\t\ti,\n\t\t\ttransaction.Id,\n\t\t)\n\t}\n}"
          }
        ]
      }
    },
    "/transactions/{transaction_id}": {
      "get": {
        "tags": [
          "transaction"
        ],
        "operationId": "get_transaction",
        "summary": "Fetch a transaction",
        "parameters": [
          {
            "$ref": "#/components/parameters/transaction_id"
          }
        ],
        "responses": {
          "200": {
            "description": "A transaction.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Transaction"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site or transaction ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": [
          {
            "lang": "Node.js",
            "source": "try {\n  const transaction = await client.getTransaction(transactionId)\n  console.log('Fetched transaction: ', transaction.uuid)\n} catch (err) {\n  if (err instanceof recurly.errors.NotFoundError) {\n    // If the request was not found, you may want to alert the user or\n    // just return null\n    console.log('Resource Not Found')\n  } else {\n    // If we don't know what to do with the err, we should\n    // probably re-raise and let our web framework and logger handle it\n    console.log('Unknown Error: ', err)\n  }\n}\n"
          },
          {
            "lang": "Python",
            "source": "try:\n  transaction = client.get_transaction(transaction_id)\n  print(\"Got Transaction %s\" % transaction)\nexcept recurly.errors.NotFoundError:\n    # If the resource was not found, you may want to alert the user or\n    # just return nil\n    print(\"Resource Not Found\")\n"
          },
          {
            "lang": ".NET",
            "source": "try\n{\n    Transaction transaction = client.GetTransaction(transactionId);\n    Console.WriteLine($\"Fetched transaction {transaction.Uuid}\");\n}\ncatch (Recurly.Errors.NotFound ex)\n{\n    // If the resource was not found\n    // we may want to alert the user or just return null\n    Console.WriteLine($\"Resource Not Found: {ex.Error.Message}\");\n}\ncatch (Recurly.Errors.ApiError ex)\n{\n    // Use ApiError to catch a generic error from the API\n    Console.WriteLine($\"Unexpected Recurly Error: {ex.Error.Message}\");\n}\n"
          },
          {
            "lang": "Ruby",
            "source": "begin\n  transaction = @client.get_transaction(transaction_id: transaction_id)\n  puts \"Got Transaction #{transaction}\"\nrescue Recurly::Errors::NotFoundError\n  # If the resource was not found, you may want to alert the user or\n  # just return nil\n  puts \"Resource Not Found\"\nend\n"
          },
          {
            "lang": "Java",
            "source": "try {\n    Transaction transaction = client.getTransaction(transactionId);\n    System.out.println(\"Fetched transaction \" + transaction.getUuid());\n} catch (NotFoundException e) {\n    // If the resource was not found\n    // we may want to alert the user or just return null\n    System.out.println(\"Resource Not Found: \" + e.getError().getMessage());\n} catch (ApiException e) {\n    // Use ApiException to catch a generic error from the API\n    System.out.println(\"Unexpected Recurly Error: \" + e.getError().getMessage());\n}\n"
          },
          {
            "lang": "PHP",
            "source": "try {\n    $transaction = $client->getTransaction($transaction_id);\n\n    echo 'Got Transaction:' . PHP_EOL;\n    var_dump($transaction);\n} catch (\\Recurly\\Errors\\NotFound $e) {\n    // Could not find the resource, you may want to inform the user\n    // or just return a NULL\n    echo 'Could not find resource.' . PHP_EOL;\n    var_dump($e);\n} catch (\\Recurly\\RecurlyError $e) {\n    // Something bad happened... tell the user so that they can fix it?\n    echo 'Some unexpected Recurly error happened. Try again later.' . PHP_EOL;\n}\n"
          },
          {
            "lang": "Go",
            "source": "transaction, err := client.GetTransaction(transactionID)\nif e, ok := err.(*recurly.Error); ok {\n\tif e.Type == recurly.ErrorTypeNotFound {\n\t\tfmt.Printf(\"Resource not found: %v\", e)\n\t\treturn nil, err\n\t}\n\tfmt.Printf(\"Unexpected Recurly error: %v\", e)\n\treturn nil, err\n}\nfmt.Printf(\"Fetched Transaction: %v\", transaction.Id)"
          }
        ]
      }
    },
    "/unique_coupon_codes/{unique_coupon_code_id}": {
      "parameters": [
        {
          "$ref": "#/components/parameters/unique_coupon_code_id"
        }
      ],
      "get": {
        "tags": [
          "unique_coupon_code"
        ],
        "operationId": "get_unique_coupon_code",
        "summary": "Fetch a unique coupon code",
        "responses": {
          "200": {
            "description": "A unique coupon code.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UniqueCouponCode"
                }
              }
            }
          },
          "400": {
            "description": "Bad request; perhaps missing or invalid parameters.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": []
      },
      "delete": {
        "tags": [
          "unique_coupon_code"
        ],
        "operationId": "deactivate_unique_coupon_code",
        "summary": "Deactivate a unique coupon code",
        "description": "Expire a unique code, making that specific code no longer redeemable. The parent bulk coupon will not be affected.",
        "responses": {
          "200": {
            "description": "A unique coupon code.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UniqueCouponCode"
                }
              }
            }
          },
          "400": {
            "description": "Bad request; perhaps missing or invalid parameters.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "422": {
            "description": "Unique coupon code cannot be deactivated for the provided reason.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": []
      }
    },
    "/unique_coupon_codes/{unique_coupon_code_id}/restore": {
      "parameters": [
        {
          "$ref": "#/components/parameters/unique_coupon_code_id"
        }
      ],
      "put": {
        "tags": [
          "unique_coupon_code"
        ],
        "operationId": "reactivate_unique_coupon_code",
        "summary": "Restore a unique coupon code",
        "responses": {
          "200": {
            "description": "A unique coupon code.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UniqueCouponCode"
                }
              }
            }
          },
          "400": {
            "description": "Bad request; perhaps missing or invalid parameters.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "422": {
            "description": "Unique coupon code cannot be restored for the provided reason.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": []
      }
    },
    "/purchases": {
      "post": {
        "tags": [
          "purchase"
        ],
        "operationId": "create_purchase",
        "summary": "Create a new purchase",
        "description": "A purchase is a checkout containing at least one or more subscriptions or one-time charges (line items) and supports both coupon and gift card redemptions. All items purchased will be on one invoice and paid for with one transaction.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PurchaseCreate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Returns the new invoices",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/InvoiceCollection"
                }
              }
            }
          },
          "400": {
            "description": "Bad request; perhaps missing or invalid parameters.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "422": {
            "description": "Purchase cannot be completed for the specified reason.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": [
          {
            "lang": "Node.js",
            "source": "try {\n  let purchaseReq = {\n    currency: 'USD',\n    account: {\n      code: accountCode,\n      firstName: 'Benjamin',\n      lastName: 'Du Monde',\n      billingInfo: {\n        tokenId: rjsTokenId\n      }\n    },\n    subscriptions: [\n      { planCode: planCode },\n    ]\n  }\n  let invoiceCollection = await client.createPurchase(purchaseReq)\n  console.log('Created Charge Invoice: ', invoiceCollection.chargeInvoice)\n  console.log('Created Credit Invoices: ', invoiceCollection.creditInvoices)\n} catch (err) {\n  if (err instanceof recurly.errors.ValidationError) {\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in err.params\n    console.log('Failed validation', err.params)\n  } else {\n    // If we don't know what to do with the err, we should\n    // probably re-raise and let our web framework and logger handle it\n    console.log('Unknown Error: ', err)\n  }\n}\n"
          },
          {
            "lang": "Python",
            "source": "try:\n    purchase = {\n        \"currency\": \"USD\",\n        \"account\": {\n            \"code\": account_code,\n            \"first_name\": \"Benjamin\",\n            \"last_name\": \"Du Monde\",\n            \"billing_info\": {\"token_id\": rjs_token_id},\n        },\n        \"subscriptions\": [{\"plan_code\": plan_code}],\n    }\n    invoice_collection = client.create_purchase(purchase)\n    print(\"Created Charge Invoice %s\" % invoice_collection.charge_invoice)\n    print(\"Created Credit Invoices %s\" % invoice_collection.credit_invoices)\nexcept recurly.errors.ValidationError as e:\n    # If the request was invalid, you may want to tell your user\n    # why. You can find the invalid params and reasons in e.error.params\n    print(\"ValidationError: %s\" % e.error.message)\n    print(e.error.params)\n"
          },
          {
            "lang": ".NET",
            "source": "try\n{\n    var purchaseReq = new PurchaseCreate()\n    {\n        Currency = \"USD\",\n        Account = new AccountPurchase()\n        {\n            Code = accountCode,\n            FirstName = \"Benjamin\",\n            LastName = \"Du Monde\",\n            BillingInfo = new BillingInfoCreate()\n            {\n                TokenId = rjsTokenId\n            }\n        },\n        Subscriptions = new List<SubscriptionPurchase>()\n        {\n            new SubscriptionPurchase() { PlanCode = planCode }\n        }\n    };\n    InvoiceCollection collection = client.CreatePurchase(purchaseReq);\n    Console.WriteLine($\"Created ChargeInvoice with Number: {collection.ChargeInvoice.Number}\");\n}\ncatch (Recurly.Errors.Validation ex)\n{\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in ex.Error.Params\n    Console.WriteLine($\"Failed validation: {ex.Error.Message}\");\n}\ncatch (Recurly.Errors.ApiError ex)\n{\n    // Use ApiError to catch a generic error from the API\n    Console.WriteLine($\"Unexpected Recurly Error: {ex.Error.Message}\");\n}\n"
          },
          {
            "lang": "Ruby",
            "source": "begin\n  purchase = {\n    currency: \"USD\",\n    account: {\n      code: account_code,\n      first_name: \"Benjamin\",\n      last_name: \"Du Monde\",\n      billing_info: {\n        token_id: rjs_token_id\n      },\n    },\n    subscriptions: [\n      { plan_code: plan_code }\n    ]\n  }\n  invoice_collection = @client.create_purchase(\n    body: purchase\n  )\n  puts \"Created Charge Invoice #{invoice_collection.charge_invoice}\"\n  puts \"Created Credit Invoices #{invoice_collection.credit_invoices}\"\nrescue Recurly::Errors::ValidationError => e\n  # If the request was invalid, you may want to tell your user\n  # why. You can find the invalid params and reasons in e.recurly_error.params\n  puts \"ValidationError: #{e.recurly_error.params}\"\nend\n"
          },
          {
            "lang": "Java",
            "source": "try {\n\n    AccountPurchase account = new AccountPurchase();\n    account.setCode(accountCode);\n    account.setFirstName(\"Benjamin\");\n    account.setLastName(\"DuMonde\");\n\n    BillingInfoCreate billing = new BillingInfoCreate();\n    billing.setTokenId(rjsTokenId);\n    account.setBillingInfo(billing);\n\n    List<SubscriptionPurchase> subscriptions = new ArrayList<SubscriptionPurchase>();\n    SubscriptionPurchase sub = new SubscriptionPurchase();\n    sub.setPlanCode(planCode);\n    subscriptions.add(sub);\n\n    PurchaseCreate purchase = new PurchaseCreate();\n    purchase.setCurrency(\"USD\");\n    purchase.setAccount(account);\n    purchase.setSubscriptions(subscriptions);\n\n    InvoiceCollection collection = client.createPurchase(purchase);\n    System.out.println(\"Created ChargeInvoice with Id: \" + collection.getChargeInvoice().getId());\n} catch (ValidationException e) {\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in e.getError().getParams()\n    System.out.println(\"Failed validation: \" + e.getError().getMessage());\n    System.out.println(\"Params: \" + e.getError().getParams());\n} catch (TransactionException e) {\n    TransactionError tError = e.getError().getTransactionError();\n    if (tError.getCategory() == Constants.ErrorCategory.THREE_D_SECURE_ACTION_REQUIRED) {\n        String actionTokenId = tError.getThreeDSecureActionTokenId();\n        System.out.println(\"Got 3DSecure TransactionError token: \" + actionTokenId);\n    }\n}\ncatch (ApiException e) {\n    // Use ApiException to catch a generic error from the API\n    System.out.println(\"Unexpected Recurly Error: \" + e.getError().getMessage());\n}\n"
          },
          {
            "lang": "PHP",
            "source": "try {\n    $purchase_create = [\n        \"currency\" => \"USD\",\n        \"account\" => [\n            \"code\" => $account_code,\n            \"first_name\" => \"Douglas\",\n            \"last_name\" => \"Du Monde\",\n            \"billing_info\" => [\n                \"token_id\" => $rjs_token_id\n            ],\n        ],\n        \"subscriptions\" => [\n            [\n                \"plan_code\" => $plan_code\n            ]\n        ]\n    ];\n    $invoice_collection = $client->createPurchase($purchase_create);\n    echo 'Created Invoices:' . PHP_EOL;\n    var_dump($invoice_collection);\n} catch (\\Recurly\\Errors\\Validation $e) {\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in err.params\n    var_dump($e);\n} catch (\\Recurly\\RecurlyError $e) {\n    // If we don't know what to do with the err, we should\n    // probably re-raise and let our web framework and logger handle it\n    var_dump($e);\n}\n"
          },
          {
            "lang": "Go",
            "source": "purchaseReq := &recurly.PurchaseCreate{\n\tCurrency: recurly.String(\"USD\"),\n\tAccount: &recurly.AccountPurchase{\n\t\tCode: recurly.String(accountCode),\n\t},\n\tSubscriptions: []recurly.SubscriptionPurchase{\n\t\t{\n\t\t\tPlanCode:     recurly.String(planCode),\n\t\t\tNextBillDate: recurly.Time(time.Date(2078, time.November, 10, 23, 0, 0, 0, time.UTC)),\n\t\t},\n\t},\n\tShipping: &recurly.ShippingPurchase{\n\t\tAddressId: recurly.String(shippingAddressID),\n\t},\n}\n\ncollection, err := client.CreatePurchase(purchaseReq)\nif e, ok := err.(*recurly.Error); ok {\n\tif e.Type == recurly.ErrorTypeValidation {\n\t\tfmt.Printf(\"Failed validation: %v\", e)\n\t\treturn nil, err\n\t}\n\tfmt.Printf(\"Unexpected Recurly error: %v\", e)\n\treturn nil, err\n}\nfmt.Printf(\"Created Purchase: %s\", collection.ChargeInvoice.Number)"
          }
        ]
      }
    },
    "/purchases/preview": {
      "post": {
        "tags": [
          "purchase"
        ],
        "operationId": "preview_purchase",
        "summary": "Preview a new purchase",
        "description": "A purchase is a checkout containing at least one or more subscriptions or one-time charges (line items) and supports both coupon and gift card redemptions. All items purchased will be on one invoice and paid for with one transaction.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PurchaseCreate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Returns preview of the new invoices",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/InvoiceCollection"
                }
              }
            }
          },
          "400": {
            "description": "Bad request; perhaps missing or invalid parameters.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "422": {
            "description": "Purchase cannot be previewed for the specified reason.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": [
          {
            "lang": "Node.js",
            "source": "try {\n  let purchaseReq = {\n    currency: 'USD',\n    account: {\n      firstName: 'Benjamin',\n      lastName: 'Du Monde',\n      code: accountCode,\n      billingInfo: {\n        tokenId: rjsTokenId\n      }\n    },\n    subscriptions: [\n      { planCode: planCode },\n    ]\n  }\n  let invoiceCollection = await client.previewPurchase(purchaseReq)\n  console.log('Preview Charge Invoice: ', invoiceCollection.chargeInvoice)\n  console.log('Preview Credit Invoices: ', invoiceCollection.creditInvoices)\n} catch (err) {\n  if (err instanceof recurly.errors.ValidationError) {\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in err.params\n    console.log('Failed validation', err.params)\n  } else {\n    // If we don't know what to do with the err, we should\n    // probably re-raise and let our web framework and logger handle it\n    console.log('Unknown Error: ', err)\n  }\n}\n"
          },
          {
            "lang": "Python",
            "source": "try:\n    purchase = {\n        \"currency\": \"USD\",\n        \"account\": {\n            \"code\": account_code,\n            \"first_name\": \"Benjamin\",\n            \"last_name\": \"Du Monde\",\n            \"billing_info\": {\"token_id\": rjs_token_id},\n        },\n        \"subscriptions\": [{\"plan_code\": plan_code}],\n    }\n    invoice_collection = client.preview_purchase(purchase)\n    print(\"Preview Charge Invoice %s\" % invoice_collection.charge_invoice)\n    print(\"Preview Credit Invoices %s\" % invoice_collection.credit_invoices)\nexcept recurly.errors.ValidationError as e:\n    # If the request was invalid, you may want to tell your user\n    # why. You can find the invalid params and reasons in e.error.params\n    print(\"ValidationError: %s\" % e.error.message)\n    print(e.error.params)\n"
          },
          {
            "lang": ".NET",
            "source": "try\n{\n    var purchaseReq = new PurchaseCreate()\n    {\n        Currency = \"USD\",\n        Account = new AccountPurchase()\n        {\n            Code = accountCode,\n            FirstName = \"Benjamin\",\n            LastName = \"Du Monde\",\n            BillingInfo = new BillingInfoCreate()\n            {\n                TokenId = rjsTokenId\n            }\n        },\n        Subscriptions = new List<SubscriptionPurchase>()\n        {\n            new SubscriptionPurchase() { PlanCode = planCode }\n        }\n    };\n    InvoiceCollection collection = client.PreviewPurchase(purchaseReq);\n    Console.WriteLine($\"Preview ChargeInvoice with Total: {collection.ChargeInvoice.Total}\");\n}\ncatch (Recurly.Errors.Validation ex)\n{\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in ex.Error.Params\n    Console.WriteLine($\"Failed validation: {ex.Error.Message}\");\n}\ncatch (Recurly.Errors.ApiError ex)\n{\n    // Use ApiError to catch a generic error from the API\n    Console.WriteLine($\"Unexpected Recurly Error: {ex.Error.Message}\");\n}\n"
          },
          {
            "lang": "Ruby",
            "source": "begin\n  purchase = {\n    currency: \"USD\",\n    account: {\n      code: account_code,\n      first_name: \"Benjamin\",\n      last_name: \"Du Monde\",\n      billing_info: {\n        token_id: rjs_token_id\n      },\n    },\n    subscriptions: [\n      { plan_code: plan_code }\n    ]\n  }\n  invoice_collection = @client.preview_purchase(\n    body: purchase\n  )\n  puts \"Preview Charge Invoice #{invoice_collection.charge_invoice}\"\n  puts \"Preview Credit Invoices #{invoice_collection.credit_invoices}\"\nrescue Recurly::Errors::ValidationError => e\n  # If the request was invalid, you may want to tell your user\n  # why. You can find the invalid params and reasons in e.recurly_error.params\n  puts \"ValidationError: #{e.recurly_error.params}\"\nend\n"
          },
          {
            "lang": "Java",
            "source": "try {\n\n    AccountPurchase account = new AccountPurchase();\n    account.setCode(accountCode);\n    account.setFirstName(\"Joanna\");\n    account.setLastName(\"DuMonde\");\n\n    BillingInfoCreate billing = new BillingInfoCreate();\n    billing.setTokenId(rjsTokenId);\n    account.setBillingInfo(billing);\n\n    List<SubscriptionPurchase> subscriptions = new ArrayList<SubscriptionPurchase>();\n    SubscriptionPurchase sub = new SubscriptionPurchase();\n    sub.setPlanCode(planCode);\n    subscriptions.add(sub);\n\n    PurchaseCreate purchase = new PurchaseCreate();\n    purchase.setCurrency(\"USD\");\n    purchase.setAccount(account);\n    purchase.setSubscriptions(subscriptions);\n\n    InvoiceCollection collection = client.previewPurchase(purchase);\n    System.out.println(\"Preview Charge Invoice:\" + collection.getChargeInvoice());\n    System.out.println(\"Preview Credit Invoices: \" + collection.getCreditInvoices());\n\n} catch (ValidationException e) {\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in e.getError().getParams()\n    System.out.println(\"Failed validation: \" + e.getError().getMessage());\n    System.out.println(\"Params: \" + e.getError().getParams());\n} catch (ApiException e) {\n    // Use ApiException to catch a generic error from the API\n    System.out.println(\"Unexpected Recurly Error: \" + e.getError().getMessage());\n}\n"
          },
          {
            "lang": "PHP",
            "source": "try {\n    $purchase_preview = [\n        \"currency\" => \"USD\",\n        \"account\" => [\n            \"code\" => $account_code,\n            \"first_name\" => \"Douglas\",\n            \"last_name\" => \"Du Monde\",\n            \"billing_info\" => [\n                \"token_id\" => $rjs_token_id\n            ],\n        ],\n        \"subscriptions\" => [\n            [\n                \"plan_code\" => $plan_code\n            ]\n        ]\n    ];\n    $invoice_collection = $client->previewPurchase($purchase_preview);\n    echo 'Preview Invoices:' . PHP_EOL;\n    var_dump($invoice_collection);\n} catch (\\Recurly\\Errors\\Validation $e) {\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in err.params\n    var_dump($e);\n} catch (\\Recurly\\RecurlyError $e) {\n    // If we don't know what to do with the err, we should\n    // probably re-raise and let our web framework and logger handle it\n    var_dump($e);\n}\n"
          },
          {
            "lang": "Go",
            "source": "purchaseReq := &recurly.PurchaseCreate{\n\tCurrency: recurly.String(\"USD\"),\n\tAccount: &recurly.AccountPurchase{\n\t\tCode: recurly.String(account.Code),\n\t},\n\tSubscriptions: []recurly.SubscriptionPurchase{\n\t\t{\n\t\t\tPlanCode:     recurly.String(plan.Code),\n\t\t\tNextBillDate: recurly.Time(time.Date(2078, time.November, 10, 23, 0, 0, 0, time.UTC)),\n\t\t},\n\t},\n\tShipping: &recurly.ShippingPurchase{\n\t\tAddressId: recurly.String(shippingAddressID),\n\t},\n}\ncollection, err := client.PreviewPurchase(purchaseReq)\nif e, ok := err.(*recurly.Error); ok {\n\tif e.Type == recurly.ErrorTypeValidation {\n\t\tfmt.Printf(\"Failed validation: %v\", e)\n\t\treturn nil, err\n\t}\n\tfmt.Printf(\"Unexpected Recurly error: %v\", e)\n\treturn nil, err\n}\nfmt.Printf(\"Preview Charge Invoice %v\", collection.ChargeInvoice)"
          }
        ]
      }
    },
    "/purchases/pending": {
      "post": {
        "tags": [
          "purchase"
        ],
        "operationId": "create_pending_purchase",
        "summary": "Create a pending purchase",
        "description": "A purchase is a hybrid checkout containing at least one or more subscriptions or one-time charges (adjustments) and supports both coupon and gift card redemptions. All items purchased will be on one invoice and paid for with one transaction. A purchase is only a request data type and is not persistent in Recurly and an invoice collection will be the returned type.\n\nUse for **Adyen HPP** and **Online Banking** transaction requests.\nThis runs the validations but not the transactions.\nThe API request allows the inclusion of the following field: **external_hpp_type** with `'adyen'` in the **billing_info** object.\n\nFor additional information regarding shipping fees, please see https://docs.recurly.com/docs/shipping\n\nNote: an email address is required on the account for a Pending Purchase.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PurchaseCreate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Returns the pending invoice",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/InvoiceCollection"
                }
              }
            }
          },
          "400": {
            "description": "Bad request; perhaps missing or invalid parameters.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "422": {
            "description": "Pending purchase cannot be completed for the specified reason.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": [
          {
            "lang": "Node.js",
            "source": "try {\n  const purchaseReq = {\n    currency: 'EUR',\n    account: {\n      code: accountCode,\n      email: 'example@recurly.com',\n      billingInfo: {\n        firstName: 'Benjamin',\n        lastName: 'Du Monde',\n        onlineBankingPaymentType: 'ideal'\n      },\n    },\n    lineItems: [\n      {\n        currency: 'EUR',\n        unitAmount: 1000,\n        type: 'charge'\n      }\n    ]\n  };\n  const invoiceCollection = await client.createPendingPurchase(purchaseReq)\n  console.log('Created ChargeInvoice with UUID: ', invoiceCollection.chargeInvoice.uuid)\n} catch (err) {\n  if (err instanceof recurly.errors.ValidationError) {\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in err.params\n    console.log('Failed validation', err.params)\n  } else {\n    // If we don't know what to do with the err, we should\n    // probably re-raise and let our web framework and logger handle it\n    console.log('Unknown Error: ', err)\n  }\n}\n"
          },
          {
            "lang": "Python",
            "source": "try:\n    purchase = {\n        \"currency\": \"EUR\",\n        \"account\": {\n            \"code\": account_code,\n            \"email\": \"benjamin@example.com\",\n            \"billing_info\": {\n                \"first_name\": \"Benjamin\",\n                \"last_name\": \"Du Monde\",\n                \"online_banking_payment_type\": \"ideal\"\n            }\n        },\n        \"line_items\": [\n            {\n                \"currency\": \"EUR\",\n                \"unit_amount\": 1000,\n                \"type\": \"charge\"\n            }\n        ],\n    }\n    invoice_collection = client.create_pending_purchase(purchase)\n    print(\"Created ChargeInvoice with UUID %s\" % invoice_collection.charge_invoice.uuid)\nexcept recurly.errors.ValidationError as e:\n    # If the request was invalid, you may want to tell your user\n    # why. You can find the invalid params and reasons in e.error.params\n    print(\"ValidationError: %s\" % e.error.message)\n    print(e.error.params)\n"
          },
          {
            "lang": ".NET",
            "source": "try\n{\n    var purchaseReq = new PurchaseCreate()\n    {\n        Currency = \"EUR\",\n        Account = new AccountPurchase()\n        {\n            Code = accountCode,\n            Email = \"benjamin@example.com\",\n            BillingInfo = new BillingInfoCreate()\n            {\n                FirstName = \"Benjamin\",\n                LastName = \"Du Monde\",\n                OnlineBankingPaymentType = OnlineBankingPaymentType.Ideal\n            }\n        },\n        LineItems = new List<LineItemCreate>()\n        {\n            new LineItemCreate()\n            {\n                Currency = \"EUR\",\n                UnitAmount = 1000,\n                Type = LineItemType.Charge\n            }\n        }\n    };\n    InvoiceCollection collection = client.CreatePendingPurchase(purchaseReq);\n    Console.WriteLine($\"Created ChargeInvoice with UUID: {collection.ChargeInvoice.Uuid}\");\n}\ncatch (Recurly.Errors.Validation ex)\n{\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in ex.Error.Params\n    Console.WriteLine($\"Failed validation: {ex.Error.Message}\");\n}\ncatch (Recurly.Errors.ApiError ex)\n{\n    // Use ApiError to catch a generic error from the API\n    Console.WriteLine($\"Unexpected Recurly Error: {ex.Error.Message}\");\n}\n"
          },
          {
            "lang": "Ruby",
            "source": "begin\n  purchase = {\n    currency: 'EUR',\n    account: {\n      code: account_code,\n      email: 'benjamin@example.com',\n      billing_info: {\n        first_name: 'Benjamin',\n        last_name: 'Du Monde',\n        online_banking_payment_type: 'ideal'\n      },\n    },\n    line_items: [\n      {\n        currency: 'EUR',\n        unit_amount: 1000,\n        type: 'charge'\n      }\n    ]\n  }\n  invoice_collection = @client.create_pending_purchase(body: purchase)\n  puts \"Created ChargeInvoice with UUID: #{invoice_collection.charge_invoice.uuid}\"\nrescue Recurly::Errors::ValidationError => e\n  # If the request was invalid, you may want to tell your user\n  # why. You can find the invalid params and reasons in e.recurly_error.params\n  puts \"ValidationError: #{e.recurly_error.params}\"\nend\n"
          },
          {
            "lang": "Java",
            "source": "try {\n    AccountPurchase account = new AccountPurchase();\n    account.setCode(accountCode);\n    account.setEmail(\"benjamin@example.com\");\n\n    BillingInfoCreate billingInfo = new BillingInfoCreate();\n    billingInfo.setFirstName(\"Benjamin\");\n    billingInfo.setLastName(\"Du Monde\");\n    billingInfo.setOnlineBankingPaymentType(Constants.OnlineBankingPaymentType.IDEAL);\n    account.setBillingInfo(billingInfo);\n\n    List<LineItemCreate> lineItems = new ArrayList<LineItemCreate>();\n    LineItemCreate lineItem = new LineItemCreate();\n    lineItem.setCurrency(\"EUR\");\n    lineItem.setUnitAmount(new BigDecimal(\"1000.0\"));\n    lineItem.setType(Constants.LineItemType.CHARGE);\n    lineItems.add(lineItem);\n\n    PurchaseCreate purchase = new PurchaseCreate();\n    purchase.setCurrency(\"EUR\");\n    purchase.setAccount(account);\n    purchase.setLineItems(lineItems);\n\n    InvoiceCollection collection = client.createPendingPurchase(purchase);\n    System.out.println(\"Created ChargeInvoice with UUID: \" + collection.getChargeInvoice().getUuid());\n} catch (ValidationException e) {\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in e.getError().getParams()\n    System.out.println(\"Failed validation: \" + e.getError().getMessage());\n    System.out.println(\"Params: \" + e.getError().getParams());\n} catch (TransactionException e) {\n    TransactionError tError = e.getError().getTransactionError();\n    if (tError.getCategory() == Constants.ErrorCategory.THREE_D_SECURE_ACTION_REQUIRED) {\n        String actionTokenId = tError.getThreeDSecureActionTokenId();\n        System.out.println(\"Got 3DSecure TransactionError token: \" + actionTokenId);\n    }\n}\ncatch (ApiException e) {\n    // Use ApiException to catch a generic error from the API\n    System.out.println(\"Unexpected Recurly Error: \" + e.getError().getMessage());\n}\n"
          },
          {
            "lang": "PHP",
            "source": "try {\n    $purchase_create = [\n        \"currency\" => \"EUR\",\n        \"account\" => [\n            \"code\" => $account_code,\n            \"email\" => \"benjamin@example.com\",\n            \"billing_info\" => [\n                \"first_name\" => \"Benjamin\",\n                \"last_name\" => \"Du Monde\",\n                \"online_banking_payment_type\" => \"ideal\"\n            ],\n        ],\n        \"line_items\" => [\n            [\n                \"currency\" => \"EUR\",\n                \"unit_amount\" => 1000,\n                \"type\" => \"charge\",\n            ]\n        ]\n    ];\n    $invoice_collection = $client->createPendingPurchase($purchase_create);\n    echo 'Created ChargeInvoice with UUID' . $invoice_collection->getChargeInvoice()->getUuid() . PHP_EOL;\n} catch (\\Recurly\\Errors\\Validation $e) {\n    // If the request was not valid, you may want to tell your user\n    // why. You can find the invalid params and reasons in err.params\n    var_dump($e);\n} catch (\\Recurly\\RecurlyError $e) {\n    // If we don't know what to do with the err, we should\n    // probably re-raise and let our web framework and logger handle it\n    var_dump($e);\n}\n"
          },
          {
            "lang": "Go",
            "source": "purchaseReq := &recurly.PurchaseCreate{\n\tCurrency: recurly.String(\"EUR\"),\n\tAccount: &recurly.AccountPurchase{\n\t\tCode:  recurly.String(accountCode),\n\t\tEmail: recurly.String(\"benjamin@example.com\"),\n\t\tBillingInfo: &recurly.BillingInfoCreate{\n\t\t\tFirstName:                recurly.String(\"Benjamin\"),\n\t\t\tLastName:                 recurly.String(\"Du Monde\"),\n\t\t\tOnlineBankingPaymentType: recurly.String(\"ideal\"),\n\t\t},\n\t},\n\tLineItems: []recurly.LineItemCreate{\n\t\t{\n\t\t\tCurrency:   recurly.String(\"EUR\"),\n\t\t\tUnitAmount: recurly.Float(1000),\n\t\t\tType:       recurly.String(\"charge\"),\n\t\t},\n\t},\n}\ncollection, err := client.CreatePendingPurchase(purchaseReq)\nif e, ok := err.(*recurly.Error); ok {\n\tif e.Type == recurly.ErrorTypeValidation {\n\t\tfmt.Printf(\"Failed validation: %v\", e)\n\t\treturn nil, err\n\t}\n\n\tfmt.Printf(\"Unexpected Recurly error: %v\", e)\n\treturn nil, err\n}\n\nfmt.Printf(\"Created ChargeInvoice with UUID: %s.\\n\", collection.ChargeInvoice.Uuid)\n"
          }
        ]
      }
    },
    "/purchases/authorize": {
      "post": {
        "tags": [
          "purchase"
        ],
        "operationId": "create_authorize_purchase",
        "summary": "Authorize a purchase",
        "description": "A purchase is a hybrid checkout containing at least one or more subscriptions or one-time charges (adjustments) and supports both coupon and gift card redemptions. All items purchased will be on one invoice and paid for with one transaction. A purchase is only a request data type and is not persistent in Recurly and an invoice collection will be the returned type.\n\nThe authorize endpoint will create a pending purchase that can be activated at a later time once payment has been completed on an external source.\n\nFor additional information regarding shipping fees, please see https://docs.recurly.com/docs/shipping",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PurchaseCreate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Returns the authorize invoice",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/InvoiceCollection"
                }
              }
            }
          },
          "400": {
            "description": "Bad request; perhaps missing or invalid parameters.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "422": {
            "description": "authorize purchase cannot be completed for the specified reason.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": []
      }
    },
    "/purchases/{transaction_id}/capture": {
      "post": {
        "tags": [
          "purchase"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/transaction_id"
          }
        ],
        "operationId": "create_capture_purchase",
        "summary": "Capture a purchase",
        "description": "A purchase is a hybrid checkout containing at least one or more\nsubscriptions or one-time charges (adjustments) and supports both coupon\nand gift card redemptions. All items purchased will be on one invoice\nand paid for with one transaction. A purchase is only a request data\ntype and is not persistent in Recurly and an invoice collection will be\nthe returned type.\n\n\nCapture an open Authorization request",
        "responses": {
          "200": {
            "description": "Returns the captured invoice",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/InvoiceCollection"
                }
              }
            }
          },
          "400": {
            "description": "Bad request; perhaps missing or invalid parameters.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "422": {
            "description": "Capture purchase cannot be completed for the specified reason.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": []
      }
    },
    "/purchases/{transaction_id}/cancel/": {
      "parameters": [
        {
          "$ref": "#/components/parameters/transaction_id"
        }
      ],
      "post": {
        "summary": "Cancel Purchase",
        "description": "A purchase is a hybrid checkout containing at least one or more subscriptions or one-time charges (adjustments) and supports both coupon and gift card redemptions. All items purchased will be on one invoice and paid for with one transaction. A purchase is only a request data type and is not persistent in Recurly and an invoice collection will be the returned type.\n\nCancel an open Authorization request\n",
        "tags": [
          "purchase"
        ],
        "operationId": "cancelPurchase",
        "responses": {
          "200": {
            "description": "Returns the cancelled invoice",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/InvoiceCollection"
                }
              }
            }
          },
          "400": {
            "description": "Bad request; perhaps missing or invalid parameters.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "422": {
            "description": "Cancel purchase cannot be completed for the specified reason.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": []
      }
    },
    "/export_dates": {
      "get": {
        "tags": [
          "automated_exports"
        ],
        "operationId": "get_export_dates",
        "summary": "List the dates that have an available export to download.",
        "description": "Returns a list of dates for which export files are available for download.",
        "responses": {
          "200": {
            "description": "Returns a list of dates.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ExportDates"
                }
              }
            }
          },
          "400": {
            "description": "Invalid or unpermitted parameter.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": [
          {
            "lang": "Node.js",
            "source": "try {\n  const export_dates = await client.getExportDates()\n  export_dates.dates.forEach(date => {\n    console.log(`Exports are available for: ${date}`)\n  })\n} catch (err) {\n  if (err instanceof recurly.ApiError) {\n    console.log('Unexpected error', err)\n  }\n}\n"
          },
          {
            "lang": "Python",
            "source": "try:\n    export_dates = client.get_export_dates()\n    for date in export_dates.dates:\n        print( \"Exports are available for: %s\" % date)\nexcept recurly.errors.NotFoundError:\n    # If the resource was not found, you may want to alert the user or\n    # just return nil\n    print(\"Resource Not Found\")\n"
          },
          {
            "lang": ".NET",
            "source": "try\n{\n    ExportDates exportDates = client.GetExportDates();\n    foreach (var date in exportDates.Dates)\n    {\n        System.Console.WriteLine($\"Exports are available for: {date}\");\n    }\n}\ncatch (Recurly.Errors.ApiError ex)\n{\n    // Use ApiError to catch a generic error from the API\n    Console.WriteLine($\"Unexpected Recurly Error: {ex.Error.Message}\");\n}\n"
          },
          {
            "lang": "Ruby",
            "source": "begin\n  export_dates = @client.get_export_dates()\n  export_dates.dates.each do |date|\n    puts \"Exports are available for: #{date}\"\n  end\nrescue Recurly::Errors::NotFoundError\n  # If the resource was not found, you may want to alert the user or\n  # just return nil\n  puts \"Resource Not Found\"\nend\n"
          },
          {
            "lang": "Java",
            "source": "try {\n    ExportDates exportDates = client.getExportDates();\n    for (String date : exportDates.getDates()) {\n        System.out.println(\"Exports are available for: \" + date);\n    }\n} catch (ApiException e) {\n    // Use ApiException to catch a generic error from the API\n    System.out.println(\"Unexpected Recurly Error: \" + e.getError().getMessage());\n}\n"
          },
          {
            "lang": "PHP",
            "source": "try {\n    $export_dates = $client->getExportDates();\n    foreach($export_dates->getDates() as $date)\n    {\n        echo \"Exports are available for: {$date}\" . PHP_EOL;\n    }\n} catch (\\Recurly\\RecurlyError $e) {\n    echo 'Some unexpected Recurly error happened. Try again later.' . PHP_EOL;\n}\n"
          },
          {
            "lang": "Go",
            "source": "exportDates, err := client.GetExportDates()\nif e, ok := err.(*recurly.Error); ok {\n\tfmt.Printf(\"Unexpected Recurly error: %v\", e)\n\treturn nil, err\n}\n\nfor _, date := range exportDates.Dates {\n\tfmt.Println(\"Exports are available for: \", date)\n}"
          }
        ]
      }
    },
    "/export_dates/{export_date}/export_files": {
      "parameters": [
        {
          "$ref": "#/components/parameters/export_date"
        }
      ],
      "get": {
        "tags": [
          "automated_exports"
        ],
        "operationId": "get_export_files",
        "summary": "List of the export files that are available to download.",
        "description": "Returns a list of presigned URLs to download export files for the given date, with their MD5 sums.",
        "responses": {
          "200": {
            "description": "Returns a list of export files to download.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ExportFiles"
                }
              }
            }
          },
          "400": {
            "description": "Invalid or unpermitted parameter.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site ID or date.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": [
          {
            "lang": "Node.js",
            "source": "try {\n  const export_files = await client.getExportFiles(export_date)\n  export_files.files.forEach(file => {\n    console.log(`Export file download URL: ${file.href}`)\n  })\n} catch (err) {\n  if (err instanceof recurly.ApiError) {\n    console.log('Unexpected error', err)\n  }\n}\n"
          },
          {
            "lang": "Python",
            "source": "try:\n    export_files = client.get_export_files(export_date)\n    for file in export_files.files:\n        print( \"Export file download URL: %s\" % file.href)\nexcept recurly.errors.NotFoundError:\n    # If the resource was not found, you may want to alert the user or\n    # just return nil\n    print(\"Resource Not Found\")\n"
          },
          {
            "lang": ".NET",
            "source": "try\n{\n    ExportFiles exportFiles = client.GetExportFiles(exportDate: exportDate);\n    foreach (var file in exportFiles.Files)\n    {\n        System.Console.WriteLine($\"Export file download URL: {file.Href}\");\n    }\n}\ncatch (Recurly.Errors.ApiError ex)\n{\n    // Use ApiError to catch a generic error from the API\n    Console.WriteLine($\"Unexpected Recurly Error: {ex.Error.Message}\");\n}\n"
          },
          {
            "lang": "Ruby",
            "source": "begin\n  export_files = @client.get_export_files(export_date: export_date)\n  export_files.files.each do |file|\n    puts \"Export file download URL: #{file.href}\"\n  end\nrescue Recurly::Errors::NotFoundError\n  # If the resource was not found, you may want to alert the user or\n  # just return nil\n  puts \"Resource Not Found\"\nend\n"
          },
          {
            "lang": "Java",
            "source": "try {\n    ExportFiles exportFiles = client.getExportFiles(exportDate);\n    for (ExportFile file : exportFiles.getFiles()) {\n        System.out.println(\"Export file download URL: \" + file.getHref());\n    }\n} catch (ApiException e) {\n    // Use ApiException to catch a generic error from the API\n    System.out.println(\"Unexpected Recurly Error: \" + e.getError());\n}\n"
          },
          {
            "lang": "PHP",
            "source": "try {\n    $export_files = $client->getExportFiles($export_date);\n    foreach($export_files->getFiles() as $file)\n    {\n        echo \"Export file download URL: {$file->getHref()}\" . PHP_EOL;\n    }\n} catch (\\Recurly\\RecurlyError $e) {\n    echo 'Some unexpected Recurly error happened. Try again later.' . PHP_EOL;\n}\n"
          },
          {
            "lang": "Go",
            "source": "exportFiles, err := client.GetExportFiles(exportDate)\nif e, ok := err.(*recurly.Error); ok {\n\tfmt.Printf(\"Unexpected Recurly error: %v\", e)\n\treturn nil, err\n}\n\nfor _, file := range exportFiles.Files {\n\tfmt.Println(\"Export file download URL: \", file.Href)\n}"
          }
        ]
      }
    },
    "/dunning_campaigns": {
      "get": {
        "tags": [
          "dunning_campaigns"
        ],
        "operationId": "list_dunning_campaigns",
        "summary": "List the dunning campaigns for a site",
        "description": "See the [Pagination Guide](/developers/guides/pagination.html) to learn how to use pagination in the API and Client Libraries.",
        "parameters": [
          {
            "$ref": "#/components/parameters/sort_dates"
          }
        ],
        "responses": {
          "200": {
            "description": "A list of the the dunning_campaigns on an account.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DunningCampaignList"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": []
      }
    },
    "/dunning_campaigns/{dunning_campaign_id}": {
      "parameters": [
        {
          "$ref": "#/components/parameters/dunning_campaign_id"
        }
      ],
      "get": {
        "tags": [
          "dunning_campaigns"
        ],
        "operationId": "get_dunning_campaign",
        "summary": "Fetch a dunning campaign",
        "responses": {
          "200": {
            "description": "Settings for a dunning campaign.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DunningCampaign"
                }
              }
            }
          },
          "400": {
            "description": "Bad request; perhaps missing or invalid parameters.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site or campaign ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": []
      }
    },
    "/dunning_campaigns/{dunning_campaign_id}/bulk_update": {
      "parameters": [
        {
          "$ref": "#/components/parameters/dunning_campaign_id"
        }
      ],
      "put": {
        "tags": [
          "dunning_campaigns"
        ],
        "operationId": "put_dunning_campaign_bulk_update",
        "summary": "Assign a dunning campaign to multiple plans",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DunningCampaignsBulkUpdate"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "A list of updated plans.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DunningCampaignsBulkUpdateResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad request; perhaps missing or invalid parameters.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site or campaign ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": []
      }
    },
    "/invoice_templates": {
      "get": {
        "tags": [
          "invoice_templates"
        ],
        "operationId": "list_invoice_templates",
        "summary": "Show the invoice templates for a site",
        "description": "See the [Pagination Guide](/developers/guides/pagination.html) to learn how to use pagination in the API and Client Libraries.",
        "parameters": [
          {
            "$ref": "#/components/parameters/sort_dates"
          }
        ],
        "responses": {
          "200": {
            "description": "A list of the the invoice templates on a site.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/InvoiceTemplateList"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": []
      }
    },
    "/invoice_templates/{invoice_template_id}": {
      "parameters": [
        {
          "$ref": "#/components/parameters/invoice_template_id"
        }
      ],
      "get": {
        "tags": [
          "invoice_templates"
        ],
        "operationId": "get_invoice_template",
        "summary": "Fetch an invoice template",
        "responses": {
          "200": {
            "description": "Settings for an invoice template.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/InvoiceTemplate"
                }
              }
            }
          },
          "400": {
            "description": "Bad request; perhaps missing or invalid parameters.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site or invoice template ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": []
      }
    },
    "/external_invoices": {
      "get": {
        "tags": [
          "external_invoices"
        ],
        "operationId": "list_external_invoices",
        "summary": "List the external invoices on a site",
        "description": "See the [Pagination Guide](/developers/guides/pagination.html) to learn how to use pagination in the API and Client Libraries.",
        "parameters": [
          {
            "$ref": "#/components/parameters/sort_dates"
          },
          {
            "$ref": "#/components/parameters/limit"
          },
          {
            "$ref": "#/components/parameters/order"
          }
        ],
        "responses": {
          "200": {
            "description": "A list of the the external_invoices on a site.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ExternalInvoiceList"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": []
      }
    },
    "/external_invoices/{external_invoice_id}": {
      "parameters": [
        {
          "$ref": "#/components/parameters/external_invoice_id"
        }
      ],
      "get": {
        "tags": [
          "external_invoices"
        ],
        "operationId": "show_external_invoice",
        "summary": "Fetch an external invoice",
        "responses": {
          "201": {
            "description": "Returns the external invoice",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ExternalInvoice"
                }
              }
            }
          },
          "400": {
            "description": "Bad request; perhaps missing or invalid parameters.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "404": {
            "description": "External invoice cannot be found for the specified reason.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": []
      }
    },
    "/external_subscriptions/{external_subscription_id}/external_payment_phases": {
      "parameters": [
        {
          "$ref": "#/components/parameters/external_subscription_id"
        }
      ],
      "get": {
        "tags": [
          "external_subscriptions"
        ],
        "operationId": "list_external_subscription_external_payment_phases",
        "summary": "List the external payment phases on an external subscription",
        "description": "See the [Pagination Guide](/developers/guides/pagination.html) to learn how to use pagination in the API and Client Libraries.",
        "parameters": [
          {
            "$ref": "#/components/parameters/sort_dates"
          },
          {
            "$ref": "#/components/parameters/limit"
          },
          {
            "$ref": "#/components/parameters/order"
          }
        ],
        "responses": {
          "200": {
            "description": "A list of the the external_payment_phases on a site.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ExternalPaymentPhaseList"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": []
      }
    },
    "/external_subscriptions/{external_subscription_id}/external_payment_phases/{external_payment_phase_id}": {
      "parameters": [
        {
          "$ref": "#/components/parameters/external_subscription_id"
        },
        {
          "$ref": "#/components/parameters/external_payment_phase_id"
        }
      ],
      "get": {
        "tags": [
          "external_payment_phases"
        ],
        "operationId": "get_external_subscription_external_payment_phase",
        "summary": "Fetch an external payment phase",
        "responses": {
          "200": {
            "description": "Details for an external payment phase.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ExternalPaymentPhase"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site or external subscription ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": []
      }
    },
    "/accounts/{account_id}/entitlements": {
      "parameters": [
        {
          "$ref": "#/components/parameters/account_id"
        },
        {
          "$ref": "#/components/parameters/filter_limited_subscription_state"
        }
      ],
      "get": {
        "tags": [
          "account"
        ],
        "operationId": "list_entitlements",
        "summary": "List entitlements granted to an account",
        "responses": {
          "200": {
            "description": "A list of the entitlements granted to an account.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Entitlements"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site or account ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": []
      }
    },
    "/accounts/{account_id}/external_subscriptions": {
      "parameters": [
        {
          "$ref": "#/components/parameters/account_id"
        }
      ],
      "get": {
        "tags": [
          "account"
        ],
        "operationId": "list_account_external_subscriptions",
        "summary": "List an account's external subscriptions",
        "description": "See the [Pagination Guide](/developers/guides/pagination.html) to learn how to use pagination in the API and Client Libraries.",
        "parameters": [
          {
            "$ref": "#/components/parameters/sort_dates"
          }
        ],
        "responses": {
          "200": {
            "description": "A list of the the external_subscriptions on an account.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ExternalSubscriptionList"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect account.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": []
      }
    },
    "/business_entities/{business_entity_id}": {
      "parameters": [
        {
          "$ref": "#/components/parameters/business_entity_id"
        }
      ],
      "get": {
        "tags": [
          "business_entities"
        ],
        "operationId": "get_business_entity",
        "summary": "Fetch a business entity",
        "responses": {
          "200": {
            "description": "Business entity details",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BusinessEntity"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site or business entity ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": []
      }
    },
    "/business_entities": {
      "get": {
        "tags": [
          "business_entities"
        ],
        "operationId": "list_business_entities",
        "summary": "List business entities",
        "responses": {
          "200": {
            "description": "List of all business entities on your site.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BusinessEntityList"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": []
      }
    },
    "/gift_cards": {
      "get": {
        "tags": [
          "gift_cards"
        ],
        "operationId": "list_gift_cards",
        "summary": "List gift cards",
        "responses": {
          "200": {
            "description": "List of all created gift cards on your site.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GiftCardList"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": []
      },
      "post": {
        "tags": [
          "gift_cards"
        ],
        "operationId": "create_gift_card",
        "summary": "Create gift card",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GiftCardCreate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Returns the gift card",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GiftCard"
                }
              }
            }
          },
          "400": {
            "description": "Bad request; perhaps missing or invalid parameters.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "422": {
            "description": "Gift card cannot be completed for the specified reason.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": []
      }
    },
    "/gift_cards/{gift_card_id}": {
      "parameters": [
        {
          "$ref": "#/components/parameters/gift_card_id"
        }
      ],
      "get": {
        "tags": [
          "gift_cards"
        ],
        "operationId": "get_gift_card",
        "summary": "Fetch a gift card",
        "responses": {
          "200": {
            "description": "Gift card details",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GiftCard"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site or gift card ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": []
      }
    },
    "/gift_cards/preview": {
      "post": {
        "tags": [
          "gift_cards"
        ],
        "operationId": "preview_gift_card",
        "summary": "Preview gift card",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GiftCardCreate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Returns the gift card",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GiftCard"
                }
              }
            }
          },
          "400": {
            "description": "Bad request; perhaps missing or invalid parameters.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "422": {
            "description": "Gift card cannot be completed for the specified reason.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": []
      }
    },
    "/gift_cards/{redemption_code}/redeem": {
      "parameters": [
        {
          "$ref": "#/components/parameters/redemption_code"
        }
      ],
      "post": {
        "tags": [
          "gift_cards"
        ],
        "operationId": "redeem_gift_card",
        "summary": "Redeem gift card",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GiftCardRedeem"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Redeems and returns the gift card",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GiftCard"
                }
              }
            }
          },
          "400": {
            "description": "Bad request; perhaps missing or invalid parameters.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "422": {
            "description": "Gift card cannot be redeemed for the specified reason.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": []
      }
    },
    "/business_entities/{business_entity_id}/invoices": {
      "get": {
        "tags": [
          "invoice"
        ],
        "operationId": "list_business_entity_invoices",
        "summary": "List a business entity's invoices",
        "description": "See the [Pagination Guide](/developers/guides/pagination.html) to learn how to use pagination in the API and Client Libraries.",
        "parameters": [
          {
            "$ref": "#/components/parameters/business_entity_id"
          },
          {
            "$ref": "#/components/parameters/ids"
          },
          {
            "$ref": "#/components/parameters/invoice_state"
          },
          {
            "$ref": "#/components/parameters/limit"
          },
          {
            "$ref": "#/components/parameters/order"
          },
          {
            "$ref": "#/components/parameters/sort_dates"
          },
          {
            "$ref": "#/components/parameters/filter_begin_time"
          },
          {
            "$ref": "#/components/parameters/filter_end_time"
          },
          {
            "$ref": "#/components/parameters/filter_invoice_type"
          }
        ],
        "responses": {
          "200": {
            "description": "A list of the business entity's invoices.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/InvoiceList"
                }
              }
            }
          },
          "400": {
            "description": "Invalid or unpermitted parameter.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect site or business entity ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "x-code-samples": []
      }
    }
  },
  "servers": [
    {
      "url": "https://v3.recurly.com"
    },
    {
      "url": "https://v3.eu.recurly.com"
    }
  ],
  "components": {
    "parameters": {
      "site_id": {
        "name": "site_id",
        "in": "path",
        "description": "Site ID or subdomain. For ID no prefix is used e.g. `e28zov4fw0v2`. For subdomain use prefix `subdomain-`, e.g. `subdomain-recurly`.",
        "required": true,
        "schema": {
          "type": "string"
        }
      },
      "account_id": {
        "name": "account_id",
        "in": "path",
        "description": "Account ID or code. For ID no prefix is used e.g. `e28zov4fw0v2`. For code use prefix `code-`, e.g. `code-bob`.",
        "required": true,
        "schema": {
          "type": "string"
        }
      },
      "add_on_id": {
        "name": "add_on_id",
        "in": "path",
        "description": "Add-on ID or code. For ID no prefix is used e.g. `e28zov4fw0v2`. For code use prefix `code-`, e.g. `code-gold`.",
        "required": true,
        "schema": {
          "type": "string"
        }
      },
      "billing_info_id": {
        "name": "billing_info_id",
        "in": "path",
        "description": "Billing Info ID. Can ONLY be used for sites utilizing the Wallet feature.",
        "required": true,
        "schema": {
          "type": "string"
        }
      },
      "business_entity_id": {
        "name": "business_entity_id",
        "in": "path",
        "description": "Business Entity ID. For ID no prefix is used e.g. `e28zov4fw0v2`. For code use prefix `code-`, e.g. `code-entity1`.",
        "required": true,
        "schema": {
          "type": "string"
        }
      },
      "usage_id": {
        "name": "usage_id",
        "in": "path",
        "description": "Usage Record ID.",
        "required": true,
        "schema": {
          "type": "string"
        }
      },
      "coupon_id": {
        "name": "coupon_id",
        "in": "path",
        "description": "Coupon ID or code. For ID no prefix is used e.g. `e28zov4fw0v2`. For code use prefix `code-`, e.g. `code-10off`.",
        "required": true,
        "schema": {
          "type": "string"
        }
      },
      "credit_payment_id": {
        "name": "credit_payment_id",
        "in": "path",
        "description": "Credit Payment ID or UUID. For ID no prefix is used e.g. `e28zov4fw0v2`. For UUID use prefix `uuid-`, e.g. `uuid-123457890`.",
        "required": true,
        "schema": {
          "type": "string"
        }
      },
      "custom_field_definition_id": {
        "name": "custom_field_definition_id",
        "in": "path",
        "description": "Custom Field Definition ID",
        "required": true,
        "schema": {
          "type": "string"
        }
      },
      "external_account_id": {
        "name": "external_account_id",
        "in": "path",
        "description": "External account ID, e.g. `s28zov4fw0cb`.",
        "required": true,
        "schema": {
          "type": "string"
        }
      },
      "external_invoice_id": {
        "name": "external_invoice_id",
        "in": "path",
        "description": "External invoice ID, e.g. `e28zov4fw0v2`.",
        "required": true,
        "schema": {
          "type": "string"
        }
      },
      "external_product_id": {
        "name": "external_product_id",
        "in": "path",
        "description": "External product id",
        "required": true,
        "schema": {
          "type": "string"
        }
      },
      "external_product_reference_id": {
        "name": "external_product_reference_id",
        "in": "path",
        "description": "External product reference ID, e.g. `d39iun2fw1v4`.",
        "required": true,
        "schema": {
          "type": "string"
        }
      },
      "external_subscription_id_fetch": {
        "name": "external_subscription_id",
        "in": "path",
        "description": "External subscription ID, external_id or uuid. For ID no prefix is used e.g. `e28zov4fw0v2`. For external_id use prefix `external-id-`, e.g. `external-id-123456` and for uuid use prefix `uuid-` e.g. `uuid-7293239bae62777d8c1ae044a9843633`.",
        "required": true,
        "schema": {
          "type": "string"
        }
      },
      "external_subscription_id": {
        "name": "external_subscription_id",
        "in": "path",
        "description": "External subscription id",
        "required": true,
        "schema": {
          "type": "string"
        }
      },
      "external_payment_phase_id": {
        "name": "external_payment_phase_id",
        "in": "path",
        "description": "External payment phase ID, e.g. `a34ypb2ef9w1`.",
        "required": true,
        "schema": {
          "type": "string"
        }
      },
      "general_ledger_account_id": {
        "name": "general_ledger_account_id",
        "in": "path",
        "description": "General Ledger Account ID",
        "required": true,
        "schema": {
          "type": "string",
          "title": "General Ledger Account ID",
          "description": "The ID of a general ledger account. General ledger accounts are\nonly accessible as a part of the Recurly RevRec Standard and\nRecurly RevRec Advanced features.\n",
          "maxLength": 13
        }
      },
      "general_ledger_account_type_enum": {
        "name": "account_type",
        "in": "query",
        "description": "General Ledger Account type by which to filter the response.",
        "schema": {
          "type": "string",
          "enum": [
            "liability",
            "revenue"
          ]
        }
      },
      "invoice_template_id": {
        "name": "invoice_template_id",
        "in": "path",
        "description": "Invoice template ID or code. For ID no prefix is used e.g. `e28zov4fw0v2`. For code use prefix `code-`, e.g. `code-bob`.",
        "required": true,
        "schema": {
          "type": "string"
        }
      },
      "item_id": {
        "name": "item_id",
        "in": "path",
        "description": "Item ID or code. For ID no prefix is used e.g. `e28zov4fw0v2`. For code use prefix `code-`, e.g. `code-red`.",
        "required": true,
        "schema": {
          "type": "string"
        }
      },
      "invoice_id": {
        "name": "invoice_id",
        "in": "path",
        "description": "Invoice ID or number. For ID no prefix is used e.g. `e28zov4fw0v2`. For number use prefix `number-`, e.g. `number-1000`.",
        "required": true,
        "schema": {
          "type": "string"
        }
      },
      "invoice_state": {
        "name": "state",
        "in": "query",
        "description": "Invoice state.",
        "schema": {
          "type": "string",
          "default": "all",
          "enum": [
            "pending",
            "past_due",
            "paid",
            "failed"
          ]
        }
      },
      "measured_unit_id": {
        "name": "measured_unit_id",
        "in": "path",
        "description": "Measured unit ID or name. For ID no prefix is used e.g. `e28zov4fw0v2`. For name use prefix `name-`, e.g. `name-Storage`.",
        "required": true,
        "schema": {
          "type": "string"
        }
      },
      "line_item_id": {
        "name": "line_item_id",
        "in": "path",
        "description": "Line Item ID.",
        "required": true,
        "schema": {
          "type": "string"
        }
      },
      "performance_obligation_id": {
        "name": "performance_obligation_id",
        "in": "path",
        "description": "Performance Obligation id.",
        "required": true,
        "schema": {
          "type": "string",
          "title": "Performance Obligation ID",
          "description": "The ID of a performance obligation. Performance obligations are\nonly accessible as a part of the Recurly RevRec Standard and\nRecurly RevRec Advanced features.\n",
          "maxLength": 13
        }
      },
      "plan_id": {
        "name": "plan_id",
        "in": "path",
        "description": "Plan ID or code. For ID no prefix is used e.g. `e28zov4fw0v2`. For code use prefix `code-`, e.g. `code-gold`.",
        "required": true,
        "schema": {
          "type": "string"
        }
      },
      "shipping_address_id": {
        "name": "shipping_address_id",
        "in": "path",
        "description": "Shipping Address ID.",
        "required": true,
        "schema": {
          "type": "string"
        }
      },
      "shipping_method_id": {
        "name": "shipping_method_id",
        "in": "path",
        "description": "Shipping Method ID or code. For ID no prefix is used e.g. `e28zov4fw0v2`. For code use prefix `code-`, e.g. `code-usps_2-day`.",
        "required": true,
        "schema": {
          "type": "string"
        }
      },
      "subscription_id": {
        "name": "subscription_id",
        "in": "path",
        "description": "Subscription ID or UUID. For ID no prefix is used e.g. `e28zov4fw0v2`. For UUID use prefix `uuid-`, e.g. `uuid-123457890`.",
        "required": true,
        "schema": {
          "type": "string"
        }
      },
      "transaction_id": {
        "name": "transaction_id",
        "in": "path",
        "description": "Transaction ID or UUID. For ID no prefix is used e.g. `e28zov4fw0v2`. For UUID use prefix `uuid-`, e.g. `uuid-123457890`.",
        "required": true,
        "schema": {
          "type": "string"
        }
      },
      "unique_coupon_code_id": {
        "name": "unique_coupon_code_id",
        "in": "path",
        "description": "Unique Coupon Code ID or code. For ID no prefix is used e.g. `e28zov4fw0v2`. For code use prefix `code-`, e.g. `code-abc-8dh2-def`.",
        "required": true,
        "schema": {
          "type": "string"
        }
      },
      "dunning_campaign_id": {
        "name": "dunning_campaign_id",
        "in": "path",
        "description": "Dunning Campaign ID, e.g. `e28zov4fw0v2`.",
        "required": true,
        "schema": {
          "type": "string"
        }
      },
      "gift_card_id": {
        "name": "gift_card_id",
        "in": "path",
        "description": "Gift Card ID, e.g. `e28zov4fw0v2`.",
        "required": true,
        "schema": {
          "type": "string"
        }
      },
      "redemption_code": {
        "name": "redemption_code",
        "in": "path",
        "description": "Gift Card redemption code, e.g., `N1A2T8IRXSCMO40V`.",
        "required": true,
        "schema": {
          "type": "string"
        }
      },
      "ids": {
        "name": "ids",
        "in": "query",
        "description": "Filter results by their IDs. Up to 200 IDs can be passed at once using\ncommas as separators, e.g. `ids=h1at4d57xlmy,gyqgg0d3v9n1,jrsm5b4yefg6`.\n\n**Important notes:**\n\n* The `ids` parameter cannot be used with any other ordering or filtering\n  parameters (`limit`, `order`, `sort`, `begin_time`, `end_time`, etc)\n* Invalid or unknown IDs will be ignored, so you should check that the\n  results correspond to your request.\n* Records are returned in an arbitrary order. Since results are all\n  returned at once you can sort the records yourself.\n",
        "style": "form",
        "explode": false,
        "schema": {
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      },
      "limit": {
        "name": "limit",
        "in": "query",
        "description": "Limit number of records 1-200.",
        "schema": {
          "type": "integer",
          "minimum": 1,
          "maximum": 200,
          "default": 20
        }
      },
      "order": {
        "name": "order",
        "in": "query",
        "description": "Sort order.",
        "schema": {
          "default": "desc",
          "type": "string",
          "enum": [
            "asc",
            "desc"
          ]
        }
      },
      "sort_dates": {
        "name": "sort",
        "in": "query",
        "description": "Sort field. You *really* only want to sort by `updated_at` in ascending\norder. In descending order updated records will move behind the cursor and could\nprevent some records from being returned.\n",
        "schema": {
          "default": "created_at",
          "type": "string",
          "enum": [
            "created_at",
            "updated_at"
          ]
        }
      },
      "usage_sort_dates": {
        "name": "sort",
        "in": "query",
        "description": "Sort field. You *really* only want to sort by `usage_timestamp` in ascending\norder. In descending order updated records will move behind the cursor and could\nprevent some records from being returned.\n",
        "schema": {
          "type": "string",
          "default": "usage_timestamp",
          "enum": [
            "recorded_timestamp",
            "usage_timestamp"
          ]
        }
      },
      "billing_status": {
        "name": "billing_status",
        "in": "query",
        "description": "Filter by usage record's billing status",
        "schema": {
          "type": "string",
          "default": "unbilled",
          "enum": [
            "unbilled",
            "billed",
            "all"
          ]
        }
      },
      "filter_state": {
        "name": "state",
        "in": "query",
        "description": "Filter by state.",
        "schema": {
          "type": "string",
          "enum": [
            "active",
            "inactive"
          ]
        }
      },
      "filter_subscription_state": {
        "name": "state",
        "in": "query",
        "description": "Filter by state.\n\n- When `state=active`, `state=canceled`, `state=expired`, or `state=future`, subscriptions with states that match the query and only those subscriptions will be returned.\n- When `state=in_trial`, only subscriptions that have a trial_started_at date earlier than now and a trial_ends_at date later than now will be returned.\n- When `state=live`, only subscriptions that are in an active, canceled, or future state or are in trial will be returned.\n",
        "schema": {
          "type": "string",
          "enum": [
            "active",
            "canceled",
            "expired",
            "future",
            "in_trial",
            "live"
          ]
        }
      },
      "filter_limited_subscription_state": {
        "name": "state",
        "in": "query",
        "description": "Filter the entitlements based on the state of the applicable subscription.\n\n- When `state=active`, `state=canceled`, `state=expired`, or `state=future`, subscriptions with states that match the query and only those subscriptions will be returned.\n- When no state is provided, subscriptions with active or canceled states will be returned.\n",
        "schema": {
          "type": "string",
          "enum": [
            "active",
            "canceled",
            "expired",
            "future"
          ]
        }
      },
      "filter_begin_time": {
        "name": "begin_time",
        "in": "query",
        "description": "Inclusively filter by begin_time when `sort=created_at` or `sort=updated_at`.\n**Note:** this value is an ISO8601 timestamp. A partial timestamp that does not include a time zone will default to UTC.\n",
        "schema": {
          "type": "string",
          "format": "date-time"
        }
      },
      "filter_end_time": {
        "name": "end_time",
        "in": "query",
        "description": "Inclusively filter by end_time when `sort=created_at` or `sort=updated_at`.\n**Note:** this value is an ISO8601 timestamp. A partial timestamp that does not include a time zone will default to UTC.\n",
        "schema": {
          "type": "string",
          "format": "date-time"
        }
      },
      "filter_usage_begin_time": {
        "name": "begin_time",
        "in": "query",
        "description": "Inclusively filter by begin_time when `sort=usage_timestamp` or `sort=recorded_timestamp`.\n**Note:** this value is an ISO8601 timestamp. A partial timestamp that does not include a time zone will default to UTC.\n",
        "schema": {
          "type": "string",
          "format": "date-time"
        }
      },
      "filter_usage_end_time": {
        "name": "end_time",
        "in": "query",
        "description": "Inclusively filter by end_time when `sort=usage_timestamp` or `sort=recorded_timestamp`.\n**Note:** this value is an ISO8601 timestamp. A partial timestamp that does not include a time zone will default to UTC.\n",
        "schema": {
          "type": "string",
          "format": "date-time"
        }
      },
      "filter_account_email": {
        "name": "email",
        "in": "query",
        "description": "Filter for accounts with this exact email address. A blank value will return accounts with both `null` and `\"\"` email addresses. Note that multiple accounts can share one email address.",
        "schema": {
          "type": "string"
        }
      },
      "filter_account_subscriber": {
        "name": "subscriber",
        "in": "query",
        "description": "Filter for accounts with or without a subscription in the `active`,\n`canceled`, or `future` state.\n",
        "schema": {
          "type": "boolean"
        }
      },
      "filter_account_past_due": {
        "name": "past_due",
        "in": "query",
        "description": "Filter for accounts with an invoice in the `past_due` state.",
        "schema": {
          "type": "string",
          "enum": [
            true
          ]
        }
      },
      "filter_line_item_original": {
        "name": "original",
        "in": "query",
        "description": "Filter by original field.",
        "schema": {
          "type": "string",
          "enum": [
            true
          ]
        }
      },
      "filter_line_item_state": {
        "name": "state",
        "in": "query",
        "description": "Filter by state field.",
        "schema": {
          "type": "string",
          "enum": [
            "invoiced",
            "pending"
          ]
        }
      },
      "filter_line_item_type": {
        "name": "type",
        "in": "query",
        "description": "Filter by type field.",
        "schema": {
          "type": "string",
          "enum": [
            "charge",
            "credit"
          ]
        }
      },
      "filter_transaction_type": {
        "name": "type",
        "in": "query",
        "description": "Filter by type field. The value `payment` will return both `purchase` and `capture` transactions.",
        "schema": {
          "type": "string",
          "enum": [
            "authorization",
            "capture",
            "payment",
            "purchase",
            "refund",
            "verify"
          ]
        }
      },
      "filter_transaction_success": {
        "name": "success",
        "in": "query",
        "description": "Filter by success field.",
        "schema": {
          "type": "string",
          "enum": [
            true
          ]
        }
      },
      "filter_invoice_type": {
        "name": "type",
        "in": "query",
        "description": "Filter by type when:\n- `type=charge`, only charge invoices will be returned.\n- `type=credit`, only credit invoices will be returned.\n- `type=non-legacy`, only charge and credit invoices will be returned.\n- `type=legacy`, only legacy invoices will be returned.\n",
        "schema": {
          "type": "string",
          "enum": [
            "charge",
            "credit",
            "legacy",
            "non-legacy"
          ]
        }
      },
      "export_date": {
        "name": "export_date",
        "in": "path",
        "description": "Date for which to get a list of available automated export files. Date must be in YYYY-MM-DD format.",
        "required": true,
        "schema": {
          "type": "string"
        }
      }
    },
    "securitySchemes": {
      "api_key": {
        "type": "http",
        "description": "Enter the API key as the username and set the password to an empty string. You can locate and manage your API keys from the [API Credentials](https://app.recurly.com/go/developer/api_keys) page.",
        "scheme": "basic"
      }
    },
    "schemas": {
      "Empty": {
        "type": "object",
        "properties": {}
      },
      "BinaryFile": {
        "type": "string",
        "format": "binary",
        "readOnly": true
      },
      "AccountAcquisitionList": {
        "type": "object",
        "properties": {
          "object": {
            "type": "string",
            "title": "Object type",
            "description": "Will always be List."
          },
          "has_more": {
            "type": "boolean",
            "description": "Indicates there are more results on subsequent pages."
          },
          "next": {
            "type": "string",
            "description": "Path to subsequent page of results."
          },
          "data": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/AccountAcquisition"
            }
          }
        }
      },
      "AccountList": {
        "type": "object",
        "properties": {
          "object": {
            "type": "string",
            "title": "Object type",
            "description": "Will always be List."
          },
          "has_more": {
            "type": "boolean",
            "description": "Indicates there are more results on subsequent pages."
          },
          "next": {
            "type": "string",
            "description": "Path to subsequent page of results."
          },
          "data": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Account"
            }
          }
        }
      },
      "AccountNoteList": {
        "type": "object",
        "properties": {
          "object": {
            "type": "string",
            "title": "Object type",
            "description": "Will always be List."
          },
          "has_more": {
            "type": "boolean",
            "description": "Indicates there are more results on subsequent pages."
          },
          "next": {
            "type": "string",
            "description": "Path to subsequent page of results."
          },
          "data": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/AccountNote"
            }
          }
        }
      },
      "AddOnList": {
        "type": "object",
        "properties": {
          "object": {
            "type": "string",
            "title": "Object type",
            "description": "Will always be List."
          },
          "has_more": {
            "type": "boolean",
            "description": "Indicates there are more results on subsequent pages."
          },
          "next": {
            "type": "string",
            "description": "Path to subsequent page of results."
          },
          "data": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/AddOn"
            }
          }
        }
      },
      "BillingInfoList": {
        "type": "object",
        "properties": {
          "object": {
            "type": "string",
            "title": "Object type",
            "description": "Will always be List."
          },
          "has_more": {
            "type": "boolean",
            "description": "Indicates there are more results on subsequent pages."
          },
          "next": {
            "type": "string",
            "description": "Path to subsequent page of results."
          },
          "data": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/BillingInfo"
            }
          }
        }
      },
      "CreditPaymentList": {
        "type": "object",
        "properties": {
          "object": {
            "type": "string",
            "title": "Object type",
            "description": "Will always be List."
          },
          "has_more": {
            "type": "boolean",
            "description": "Indicates there are more results on subsequent pages."
          },
          "next": {
            "type": "string",
            "description": "Path to subsequent page of results."
          },
          "data": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/CreditPayment"
            }
          }
        }
      },
      "CouponList": {
        "type": "object",
        "properties": {
          "object": {
            "type": "string",
            "title": "Object type",
            "description": "Will always be List."
          },
          "has_more": {
            "type": "boolean",
            "description": "Indicates there are more results on subsequent pages."
          },
          "next": {
            "type": "string",
            "description": "Path to subsequent page of results."
          },
          "data": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Coupon"
            }
          }
        }
      },
      "CouponRedemptionList": {
        "type": "object",
        "properties": {
          "object": {
            "type": "string",
            "title": "Object type",
            "description": "Will always be List."
          },
          "has_more": {
            "type": "boolean",
            "description": "Indicates there are more results on subsequent pages."
          },
          "next": {
            "type": "string",
            "description": "Path to subsequent page of results."
          },
          "data": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/CouponRedemption"
            }
          }
        }
      },
      "CustomFieldDefinitionList": {
        "type": "object",
        "properties": {
          "object": {
            "type": "string",
            "title": "Object type",
            "description": "Will always be List."
          },
          "has_more": {
            "type": "boolean",
            "description": "Indicates there are more results on subsequent pages."
          },
          "next": {
            "type": "string",
            "description": "Path to subsequent page of results."
          },
          "data": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/CustomFieldDefinition"
            }
          }
        }
      },
      "ItemList": {
        "type": "object",
        "properties": {
          "object": {
            "type": "string",
            "title": "Object type",
            "description": "Will always be List."
          },
          "has_more": {
            "type": "boolean",
            "description": "Indicates there are more results on subsequent pages."
          },
          "next": {
            "type": "string",
            "description": "Path to subsequent page of results."
          },
          "data": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Item"
            }
          }
        }
      },
      "InvoiceList": {
        "type": "object",
        "properties": {
          "object": {
            "type": "string",
            "title": "Object type",
            "description": "Will always be List."
          },
          "has_more": {
            "type": "boolean",
            "description": "Indicates there are more results on subsequent pages."
          },
          "next": {
            "type": "string",
            "description": "Path to subsequent page of results."
          },
          "data": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Invoice"
            }
          }
        }
      },
      "MeasuredUnitList": {
        "type": "object",
        "properties": {
          "object": {
            "type": "string",
            "title": "Object type",
            "description": "Will always be List."
          },
          "has_more": {
            "type": "boolean",
            "description": "Indicates there are more results on subsequent pages."
          },
          "next": {
            "type": "string",
            "description": "Path to subsequent page of results."
          },
          "data": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/MeasuredUnit"
            }
          }
        }
      },
      "LineItemList": {
        "type": "object",
        "properties": {
          "object": {
            "type": "string",
            "title": "Object type",
            "description": "Will always be List."
          },
          "has_more": {
            "type": "boolean",
            "description": "Indicates there are more results on subsequent pages."
          },
          "next": {
            "type": "string",
            "description": "Path to subsequent page of results."
          },
          "data": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LineItem"
            }
          }
        }
      },
      "PlanList": {
        "type": "object",
        "properties": {
          "object": {
            "type": "string",
            "title": "Object type",
            "description": "Will always be List."
          },
          "has_more": {
            "type": "boolean",
            "description": "Indicates there are more results on subsequent pages."
          },
          "next": {
            "type": "string",
            "description": "Path to subsequent page of results."
          },
          "data": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Plan"
            }
          }
        }
      },
      "SiteList": {
        "type": "object",
        "properties": {
          "object": {
            "type": "string",
            "title": "Object type",
            "description": "Will always be List."
          },
          "has_more": {
            "type": "boolean",
            "description": "Indicates there are more results on subsequent pages."
          },
          "next": {
            "type": "string",
            "description": "Path to subsequent page of results."
          },
          "data": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Site"
            }
          }
        }
      },
      "ShippingMethodList": {
        "type": "object",
        "properties": {
          "object": {
            "type": "string",
            "title": "Object type",
            "description": "Will always be List."
          },
          "has_more": {
            "type": "boolean",
            "description": "Indicates there are more results on subsequent pages."
          },
          "next": {
            "type": "string",
            "description": "Path to subsequent page of results."
          },
          "data": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ShippingMethod"
            }
          }
        }
      },
      "SubscriptionList": {
        "type": "object",
        "properties": {
          "object": {
            "type": "string",
            "title": "Object type",
            "description": "Will always be List."
          },
          "has_more": {
            "type": "boolean",
            "description": "Indicates there are more results on subsequent pages."
          },
          "next": {
            "type": "string",
            "description": "Path to subsequent page of results."
          },
          "data": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Subscription"
            }
          }
        }
      },
      "TransactionList": {
        "type": "object",
        "properties": {
          "object": {
            "type": "string",
            "title": "Object type",
            "description": "Will always be List."
          },
          "has_more": {
            "type": "boolean",
            "description": "Indicates there are more results on subsequent pages."
          },
          "next": {
            "type": "string",
            "description": "Path to subsequent page of results."
          },
          "data": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Transaction"
            }
          }
        }
      },
      "Account": {
        "allOf": [
          {
            "$ref": "#/components/schemas/AccountReadOnly"
          },
          {
            "$ref": "#/components/schemas/AccountResponse"
          }
        ]
      },
      "AccountAcquisition": {
        "allOf": [
          {
            "$ref": "#/components/schemas/AccountAcquisitionUpdate"
          },
          {
            "$ref": "#/components/schemas/AccountAcquisitionReadOnly"
          }
        ]
      },
      "AccountAcquisitionUpdate": {
        "type": "object",
        "properties": {
          "cost": {
            "type": "object",
            "x-class-name": "AccountAcquisitionCost",
            "title": "Account balance",
            "items": {
              "type": "object"
            },
            "properties": {
              "currency": {
                "type": "string",
                "title": "Currency",
                "description": "3-letter ISO 4217 currency code.",
                "maxLength": 3
              },
              "amount": {
                "type": "number",
                "format": "float",
                "title": "Amount",
                "description": "The amount of the corresponding currency used to acquire the account."
              }
            }
          },
          "channel": {
            "description": "The channel through which the account was acquired.",
            "type": "string",
            "enum": [
              "advertising",
              "blog",
              "direct_traffic",
              "email",
              "events",
              "marketing_content",
              "organic_search",
              "other",
              "outbound_sales",
              "paid_search",
              "public_relations",
              "referral",
              "social_media"
            ]
          },
          "subchannel": {
            "type": "string",
            "description": "An arbitrary subchannel string representing a distinction/subcategory within a broader channel."
          },
          "campaign": {
            "type": "string",
            "description": "An arbitrary identifier for the marketing campaign that led to the acquisition of this account."
          }
        }
      },
      "AccountAcquisitionReadOnly": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "maxLength": 13,
            "readOnly": true
          },
          "object": {
            "type": "string",
            "title": "Object type",
            "readOnly": true
          },
          "account": {
            "$ref": "#/components/schemas/AccountMini"
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "description": "When the account acquisition data was created.",
            "readOnly": true
          },
          "updated_at": {
            "type": "string",
            "format": "date-time",
            "description": "When the account acquisition data was last changed.",
            "readOnly": true
          }
        }
      },
      "AccountReadOnly": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "maxLength": 13,
            "readOnly": true
          },
          "object": {
            "type": "string",
            "title": "Object type",
            "readOnly": true
          },
          "state": {
            "description": "Accounts can be either active or inactive.",
            "readOnly": true,
            "type": "string",
            "enum": [
              "active",
              "inactive"
            ]
          },
          "hosted_login_token": {
            "type": "string",
            "description": "The unique token for automatically logging the account in to the hosted management pages. You may automatically log the user into their hosted management pages by directing the user to: `https://{subdomain}.recurly.com/account/{hosted_login_token}`.",
            "readOnly": true,
            "maxLength": 32
          },
          "shipping_addresses": {
            "type": "array",
            "description": "The shipping addresses on the account.",
            "items": {
              "$ref": "#/components/schemas/ShippingAddress"
            }
          },
          "has_live_subscription": {
            "type": "boolean",
            "description": "Indicates if the account has a subscription that is either active, canceled, future, or paused."
          },
          "has_active_subscription": {
            "type": "boolean",
            "description": "Indicates if the account has an active subscription."
          },
          "has_future_subscription": {
            "type": "boolean",
            "description": "Indicates if the account has a future subscription."
          },
          "has_canceled_subscription": {
            "type": "boolean",
            "description": "Indicates if the account has a canceled subscription."
          },
          "has_paused_subscription": {
            "type": "boolean",
            "description": "Indicates if the account has a paused subscription."
          },
          "has_past_due_invoice": {
            "type": "boolean",
            "description": "Indicates if the account has a past due invoice."
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "description": "When the account was created.",
            "readOnly": true
          },
          "updated_at": {
            "type": "string",
            "format": "date-time",
            "description": "When the account was last changed.",
            "readOnly": true
          },
          "deleted_at": {
            "type": "string",
            "format": "date-time",
            "description": "If present, when the account was last marked inactive.",
            "readOnly": true
          }
        }
      },
      "AccountCreate": {
        "allOf": [
          {
            "type": "object",
            "properties": {
              "code": {
                "type": "string",
                "description": "The unique identifier of the account. This cannot be changed once the account is created.",
                "maxLength": 50
              },
              "acquisition": {
                "$ref": "#/components/schemas/AccountAcquisitionUpdate"
              },
              "external_accounts": {
                "type": "array",
                "title": "External Accounts",
                "items": {
                  "$ref": "#/components/schemas/ExternalAccountCreate"
                }
              },
              "shipping_addresses": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/ShippingAddressCreate"
                }
              }
            },
            "required": [
              "code"
            ]
          },
          {
            "$ref": "#/components/schemas/AccountUpdate"
          }
        ]
      },
      "AccountPurchase": {
        "allOf": [
          {
            "type": "object",
            "properties": {
              "id": {
                "type": "string",
                "description": "Optional, but if present allows an existing account to be used and updated as part of the purchase.",
                "maxLength": 13
              },
              "code": {
                "type": "string",
                "description": "The unique identifier of the account. This cannot be changed once the account is created.",
                "maxLength": 50
              },
              "acquisition": {
                "$ref": "#/components/schemas/AccountAcquisitionUpdate"
              }
            },
            "required": [
              "code"
            ]
          },
          {
            "$ref": "#/components/schemas/AccountUpdate"
          }
        ]
      },
      "AccountReference": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "maxLength": 13
          },
          "code": {
            "type": "string",
            "maxLength": 50
          }
        }
      },
      "AccountUpdate": {
        "type": "object",
        "properties": {
          "username": {
            "type": "string",
            "description": "A secondary value for the account.",
            "maxLength": 255
          },
          "email": {
            "type": "string",
            "format": "email",
            "description": "The email address used for communicating with this customer. The customer will also use this email address to log into your hosted account management pages. This value does not need to be unique.",
            "maxLength": 255
          },
          "preferred_locale": {
            "description": "Used to determine the language and locale of emails sent on behalf of the merchant to the customer. The list of locales is restricted to those the merchant has enabled on the site.",
            "type": "string",
            "enum": [
              "da-DK",
              "de-CH",
              "de-DE",
              "en-AU",
              "en-CA",
              "en-GB",
              "en-IE",
              "en-NZ",
              "en-US",
              "es-ES",
              "es-MX",
              "es-US",
              "fi-FI",
              "fr-BE",
              "fr-CA",
              "fr-CH",
              "fr-FR",
              "hi-IN",
              "it-IT",
              "ja-JP",
              "ko-KR",
              "nl-BE",
              "nl-NL",
              "pl-PL",
              "pt-BR",
              "pt-PT",
              "ro-RO",
              "ru-RU",
              "sk-SK",
              "sv-SE",
              "tr-TR",
              "zh-CN"
            ]
          },
          "preferred_time_zone": {
            "type": "string",
            "example": "America/Los_Angeles",
            "description": "Used to determine the time zone of emails sent on behalf of the merchant to the customer. Must be a [supported IANA time zone name](https://docs.recurly.com/docs/email-time-zones-and-time-stamps#supported-api-iana-time-zone-names)"
          },
          "cc_emails": {
            "type": "string",
            "description": "Additional email address that should receive account correspondence. These should be separated only by commas. These CC emails will receive all emails that the `email` field also receives.",
            "maxLength": 255
          },
          "first_name": {
            "type": "string",
            "maxLength": 255
          },
          "last_name": {
            "type": "string",
            "maxLength": 255
          },
          "company": {
            "type": "string",
            "maxLength": 100
          },
          "vat_number": {
            "type": "string",
            "description": "The VAT number of the account (to avoid having the VAT applied). This is only used for manually collected invoices.",
            "maxLength": 20
          },
          "tax_exempt": {
            "type": "boolean",
            "description": "The tax status of the account. `true` exempts tax on the account, `false` applies tax on the account."
          },
          "exemption_certificate": {
            "type": "string",
            "description": "The tax exemption certificate number for the account. If the merchant has an integration for the Vertex tax provider, this optional value will be sent in any tax calculation requests for the account.",
            "maxLength": 30
          },
          "override_business_entity_id": {
            "type": "string",
            "title": "Override Business Entity ID",
            "description": "Unique ID to identify the business entity assigned to the account. Available when the `Multiple Business Entities` feature is enabled."
          },
          "parent_account_code": {
            "type": "string",
            "maxLength": 50,
            "description": "The account code of the parent account to be associated with this account. Passing an empty value removes any existing parent association from this account. If both `parent_account_code` and `parent_account_id` are passed, the non-blank value in `parent_account_id` will be used. Only one level of parent child relationship is allowed. You cannot assign a parent account that itself has a parent account."
          },
          "parent_account_id": {
            "type": "string",
            "maxLength": 13,
            "description": "The UUID of the parent account to be associated with this account. Passing an empty value removes any existing parent association from this account. If both `parent_account_code` and `parent_account_id` are passed, the non-blank value in `parent_account_id` will be used. Only one level of parent child relationship is allowed. You cannot assign a parent account that itself has a parent account."
          },
          "bill_to": {
            "maxLength": 6,
            "description": "An enumerable describing the billing behavior of the account, specifically whether the account is self-paying or will rely on the parent account to pay.",
            "type": "string",
            "enum": [
              "parent",
              "self"
            ]
          },
          "transaction_type": {
            "description": "An optional type designation for the payment gateway transaction created by this request. Supports 'moto' value, which is the acronym for mail order and telephone transactions.",
            "type": "string",
            "enum": [
              "moto"
            ]
          },
          "dunning_campaign_id": {
            "type": "string",
            "title": "Dunning Campaign ID",
            "description": "Unique ID to identify a dunning campaign. Used to specify if a non-default dunning campaign should be assigned to this account. For sites without multiple dunning campaigns enabled, the default dunning campaign will always be used."
          },
          "invoice_template_id": {
            "type": "string",
            "title": "Invoice Template ID",
            "description": "Unique ID to identify an invoice template.  Available when the site is on a Pro or Elite plan.  Used to specify which invoice template, if any, should be used to generate invoices for the account."
          },
          "address": {
            "$ref": "#/components/schemas/Address"
          },
          "billing_info": {
            "$ref": "#/components/schemas/BillingInfoCreate"
          },
          "custom_fields": {
            "$ref": "#/components/schemas/CustomFields"
          },
          "entity_use_code": {
            "type": "string",
            "description": "The Avalara AvaTax value that can be passed to identify the customer type for tax purposes. The range of values can be A - R (more info at Avalara). Value is case-sensitive."
          }
        }
      },
      "AccountResponse": {
        "type": "object",
        "properties": {
          "code": {
            "type": "string",
            "description": "The unique identifier of the account. This cannot be changed once the account is created.",
            "maxLength": 50,
            "readOnly": true
          },
          "username": {
            "type": "string",
            "description": "A secondary value for the account.",
            "maxLength": 255
          },
          "email": {
            "type": "string",
            "format": "email",
            "description": "The email address used for communicating with this customer. The customer will also use this email address to log into your hosted account management pages. This value does not need to be unique.",
            "maxLength": 255
          },
          "override_business_entity_id": {
            "type": "string",
            "title": "Override Business Entity ID",
            "description": "Unique ID to identify the business entity assigned to the account. Available when the `Multiple Business Entities` feature is enabled."
          },
          "preferred_locale": {
            "description": "Used to determine the language and locale of emails sent on behalf of the merchant to the customer.",
            "type": "string",
            "enum": [
              "da-DK",
              "de-CH",
              "de-DE",
              "en-AU",
              "en-CA",
              "en-GB",
              "en-IE",
              "en-NZ",
              "en-US",
              "es-ES",
              "es-MX",
              "es-US",
              "fi-FI",
              "fr-BE",
              "fr-CA",
              "fr-CH",
              "fr-FR",
              "hi-IN",
              "it-IT",
              "ja-JP",
              "ko-KR",
              "nl-BE",
              "nl-NL",
              "pl-PL",
              "pt-BR",
              "pt-PT",
              "ro-RO",
              "ru-RU",
              "sk-SK",
              "sv-SE",
              "tr-TR",
              "zh-CN"
            ]
          },
          "preferred_time_zone": {
            "type": "string",
            "example": "America/Los_Angeles",
            "description": "The [IANA time zone name](https://docs.recurly.com/docs/email-time-zones-and-time-stamps#supported-api-iana-time-zone-names) used to determine the time zone of emails sent on behalf of the merchant to the customer."
          },
          "cc_emails": {
            "type": "string",
            "description": "Additional email address that should receive account correspondence. These should be separated only by commas. These CC emails will receive all emails that the `email` field also receives.",
            "maxLength": 255
          },
          "first_name": {
            "type": "string",
            "maxLength": 255
          },
          "last_name": {
            "type": "string",
            "maxLength": 255
          },
          "company": {
            "type": "string",
            "maxLength": 50
          },
          "vat_number": {
            "type": "string",
            "description": "The VAT number of the account (to avoid having the VAT applied). This is only used for manually collected invoices.",
            "maxLength": 20
          },
          "tax_exempt": {
            "type": "boolean",
            "description": "The tax status of the account. `true` exempts tax on the account, `false` applies tax on the account."
          },
          "exemption_certificate": {
            "type": "string",
            "description": "The tax exemption certificate number for the account. If the merchant has an integration for the Vertex tax provider, this optional value will be sent in any tax calculation requests for the account.",
            "maxLength": 30
          },
          "external_accounts": {
            "type": "array",
            "description": "The external accounts belonging to this account",
            "items": {
              "$ref": "#/components/schemas/ExternalAccount"
            }
          },
          "parent_account_id": {
            "type": "string",
            "maxLength": 13,
            "description": "The UUID of the parent account associated with this account."
          },
          "bill_to": {
            "maxLength": 6,
            "description": "An enumerable describing the billing behavior of the account, specifically whether the account is self-paying or will rely on the parent account to pay.",
            "type": "string",
            "enum": [
              "parent",
              "self"
            ]
          },
          "dunning_campaign_id": {
            "type": "string",
            "title": "Dunning Campaign ID",
            "description": "Unique ID to identify a dunning campaign. Used to specify if a non-default dunning campaign should be assigned to this account. For sites without multiple dunning campaigns enabled, the default dunning campaign will always be used."
          },
          "invoice_template_id": {
            "type": "string",
            "title": "Invoice Template ID",
            "description": "Unique ID to identify an invoice template. Available when the site is on a Pro or Elite plan. Used to specify if a non-default invoice template will be used to generate invoices for the account. For sites without multiple invoice templates enabled, the default template will always be used."
          },
          "address": {
            "$ref": "#/components/schemas/Address"
          },
          "billing_info": {
            "$ref": "#/components/schemas/BillingInfo"
          },
          "custom_fields": {
            "$ref": "#/components/schemas/CustomFields"
          },
          "entity_use_code": {
            "type": "string",
            "description": "The Avalara AvaTax value that can be passed to identify the customer type for tax purposes. The range of values can be A - R (more info at Avalara). Value is case-sensitive."
          }
        }
      },
      "AccountNote": {
        "type": "object",
        "required": [
          "message"
        ],
        "properties": {
          "id": {
            "type": "string",
            "maxLength": 13,
            "readOnly": true
          },
          "object": {
            "type": "string",
            "title": "Object type",
            "readOnly": true
          },
          "account_id": {
            "type": "string"
          },
          "user": {
            "$ref": "#/components/schemas/User"
          },
          "message": {
            "type": "string"
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "readOnly": true
          }
        }
      },
      "AccountMini": {
        "type": "object",
        "title": "Account mini details",
        "properties": {
          "id": {
            "type": "string",
            "maxLength": 13,
            "readOnly": true
          },
          "object": {
            "type": "string",
            "title": "Object type",
            "readOnly": true
          },
          "code": {
            "type": "string",
            "description": "The unique identifier of the account.",
            "maxLength": 50
          },
          "email": {
            "type": "string",
            "format": "email",
            "description": "The email address used for communicating with this customer.",
            "maxLength": 255
          },
          "first_name": {
            "type": "string",
            "maxLength": 255
          },
          "last_name": {
            "type": "string",
            "maxLength": 255
          },
          "company": {
            "type": "string",
            "maxLength": 255
          },
          "parent_account_id": {
            "type": "string",
            "maxLength": 13
          },
          "bill_to": {
            "type": "string",
            "maxLength": 6
          },
          "dunning_campaign_id": {
            "type": "string",
            "title": "Dunning Campaign ID",
            "description": "Unique ID to identify a dunning campaign. Used to specify if a non-default dunning campaign should be assigned to this account. For sites without multiple dunning campaigns enabled, the default dunning campaign will always be used."
          }
        }
      },
      "AccountBalance": {
        "type": "object",
        "properties": {
          "object": {
            "type": "string",
            "title": "Object type",
            "readOnly": true
          },
          "account": {
            "$ref": "#/components/schemas/AccountMini"
          },
          "past_due": {
            "type": "boolean"
          },
          "balances": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/AccountBalanceAmount"
            }
          }
        }
      },
      "AccountBalanceAmount": {
        "type": "object",
        "title": "Balance Amount",
        "properties": {
          "currency": {
            "type": "string",
            "title": "Currency",
            "description": "3-letter ISO 4217 currency code.",
            "maxLength": 3
          },
          "amount": {
            "type": "number",
            "format": "float",
            "title": "Amount",
            "description": "Total amount the account is past due."
          },
          "processing_prepayment_amount": {
            "type": "number",
            "format": "float",
            "title": "Processing Prepayment Amount",
            "description": "Total amount for the prepayment credit invoices in a `processing` state on the account."
          },
          "available_credit_amount": {
            "type": "number",
            "format": "float",
            "title": "Available Credit Amount",
            "description": "Total amount of the open balances on credit invoices for the account."
          }
        }
      },
      "InvoiceAddress": {
        "allOf": [
          {
            "$ref": "#/components/schemas/Address"
          },
          {
            "$ref": "#/components/schemas/AddressWithName"
          }
        ],
        "type": "object",
        "properties": {
          "name_on_account": {
            "type": "string",
            "title": "Name on account"
          },
          "company": {
            "type": "string",
            "title": "Company"
          }
        }
      },
      "Address": {
        "type": "object",
        "properties": {
          "phone": {
            "type": "string",
            "title": "Phone number"
          },
          "street1": {
            "type": "string",
            "title": "Street 1"
          },
          "street2": {
            "type": "string",
            "title": "Street 2"
          },
          "city": {
            "type": "string",
            "title": "City"
          },
          "region": {
            "type": "string",
            "title": "State/Province",
            "description": "State or province."
          },
          "postal_code": {
            "type": "string",
            "title": "Zip/Postal code",
            "description": "Zip or postal code."
          },
          "country": {
            "type": "string",
            "title": "Country",
            "description": "Country, 2-letter ISO 3166-1 alpha-2 code."
          },
          "geo_code": {
            "type": "string",
            "maxLength": 20,
            "description": "Code that represents a geographic entity (location or object). Only returned for Sling Vertex Integration"
          }
        }
      },
      "AddressWithName": {
        "allOf": [
          {
            "$ref": "#/components/schemas/Address"
          }
        ],
        "type": "object",
        "properties": {
          "first_name": {
            "type": "string",
            "title": "First name"
          },
          "last_name": {
            "type": "string",
            "title": "Last name"
          }
        }
      },
      "AddOnMini": {
        "type": "object",
        "title": "Add-on mini details",
        "description": "Just the important parts.",
        "properties": {
          "id": {
            "type": "string",
            "title": "Add-on ID",
            "maxLength": 13,
            "readOnly": true
          },
          "object": {
            "type": "string",
            "title": "Object type",
            "readOnly": true
          },
          "code": {
            "type": "string",
            "title": "Add-on code",
            "description": "The unique identifier for the add-on within its plan.",
            "maxLength": 50
          },
          "name": {
            "type": "string",
            "title": "Name",
            "description": "Describes your add-on and will appear in subscribers' invoices.",
            "maxLength": 255
          },
          "add_on_type": {
            "type": "string",
            "enum": [
              "fixed",
              "usage"
            ],
            "title": "Add-on Type",
            "description": "Whether the add-on type is fixed, or usage-based."
          },
          "usage_type": {
            "type": "string",
            "enum": [
              "price",
              "percentage"
            ],
            "title": "Usage Type",
            "description": "Type of usage, returns usage type if `add_on_type` is `usage`."
          },
          "usage_percentage": {
            "type": "number",
            "format": "float",
            "title": "Usage Percentage",
            "description": "The percentage taken of the monetary amount of usage tracked. This can be up to 4 decimal places. A value between 0.0 and 100.0."
          },
          "measured_unit_id": {
            "type": "string",
            "title": "Measured Unit ID",
            "description": "System-generated unique identifier for an measured unit associated with the add-on.",
            "maxLength": 13
          },
          "item_id": {
            "type": "string",
            "title": "Item ID",
            "maxLength": 13,
            "readOnly": true
          },
          "external_sku": {
            "type": "string",
            "title": "External SKU",
            "description": "Optional, stock keeping unit to link the item to other inventory systems.",
            "maxLength": 50,
            "readOnly": true
          },
          "accounting_code": {
            "type": "string",
            "title": "Accounting code",
            "description": "Accounting code for invoice line items for this add-on. If no value is provided, it defaults to add-on's code.",
            "pattern": "/^[a-z0-9_+-]+$/",
            "maxLength": 20
          }
        }
      },
      "AddOn": {
        "type": "object",
        "title": "Add-on",
        "description": "Full add-on details.",
        "properties": {
          "id": {
            "type": "string",
            "title": "Add-on ID",
            "maxLength": 13,
            "readOnly": true
          },
          "object": {
            "type": "string",
            "title": "Object type",
            "readOnly": true
          },
          "plan_id": {
            "type": "string",
            "title": "Plan ID",
            "maxLength": 13,
            "readOnly": true
          },
          "code": {
            "type": "string",
            "title": "Add-on code",
            "description": "The unique identifier for the add-on within its plan.",
            "maxLength": 50
          },
          "state": {
            "title": "State",
            "description": "Add-ons can be either active or inactive.",
            "readOnly": true,
            "type": "string",
            "enum": [
              "active",
              "inactive"
            ]
          },
          "name": {
            "type": "string",
            "title": "Name",
            "description": "Describes your add-on and will appear in subscribers' invoices.",
            "maxLength": 255
          },
          "add_on_type": {
            "type": "string",
            "enum": [
              "fixed",
              "usage"
            ],
            "title": "Add-on Type",
            "description": "Whether the add-on type is fixed, or usage-based."
          },
          "usage_type": {
            "type": "string",
            "enum": [
              "price",
              "percentage"
            ],
            "title": "Usage Type",
            "description": "Type of usage, returns usage type if `add_on_type` is `usage`."
          },
          "usage_calculation_type": {
            "type": "string",
            "description": "The type of calculation to be employed for an add-on.  Cumulative billing will sum all usage records created in the current billing cycle.  Last-in-period billing will apply only the most recent usage record in the billing period.  If no value is specified, cumulative billing will be used.",
            "enum": [
              "cumulative",
              "last_in_period"
            ]
          },
          "usage_percentage": {
            "type": "number",
            "format": "float",
            "title": "Usage Percentage",
            "description": "The percentage taken of the monetary amount of usage tracked. This can be up to 4 decimal places. A value between 0.0 and 100.0."
          },
          "measured_unit_id": {
            "type": "string",
            "title": "Measured Unit ID",
            "description": "System-generated unique identifier for an measured unit associated with the add-on.",
            "maxLength": 13
          },
          "liability_gl_account_id": {
            "type": "string",
            "title": "General Ledger Account ID",
            "description": "The ID of a general ledger account. General ledger accounts are\nonly accessible as a part of the Recurly RevRec Standard and\nRecurly RevRec Advanced features.\n",
            "maxLength": 13
          },
          "revenue_gl_account_id": {
            "type": "string",
            "title": "General Ledger Account ID",
            "description": "The ID of a general ledger account. General ledger accounts are\nonly accessible as a part of the Recurly RevRec Standard and\nRecurly RevRec Advanced features.\n",
            "maxLength": 13
          },
          "performance_obligation_id": {
            "type": "string",
            "title": "Performance Obligation ID",
            "description": "The ID of a performance obligation. Performance obligations are\nonly accessible as a part of the Recurly RevRec Standard and\nRecurly RevRec Advanced features.\n",
            "maxLength": 13
          },
          "accounting_code": {
            "type": "string",
            "title": "Accounting code",
            "description": "Accounting code for invoice line items for this add-on. If no value is provided, it defaults to add-on's code.",
            "pattern": "/^[a-z0-9_+-]+$/",
            "maxLength": 20
          },
          "revenue_schedule_type": {
            "title": "Revenue schedule type",
            "description": "When this add-on is invoiced, the line item will use this revenue schedule. If `item_code`/`item_id` is part of the request then `revenue_schedule_type` must be absent in the request as the value will be set from the item.",
            "type": "string",
            "enum": [
              "at_range_end",
              "at_range_start",
              "evenly",
              "never"
            ]
          },
          "avalara_transaction_type": {
            "type": "integer",
            "title": "Avalara Transaction Type",
            "description": "Used by Avalara for Communications taxes. The transaction type in combination with the service type describe how the add-on is taxed. Refer to [the documentation](https://help.avalara.com/AvaTax_for_Communications/Tax_Calculation/AvaTax_for_Communications_Tax_Engine/Mapping_Resources/TM_00115_AFC_Modules_Corresponding_Transaction_Types) for more available t/s types.",
            "minimum": 0
          },
          "avalara_service_type": {
            "type": "integer",
            "title": "Avalara Service Type",
            "description": "Used by Avalara for Communications taxes. The transaction type in combination with the service type describe how the add-on is taxed. Refer to [the documentation](https://help.avalara.com/AvaTax_for_Communications/Tax_Calculation/AvaTax_for_Communications_Tax_Engine/Mapping_Resources/TM_00115_AFC_Modules_Corresponding_Transaction_Types) for more available t/s types.",
            "minimum": 0
          },
          "tax_code": {
            "type": "string",
            "maxLength": 50,
            "title": "Tax code",
            "description": "Optional field used by Avalara, Vertex, and Recurly's In-the-Box tax solution to determine taxation rules. You can pass in specific tax codes using any of these tax integrations. For Recurly's In-the-Box tax offering you can also choose to instead use simple values of `unknown`, `physical`, or `digital` tax codes. If `item_code`/`item_id` is part of the request then `tax_code` must be absent."
          },
          "display_quantity": {
            "type": "boolean",
            "title": "Display quantity?",
            "description": "Determines if the quantity field is displayed on the hosted pages for the add-on.",
            "default": false
          },
          "default_quantity": {
            "type": "integer",
            "title": "Default quantity",
            "description": "Default quantity for the hosted pages.",
            "default": 1
          },
          "optional": {
            "type": "boolean",
            "title": "Optional",
            "description": "Whether the add-on is optional for the customer to include in their purchase on the hosted payment page. If false, the add-on will be included when a subscription is created through the Recurly UI. However, the add-on will not be included when a subscription is created through the API."
          },
          "currencies": {
            "type": "array",
            "title": "Add-on pricing",
            "items": {
              "$ref": "#/components/schemas/AddOnPricing"
            },
            "minItems": 1
          },
          "item": {
            "$ref": "#/components/schemas/ItemMini",
            "readOnly": true
          },
          "tier_type": {
            "type": "string",
            "title": "Tier type",
            "description": "The pricing model for the add-on.  For more information,\n[click here](https://docs.recurly.com/docs/billing-models#section-quantity-based). See our\n[Guide](https://recurly.com/developers/guides/item-addon-guide.html) for an overview of how\nto configure quantity-based pricing models.\n",
            "default": "flat",
            "enum": [
              "flat",
              "tiered",
              "stairstep",
              "volume"
            ]
          },
          "usage_timeframe": {
            "type": "string",
            "title": "Usage Timeframe",
            "description": "The time at which usage totals are reset for billing purposes.",
            "enum": [
              "billing_period",
              "subscription_term"
            ],
            "default": "billing_period"
          },
          "tiers": {
            "type": "array",
            "title": "Tiers",
            "items": {
              "$ref": "#/components/schemas/Tier"
            }
          },
          "percentage_tiers": {
            "type": "array",
            "title": "Percentage Tiers",
            "description": "This feature is currently in development and requires approval and enablement, please contact support.",
            "items": {
              "$ref": "#/components/schemas/PercentageTiersByCurrency"
            }
          },
          "external_sku": {
            "type": "string",
            "title": "External SKU",
            "description": "Optional, stock keeping unit to link the item to other inventory systems.",
            "maxLength": 50,
            "readOnly": true
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "title": "Created at",
            "readOnly": true
          },
          "updated_at": {
            "type": "string",
            "format": "date-time",
            "title": "Last updated at",
            "readOnly": true
          },
          "deleted_at": {
            "type": "string",
            "format": "date-time",
            "title": "Deleted at",
            "readOnly": true
          }
        },
        "required": [
          "code",
          "name"
        ]
      },
      "AddOnCreate": {
        "type": "object",
        "title": "Add-on",
        "description": "Full add-on details.",
        "properties": {
          "item_code": {
            "type": "string",
            "title": "Item Code",
            "description": "Unique code to identify an item. Available when the `Credit Invoices` feature is enabled. If `item_id` and `item_code` are both present, `item_id` will be used.",
            "pattern": "/^[a-z0-9_+-]+$/",
            "maxLength": 50
          },
          "item_id": {
            "type": "string",
            "title": "Item ID",
            "description": "System-generated unique identifier for an item. Available when the `Credit Invoices` feature is enabled. If `item_id` and `item_code` are both present, `item_id` will be used.",
            "maxLength": 13
          },
          "code": {
            "type": "string",
            "title": "Add-on code",
            "description": "The unique identifier for the add-on within its plan. If `item_code`/`item_id` is part of the request then `code` must be absent. If `item_code`/`item_id` is not present `code` is required.",
            "maxLength": 50
          },
          "name": {
            "type": "string",
            "title": "Name",
            "description": "Describes your add-on and will appear in subscribers' invoices. If `item_code`/`item_id` is part of the request then `name` must be absent. If `item_code`/`item_id` is not present `name` is required.",
            "maxLength": 255
          },
          "add_on_type": {
            "type": "string",
            "enum": [
              "fixed",
              "usage"
            ],
            "title": "Add-on Type",
            "description": "Whether the add-on type is fixed, or usage-based.",
            "default": "fixed"
          },
          "usage_type": {
            "type": "string",
            "enum": [
              "price",
              "percentage"
            ],
            "title": "Usage Type",
            "description": "Type of usage, required if `add_on_type` is `usage`. See our\n[Guide](https://recurly.com/developers/guides/usage-based-billing-guide.html) for an\noverview of how to configure usage add-ons.\n"
          },
          "usage_calculation_type": {
            "type": "string",
            "description": "The type of calculation to be employed for an add-on.  Cumulative billing will sum all usage records created in the current billing cycle.  Last-in-period billing will apply only the most recent usage record in the billing period.  If no value is specified, cumulative billing will be used.",
            "enum": [
              "cumulative",
              "last_in_period"
            ]
          },
          "usage_percentage": {
            "type": "number",
            "format": "float",
            "title": "Usage Percentage",
            "description": "The percentage taken of the monetary amount of usage tracked. This can be up to 4 decimal places. A value between 0.0 and 100.0. Required if `add_on_type` is usage, `tier_type` is `flat` and `usage_type` is percentage. Must be omitted otherwise."
          },
          "measured_unit_id": {
            "type": "string",
            "title": "Measured Unit ID",
            "description": "System-generated unique identifier for a measured unit to be associated with the add-on. Either `measured_unit_id` or `measured_unit_name` are required when `add_on_type` is `usage`. If `measured_unit_id` and `measured_unit_name` are both present, `measured_unit_id` will be used.",
            "maxLength": 13
          },
          "measured_unit_name": {
            "type": "string",
            "title": "Measured Unit Name",
            "description": "Name of a measured unit to be associated with the add-on. Either `measured_unit_id` or `measured_unit_name` are required when `add_on_type` is `usage`. If `measured_unit_id` and `measured_unit_name` are both present, `measured_unit_id` will be used."
          },
          "plan_id": {
            "type": "string",
            "title": "Plan ID",
            "maxLength": 13,
            "readOnly": true
          },
          "liability_gl_account_id": {
            "type": "string",
            "title": "General Ledger Account ID",
            "description": "The ID of a general ledger account. General ledger accounts are\nonly accessible as a part of the Recurly RevRec Standard and\nRecurly RevRec Advanced features.\n",
            "maxLength": 13
          },
          "revenue_gl_account_id": {
            "type": "string",
            "title": "General Ledger Account ID",
            "description": "The ID of a general ledger account. General ledger accounts are\nonly accessible as a part of the Recurly RevRec Standard and\nRecurly RevRec Advanced features.\n",
            "maxLength": 13
          },
          "performance_obligation_id": {
            "type": "string",
            "title": "Performance Obligation ID",
            "description": "The ID of a performance obligation. Performance obligations are\nonly accessible as a part of the Recurly RevRec Standard and\nRecurly RevRec Advanced features.\n",
            "maxLength": 13
          },
          "accounting_code": {
            "type": "string",
            "title": "Accounting code",
            "description": "Accounting code for invoice line items for this add-on. If no value is provided, it defaults to add-on's code. If `item_code`/`item_id` is part of the request then `accounting_code` must be absent.",
            "pattern": "/^[a-z0-9_+-]+$/",
            "maxLength": 20
          },
          "revenue_schedule_type": {
            "title": "Revenue schedule type",
            "description": "When this add-on is invoiced, the line item will use this revenue schedule. If `item_code`/`item_id` is part of the request then `revenue_schedule_type` must be absent in the request as the value will be set from the item.",
            "type": "string",
            "enum": [
              "at_range_end",
              "at_range_start",
              "evenly",
              "never"
            ]
          },
          "display_quantity": {
            "type": "boolean",
            "title": "Display quantity?",
            "description": "Determines if the quantity field is displayed on the hosted pages for the add-on.",
            "default": false
          },
          "default_quantity": {
            "type": "integer",
            "title": "Default quantity",
            "description": "Default quantity for the hosted pages.",
            "default": 1
          },
          "optional": {
            "type": "boolean",
            "title": "Optional",
            "description": "Whether the add-on is optional for the customer to include in their purchase on the hosted payment page. If false, the add-on will be included when a subscription is created through the Recurly UI. However, the add-on will not be included when a subscription is created through the API."
          },
          "avalara_transaction_type": {
            "type": "integer",
            "title": "Avalara Transaction Type",
            "description": "Used by Avalara for Communications taxes. The transaction type in combination with the service type describe how the add-on is taxed. Refer to [the documentation](https://help.avalara.com/AvaTax_for_Communications/Tax_Calculation/AvaTax_for_Communications_Tax_Engine/Mapping_Resources/TM_00115_AFC_Modules_Corresponding_Transaction_Types) for more available t/s types. If an `Item` is associated to the `AddOn`, then the `avalara_transaction_type` must be absent.",
            "minimum": 0
          },
          "avalara_service_type": {
            "type": "integer",
            "title": "Avalara Service Type",
            "description": "Used by Avalara for Communications taxes. The transaction type in combination with the service type describe how the add-on is taxed. Refer to [the documentation](https://help.avalara.com/AvaTax_for_Communications/Tax_Calculation/AvaTax_for_Communications_Tax_Engine/Mapping_Resources/TM_00115_AFC_Modules_Corresponding_Transaction_Types) for more available t/s types. If an `Item` is associated to the `AddOn`, then the `avalara_service_type` must be absent.",
            "minimum": 0
          },
          "tax_code": {
            "type": "string",
            "maxLength": 50,
            "title": "Tax code",
            "description": "Optional field used by Avalara, Vertex, and Recurly's In-the-Box tax solution to determine taxation rules. You can pass in specific tax codes using any of these tax integrations. For Recurly's In-the-Box tax offering you can also choose to instead use simple values of `unknown`, `physical`, or `digital` tax codes. If `item_code`/`item_id` is part of the request then `tax_code` must be absent."
          },
          "currencies": {
            "type": "array",
            "title": "Add-on pricing",
            "items": {
              "$ref": "#/components/schemas/AddOnPricing"
            },
            "minItems": 1,
            "description": "* If `item_code`/`item_id` is part of the request and the item\nhas a default currency, then `currencies` is optional. If the item does\nnot have a default currency, then `currencies` is required. If `item_code`/`item_id`\nis not present `currencies` is required.\n* If the add-on's `tier_type` is `tiered`, `volume`, or `stairstep`,\nthen `currencies` must be absent.\n* Must be absent if `add_on_type` is `usage` and `usage_type` is `percentage`.\n"
          },
          "tier_type": {
            "type": "string",
            "title": "Tier type",
            "description": "The pricing model for the add-on.  For more information,\n[click here](https://docs.recurly.com/docs/billing-models#section-quantity-based). See our\n[Guide](https://recurly.com/developers/guides/item-addon-guide.html) for an overview of how\nto configure quantity-based pricing models.\n",
            "default": "flat",
            "enum": [
              "flat",
              "tiered",
              "stairstep",
              "volume"
            ]
          },
          "usage_timeframe": {
            "type": "string",
            "title": "Usage Timeframe",
            "description": "The time at which usage totals are reset for billing purposes.\nAllows for `tiered` add-ons to accumulate usage over the course of multiple\nbilling periods.\n",
            "enum": [
              "billing_period",
              "subscription_term"
            ],
            "default": "billing_period"
          },
          "tiers": {
            "type": "array",
            "title": "Tiers",
            "items": {
              "$ref": "#/components/schemas/Tier"
            },
            "description": "If the tier_type is `flat`, then `tiers` must be absent. The `tiers` object\nmust include one to many tiers with `ending_quantity` and `unit_amount` for\nthe desired `currencies`. There must be one tier without an `ending_quantity` value\nwhich represents the final tier.\n"
          },
          "percentage_tiers": {
            "type": "array",
            "title": "Percentage Tiers By Currency",
            "items": {
              "$ref": "#/components/schemas/PercentageTiersByCurrency"
            },
            "description": "Array of objects which must have at least one set of tiers\nper currency and the currency code. The tier_type must be `volume` or `tiered`,\nif not, it must be absent. There must be one tier without an `ending_amount` value\nwhich represents the final tier. This feature is currently in development and\nrequires approval and enablement, please contact support.\n"
          }
        },
        "required": [
          "code",
          "name"
        ]
      },
      "AddOnUpdate": {
        "type": "object",
        "title": "Add-on",
        "description": "Full add-on details.",
        "properties": {
          "id": {
            "type": "string",
            "title": "Add-on ID",
            "maxLength": 13,
            "readOnly": true
          },
          "code": {
            "type": "string",
            "title": "Add-on code",
            "description": "The unique identifier for the add-on within its plan. If an `Item` is associated to the `AddOn` then `code` must be absent.",
            "maxLength": 50
          },
          "name": {
            "type": "string",
            "title": "Name",
            "description": "Describes your add-on and will appear in subscribers' invoices. If an `Item` is associated to the `AddOn` then `name` must be absent.",
            "maxLength": 255
          },
          "usage_percentage": {
            "type": "number",
            "format": "float",
            "title": "Usage Percentage",
            "description": "The percentage taken of the monetary amount of usage tracked. This can be up to 4 decimal places. A value between 0.0 and 100.0. Required if `add_on_type` is usage, `tier_type` is `flat` and `usage_type` is percentage. Must be omitted otherwise."
          },
          "usage_calculation_type": {
            "type": "string",
            "description": "The type of calculation to be employed for an add-on.  Cumulative billing will sum all usage records created in the current billing cycle.  Last-in-period billing will apply only the most recent usage record in the billing period.  If no value is specified, cumulative billing will be used.",
            "enum": [
              "cumulative",
              "last_in_period"
            ]
          },
          "measured_unit_id": {
            "type": "string",
            "title": "Measured Unit ID",
            "description": "System-generated unique identifier for a measured unit to be associated with the add-on. Either `measured_unit_id` or `measured_unit_name` are required when `add_on_type` is `usage`. If `measured_unit_id` and `measured_unit_name` are both present, `measured_unit_id` will be used.",
            "maxLength": 13
          },
          "measured_unit_name": {
            "type": "string",
            "title": "Measured Unit Name",
            "description": "Name of a measured unit to be associated with the add-on. Either `measured_unit_id` or `measured_unit_name` are required when `add_on_type` is `usage`. If `measured_unit_id` and `measured_unit_name` are both present, `measured_unit_id` will be used."
          },
          "accounting_code": {
            "type": "string",
            "title": "Accounting code",
            "description": "Accounting code for invoice line items for this add-on. If no value is provided, it defaults to add-on's code. If an `Item` is associated to the `AddOn` then `accounting code` must be absent.",
            "pattern": "/^[a-z0-9_+-]+$/",
            "maxLength": 20
          },
          "liability_gl_account_id": {
            "type": "string",
            "title": "General Ledger Account ID",
            "description": "The ID of a general ledger account. General ledger accounts are\nonly accessible as a part of the Recurly RevRec Standard and\nRecurly RevRec Advanced features.\n",
            "maxLength": 13
          },
          "revenue_gl_account_id": {
            "type": "string",
            "title": "General Ledger Account ID",
            "description": "The ID of a general ledger account. General ledger accounts are\nonly accessible as a part of the Recurly RevRec Standard and\nRecurly RevRec Advanced features.\n",
            "maxLength": 13
          },
          "performance_obligation_id": {
            "type": "string",
            "title": "Performance Obligation ID",
            "description": "The ID of a performance obligation. Performance obligations are\nonly accessible as a part of the Recurly RevRec Standard and\nRecurly RevRec Advanced features.\n",
            "maxLength": 13
          },
          "revenue_schedule_type": {
            "title": "Revenue schedule type",
            "description": "When this add-on is invoiced, the line item will use this revenue schedule. If `item_code`/`item_id` is part of the request then `revenue_schedule_type` must be absent in the request as the value will be set from the item.",
            "type": "string",
            "enum": [
              "at_range_end",
              "at_range_start",
              "evenly",
              "never"
            ]
          },
          "avalara_transaction_type": {
            "type": "integer",
            "title": "Avalara Transaction Type",
            "description": "Used by Avalara for Communications taxes. The transaction type in combination with the service type describe how the add-on is taxed. Refer to [the documentation](https://help.avalara.com/AvaTax_for_Communications/Tax_Calculation/AvaTax_for_Communications_Tax_Engine/Mapping_Resources/TM_00115_AFC_Modules_Corresponding_Transaction_Types) for more available t/s types. If an `Item` is associated to the `AddOn`, then the `avalara_transaction_type` must be absent.",
            "minimum": 0
          },
          "avalara_service_type": {
            "type": "integer",
            "title": "Avalara Service Type",
            "description": "Used by Avalara for Communications taxes. The transaction type in combination with the service type describe how the add-on is taxed. Refer to [the documentation](https://help.avalara.com/AvaTax_for_Communications/Tax_Calculation/AvaTax_for_Communications_Tax_Engine/Mapping_Resources/TM_00115_AFC_Modules_Corresponding_Transaction_Types) for more available t/s types. If an `Item` is associated to the `AddOn`, then the `avalara_service_type` must be absent.",
            "minimum": 0
          },
          "tax_code": {
            "type": "string",
            "maxLength": 50,
            "title": "Tax code",
            "description": "Optional field used by Avalara, Vertex, and Recurly's In-the-Box tax solution to determine taxation rules. You can pass in specific tax codes using any of these tax integrations. For Recurly's In-the-Box tax offering you can also choose to instead use simple values of `unknown`, `physical`, or `digital` tax codes. If an `Item` is associated to the `AddOn` then `tax_code` must be absent."
          },
          "display_quantity": {
            "type": "boolean",
            "title": "Display quantity?",
            "description": "Determines if the quantity field is displayed on the hosted pages for the add-on.",
            "default": false
          },
          "default_quantity": {
            "type": "integer",
            "title": "Default quantity",
            "description": "Default quantity for the hosted pages.",
            "default": 1
          },
          "optional": {
            "type": "boolean",
            "title": "Optional",
            "description": "Whether the add-on is optional for the customer to include in their purchase on the hosted payment page. If false, the add-on will be included when a subscription is created through the Recurly UI. However, the add-on will not be included when a subscription is created through the API."
          },
          "currencies": {
            "type": "array",
            "title": "Add-on pricing",
            "items": {
              "$ref": "#/components/schemas/AddOnPricing"
            },
            "minItems": 1,
            "description": "If the add-on's `tier_type` is `tiered`, `volume`, or `stairstep`,\nthen currencies must be absent. Must also be absent if `add_on_type` is\n`usage` and `usage_type` is `percentage`.\n"
          },
          "tiers": {
            "type": "array",
            "title": "Tiers",
            "items": {
              "$ref": "#/components/schemas/Tier"
            },
            "description": "If the tier_type is `flat`, then `tiers` must be absent. The `tiers` object\nmust include one to many tiers with `ending_quantity` and `unit_amount` for\nthe desired `currencies`. There must be one tier without an `ending_quantity` value\nwhich represents the final tier.\n"
          },
          "percentage_tiers": {
            "type": "array",
            "title": "Percentage Tiers By Currency",
            "items": {
              "$ref": "#/components/schemas/PercentageTiersByCurrency"
            },
            "description": "`percentage_tiers` is an array of objects, which must have the set of tiers\nper currency and the currency code. The tier_type must be `volume` or `tiered`,\nif not, it must be absent. There must be one tier without an `ending_amount` value\nwhich represents the final tier. This feature is currently in development and\nrequires approval and enablement, please contact support.\n"
          }
        }
      },
      "BillingInfo": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "maxLength": 13,
            "readOnly": true
          },
          "object": {
            "type": "string",
            "title": "Object type",
            "readOnly": true
          },
          "account_id": {
            "type": "string",
            "maxLength": 13,
            "readOnly": true
          },
          "first_name": {
            "type": "string",
            "maxLength": 50
          },
          "last_name": {
            "type": "string",
            "maxLength": 50
          },
          "company": {
            "type": "string",
            "maxLength": 100
          },
          "address": {
            "$ref": "#/components/schemas/Address"
          },
          "vat_number": {
            "type": "string",
            "description": "Customer's VAT number (to avoid having the VAT applied). This is only used for automatically collected invoices."
          },
          "valid": {
            "type": "boolean",
            "readOnly": true
          },
          "payment_method": {
            "$ref": "#/components/schemas/PaymentMethod"
          },
          "fraud": {
            "type": "object",
            "x-class-name": "FraudInfo",
            "title": "Fraud information",
            "description": "Most recent fraud result.",
            "readOnly": true,
            "properties": {
              "score": {
                "type": "integer",
                "title": "Kount score",
                "minimum": 1,
                "maximum": 99
              },
              "decision": {
                "title": "Kount decision",
                "maxLength": 10,
                "type": "string",
                "enum": [
                  "approve",
                  "decline",
                  "escalate",
                  "review"
                ]
              },
              "risk_rules_triggered": {
                "type": "object",
                "title": "Kount rules"
              }
            }
          },
          "primary_payment_method": {
            "type": "boolean",
            "description": "The `primary_payment_method` field is used to indicate the primary billing info on the account. The first billing info created on an account will always become primary. This payment method will be used"
          },
          "backup_payment_method": {
            "type": "boolean",
            "description": "The `backup_payment_method` field is used to indicate a billing info as a backup on the account that will be tried if the initial billing info used for an invoice is declined."
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "description": "When the billing information was created.",
            "readOnly": true
          },
          "updated_at": {
            "type": "string",
            "format": "date-time",
            "description": "When the billing information was last changed.",
            "readOnly": true
          },
          "updated_by": {
            "type": "object",
            "x-class-name": "BillingInfoUpdatedBy",
            "readOnly": true,
            "properties": {
              "ip": {
                "type": "string",
                "description": "Customer's IP address when updating their billing information.",
                "maxLength": 20
              },
              "country": {
                "type": "string",
                "description": "Country, 2-letter ISO 3166-1 alpha-2 code matching the origin IP address, if known by Recurly.",
                "maxLength": 2
              }
            }
          }
        }
      },
      "BillingInfoCreate": {
        "type": "object",
        "properties": {
          "token_id": {
            "type": "string",
            "title": "Token ID",
            "description": "A token [generated by Recurly.js](https://recurly.com/developers/reference/recurly-js/#getting-a-token).",
            "maxLength": 22
          },
          "first_name": {
            "type": "string",
            "title": "First name",
            "maxLength": 50
          },
          "last_name": {
            "type": "string",
            "title": "Last name",
            "maxLength": 50
          },
          "company": {
            "type": "string",
            "title": "Company name",
            "maxLength": 100
          },
          "address": {
            "$ref": "#/components/schemas/Address"
          },
          "number": {
            "type": "string",
            "title": "Credit card number",
            "description": "Credit card number, spaces and dashes are accepted."
          },
          "month": {
            "type": "string",
            "title": "Expiration month",
            "maxLength": 2
          },
          "year": {
            "type": "string",
            "title": "Expiration year",
            "maxLength": 4
          },
          "cvv": {
            "type": "string",
            "title": "Security code or CVV",
            "description": "*STRONGLY RECOMMENDED*",
            "maxLength": 4
          },
          "currency": {
            "type": "string",
            "description": "3-letter ISO 4217 currency code."
          },
          "vat_number": {
            "type": "string",
            "title": "VAT number"
          },
          "ip_address": {
            "type": "string",
            "title": "IP address",
            "description": "*STRONGLY RECOMMENDED* Customer's IP address when updating their billing information.",
            "maxLength": 20
          },
          "gateway_token": {
            "type": "string",
            "title": "A token used in place of a credit card in order to perform transactions. Must be used in conjunction with `gateway_code`.",
            "maxLength": 50
          },
          "gateway_code": {
            "type": "string",
            "title": "An identifier for a specific payment gateway. Must be used in conjunction with `gateway_token`.",
            "maxLength": 12
          },
          "gateway_attributes": {
            "type": "object",
            "description": "Additional attributes to send to the gateway.",
            "x-class-name": "GatewayAttributes",
            "properties": {
              "account_reference": {
                "type": "string",
                "description": "Used by Adyen and Braintree gateways. For Adyen the Shopper Reference value used when the external token was created. Must be used in conjunction with gateway_token and gateway_code. For Braintree the PayPal PayerID is populated in the response.",
                "maxLength": 264
              }
            }
          },
          "amazon_billing_agreement_id": {
            "type": "string",
            "title": "Amazon billing agreement ID"
          },
          "paypal_billing_agreement_id": {
            "type": "string",
            "title": "PayPal billing agreement ID"
          },
          "roku_billing_agreement_id": {
            "type": "string",
            "title": "Roku's CIB if billing through Roku"
          },
          "fraud_session_id": {
            "type": "string",
            "title": "Fraud Session ID"
          },
          "transaction_type": {
            "description": "An optional type designation for the payment gateway transaction created by this request. Supports 'moto' value, which is the acronym for mail order and telephone transactions.",
            "type": "string",
            "enum": [
              "moto"
            ]
          },
          "three_d_secure_action_result_token_id": {
            "type": "string",
            "title": "3-D Secure action result token ID",
            "description": "A token generated by Recurly.js after completing a 3-D Secure device fingerprinting or authentication challenge.",
            "maxLength": 22
          },
          "iban": {
            "type": "string",
            "maxLength": 34,
            "description": "The International Bank Account Number, up to 34 alphanumeric characters comprising a country code; two check digits; and a number that includes the domestic bank account number, branch identifier, and potential routing information"
          },
          "name_on_account": {
            "type": "string",
            "maxLength": 255,
            "description": "The name associated with the bank account (ACH, SEPA, Bacs only)"
          },
          "account_number": {
            "type": "string",
            "maxLength": 255,
            "description": "The bank account number. (ACH, Bacs only)"
          },
          "routing_number": {
            "type": "string",
            "maxLength": 15,
            "description": "The bank's rounting number. (ACH only)"
          },
          "sort_code": {
            "type": "string",
            "maxLength": 15,
            "description": "Bank identifier code for UK based banks. Required for Bacs based billing infos. (Bacs only)"
          },
          "type": {
            "type": "string",
            "description": "The payment method type for a non-credit card based billing info. `bacs` and `becs` are the only accepted values.",
            "enum": [
              "bacs",
              "becs"
            ]
          },
          "account_type": {
            "type": "string",
            "description": "The bank account type. (ACH only)",
            "enum": [
              "checking",
              "savings"
            ]
          },
          "tax_identifier": {
            "type": "string",
            "description": "Tax identifier is required if adding a billing info that is a consumer card in Brazil or in Argentina. This would be the customer's CPF/CNPJ (Brazil) and CUIT (Argentina). CPF, CNPJ and CUIT are tax identifiers for all residents who pay taxes in Brazil and Argentina respectively."
          },
          "tax_identifier_type": {
            "description": "This field and a value of `cpf`, `cnpj` or `cuit` are required if adding a billing info that is an elo or hipercard type in Brazil or in Argentina.",
            "type": "string",
            "enum": [
              "cpf",
              "cnpj",
              "cuit"
            ]
          },
          "primary_payment_method": {
            "type": "boolean",
            "title": "Primary Payment Method",
            "description": "The `primary_payment_method` field is used to designate the primary billing info on the account. The first billing info created on an account will always become primary. Adding additional billing infos provides the flexibility to mark another billing info as primary, or adding additional non-primary billing infos. This can be accomplished by passing the `primary_payment_method` with a value of `true`. When adding billing infos via the billing_info and /accounts endpoints, this value is not permitted, and will return an error if provided."
          },
          "backup_payment_method": {
            "type": "boolean",
            "description": "The `backup_payment_method` field is used to designate a billing info as a backup on the account that will be tried if the initial billing info used for an invoice is declined. All payment methods, including the billing info marked `primary_payment_method` can be set as a backup. An account can have a maximum of 1 backup, if a user sets a different payment method as a backup, the existing backup will no longer be marked as such."
          },
          "external_hpp_type": {
            "type": "string",
            "description": "Use for Adyen HPP billing info. This should only be used as part of a pending purchase request, when the billing info is nested inside an account object.",
            "enum": [
              "adyen"
            ]
          },
          "online_banking_payment_type": {
            "deprecated": true,
            "type": "string",
            "description": "Use for Online Banking billing info. This should only be used as part of a pending purchase request, when the billing info is nested inside an account object.",
            "enum": [
              "ideal",
              "sofort"
            ]
          },
          "card_type": {
            "type": "string",
            "enum": [
              "American Express",
              "Dankort",
              "Diners Club",
              "Discover",
              "ELO",
              "Forbrugsforeningen",
              "Hipercard",
              "JCB",
              "Laser",
              "Maestro",
              "MasterCard",
              "Test Card",
              "Union Pay",
              "Unknown",
              "Visa",
              "Tarjeta Naranja"
            ]
          },
          "card_network_preference": {
            "description": "Represents the card network preference associated with the billing info for dual badged cards. Must be a supported card network.",
            "type": "string",
            "enum": [
              "Bancontact",
              "CartesBancaires",
              "Dankort",
              "MasterCard",
              "Visa"
            ]
          }
        }
      },
      "BillingInfoVerify": {
        "type": "object",
        "properties": {
          "gateway_code": {
            "type": "string",
            "description": "An identifier for a specific payment gateway.",
            "maxLength": 13
          }
        }
      },
      "BillingInfoVerifyCVV": {
        "type": "object",
        "properties": {
          "verification_value": {
            "type": "string",
            "description": "Unique security code for a credit card."
          }
        }
      },
      "Coupon": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "title": "Coupon ID",
            "readOnly": true
          },
          "object": {
            "type": "string",
            "title": "Object type",
            "readOnly": true
          },
          "code": {
            "type": "string",
            "title": "Coupon code",
            "description": "The code the customer enters to redeem the coupon."
          },
          "name": {
            "type": "string",
            "title": "Name",
            "description": "The internal name for the coupon."
          },
          "state": {
            "title": "State",
            "description": "Indicates if the coupon is redeemable, and if it is not, why.",
            "type": "string",
            "enum": [
              "expired",
              "maxed_out",
              "redeemable"
            ]
          },
          "max_redemptions": {
            "type": "integer",
            "title": "Max redemptions",
            "description": "A maximum number of redemptions for the coupon. The coupon will expire when it hits its maximum redemptions."
          },
          "max_redemptions_per_account": {
            "type": "integer",
            "title": "Max redemptions per account",
            "description": "Redemptions per account is the number of times a specific account can redeem the coupon. Set redemptions per account to `1` if you want to keep customers from gaming the system and getting more than one discount from the coupon campaign."
          },
          "unique_coupon_codes_count": {
            "type": "integer",
            "title": "Unique coupon codes count",
            "description": "When this number reaches `max_redemptions` the coupon will no longer be redeemable.",
            "readOnly": true
          },
          "unique_code_template": {
            "type": "string",
            "title": "Unique code template",
            "description": "On a bulk coupon, the template from which unique coupon codes are generated."
          },
          "unique_coupon_code": {
            "allOf": [
              {
                "$ref": "#/components/schemas/UniqueCouponCode"
              }
            ],
            "type": "object",
            "description": "Will be populated when the Coupon being returned is a `UniqueCouponCode`."
          },
          "duration": {
            "title": "Duration",
            "description": "- \"single_use\" coupons applies to the first invoice only.\n- \"temporal\" coupons will apply to invoices for the duration determined by the `temporal_unit` and `temporal_amount` attributes.\n",
            "type": "string",
            "enum": [
              "forever",
              "single_use",
              "temporal"
            ]
          },
          "temporal_amount": {
            "type": "integer",
            "title": "Temporal amount",
            "description": "If `duration` is \"temporal\" than `temporal_amount` is an integer which is multiplied by `temporal_unit` to define the duration that the coupon will be applied to invoices for."
          },
          "temporal_unit": {
            "title": "Temporal unit",
            "description": "If `duration` is \"temporal\" than `temporal_unit` is multiplied by `temporal_amount` to define the duration that the coupon will be applied to invoices for.",
            "type": "string",
            "enum": [
              "day",
              "month",
              "week",
              "year"
            ]
          },
          "free_trial_unit": {
            "title": "Free trial unit",
            "description": "Description of the unit of time the coupon is for. Used with `free_trial_amount` to determine the duration of time the coupon is for.",
            "type": "string",
            "enum": [
              "day",
              "month",
              "week"
            ]
          },
          "free_trial_amount": {
            "type": "integer",
            "title": "Free trial amount",
            "description": "Sets the duration of time the `free_trial_unit` is for.",
            "minimum": 1,
            "maximum": 9999
          },
          "applies_to_all_plans": {
            "type": "boolean",
            "title": "Applies to all plans?",
            "description": "The coupon is valid for all plans if true. If false then `plans` will list the applicable plans.",
            "default": true
          },
          "applies_to_all_items": {
            "type": "boolean",
            "title": "Applies to all items?",
            "description": "The coupon is valid for all items if true. If false then `items`\nwill list the applicable items.\n",
            "default": false
          },
          "applies_to_non_plan_charges": {
            "type": "boolean",
            "title": "Applied to all non-plan charges?",
            "description": "The coupon is valid for one-time, non-plan charges if true.",
            "default": false
          },
          "plans": {
            "type": "array",
            "title": "Plans",
            "description": "A list of plans for which this coupon applies. This will be `null` if `applies_to_all_plans=true`.",
            "items": {
              "$ref": "#/components/schemas/PlanMini"
            }
          },
          "items": {
            "type": "array",
            "title": "Items",
            "description": "A list of items for which this coupon applies. This will be\n`null` if `applies_to_all_items=true`.\n",
            "items": {
              "$ref": "#/components/schemas/ItemMini"
            }
          },
          "redemption_resource": {
            "title": "Redemption resource",
            "description": "Whether the discount is for all eligible charges on the account, or only a specific subscription.",
            "default": "account",
            "type": "string",
            "enum": [
              "account",
              "subscription"
            ]
          },
          "discount": {
            "$ref": "#/components/schemas/CouponDiscount"
          },
          "coupon_type": {
            "title": "Coupon type (TODO: implement coupon generation)",
            "description": "Whether the coupon is \"single_code\" or \"bulk\". Bulk coupons will require a `unique_code_template` and will generate unique codes through the `/generate` endpoint.",
            "type": "string",
            "enum": [
              "bulk",
              "single_code"
            ]
          },
          "hosted_page_description": {
            "type": "string",
            "title": "Hosted Payment Pages description",
            "description": "This description will show up when a customer redeems a coupon on your Hosted Payment Pages, or if you choose to show the description on your own checkout page."
          },
          "invoice_description": {
            "type": "string",
            "title": "Invoice description",
            "description": "Description of the coupon on the invoice.",
            "maxLength": 255
          },
          "redeem_by": {
            "type": "string",
            "title": "Redeem by",
            "description": "The date and time the coupon will expire and can no longer be redeemed. Time is always 11:59:59, the end-of-day Pacific time.",
            "format": "date-time"
          },
          "created_at": {
            "type": "string",
            "title": "Created at",
            "format": "date-time",
            "readOnly": true
          },
          "updated_at": {
            "type": "string",
            "title": "Last updated at",
            "format": "date-time",
            "readOnly": true
          },
          "expired_at": {
            "type": "string",
            "title": "Expired at",
            "description": "The date and time the coupon was expired early or reached its `max_redemptions`.",
            "format": "date-time"
          }
        }
      },
      "CouponCreate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/CouponUpdate"
          },
          {
            "type": "object",
            "properties": {
              "code": {
                "type": "string",
                "title": "Coupon code",
                "description": "The code the customer enters to redeem the coupon."
              },
              "discount_type": {
                "title": "Discount type",
                "description": "The type of discount provided by the coupon (how the amount discounted is calculated)",
                "type": "string",
                "enum": [
                  "fixed",
                  "free_trial",
                  "percent"
                ]
              },
              "discount_percent": {
                "type": "integer",
                "title": "Discount percent",
                "description": "The percent of the price discounted by the coupon.  Required if `discount_type` is `percent`."
              },
              "free_trial_unit": {
                "title": "Free trial unit",
                "description": "Description of the unit of time the coupon is for. Used with `free_trial_amount` to determine the duration of time the coupon is for.  Required if `discount_type` is `free_trial`.",
                "type": "string",
                "enum": [
                  "day",
                  "month",
                  "week"
                ]
              },
              "free_trial_amount": {
                "type": "integer",
                "title": "Free trial amount",
                "description": "Sets the duration of time the `free_trial_unit` is for. Required if `discount_type` is `free_trial`.",
                "minimum": 1,
                "maximum": 9999
              },
              "currencies": {
                "title": "Currencies",
                "description": "Fixed discount currencies by currency. Required if the coupon type is `fixed`. This parameter should contain the coupon discount values",
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/CouponPricing"
                }
              },
              "applies_to_non_plan_charges": {
                "type": "boolean",
                "title": "Applied to all non-plan charges?",
                "description": "The coupon is valid for one-time, non-plan charges if true.",
                "default": false
              },
              "applies_to_all_plans": {
                "type": "boolean",
                "title": "Applies to all plans?",
                "description": "The coupon is valid for all plans if true. If false then `plans` will list the applicable plans.",
                "default": true
              },
              "applies_to_all_items": {
                "type": "boolean",
                "title": "Applies to all items?",
                "description": "To apply coupon to Items in your Catalog, include a list\nof `item_codes` in the request that the coupon will apply to. Or set value\nto true to apply to all Items in your Catalog. The following values\nare not permitted when `applies_to_all_items` is included: `free_trial_amount`\nand `free_trial_unit`.\n",
                "default": false
              },
              "plan_codes": {
                "type": "array",
                "title": "Plan codes",
                "description": "List of plan codes to which this coupon applies. Required\nif `applies_to_all_plans` is false. Overrides `applies_to_all_plans`\nwhen `applies_to_all_plans` is true.\n",
                "items": {
                  "type": "string"
                }
              },
              "item_codes": {
                "type": "array",
                "title": "Item codes",
                "description": "List of item codes to which this coupon applies. Sending\n`item_codes` is only permitted when `applies_to_all_items` is set to false.\nThe following values are not permitted when `item_codes` is included:\n`free_trial_amount` and `free_trial_unit`.\n",
                "items": {
                  "type": "string"
                }
              },
              "duration": {
                "title": "Duration",
                "description": "This field does not apply when the discount_type is `free_trial`.\n- \"single_use\" coupons applies to the first invoice only.\n- \"temporal\" coupons will apply to invoices for the duration determined by the `temporal_unit` and `temporal_amount` attributes.\n- \"forever\" coupons will apply to invoices forever.\n",
                "default": "forever",
                "type": "string",
                "enum": [
                  "forever",
                  "single_use",
                  "temporal"
                ]
              },
              "temporal_amount": {
                "type": "integer",
                "title": "Temporal amount",
                "description": "If `duration` is \"temporal\" than `temporal_amount` is an integer which is multiplied by `temporal_unit` to define the duration that the coupon will be applied to invoices for."
              },
              "temporal_unit": {
                "title": "Temporal unit",
                "description": "If `duration` is \"temporal\" than `temporal_unit` is multiplied by `temporal_amount` to define the duration that the coupon will be applied to invoices for.",
                "type": "string",
                "enum": [
                  "day",
                  "month",
                  "week",
                  "year"
                ]
              },
              "coupon_type": {
                "title": "Coupon type",
                "description": "Whether the coupon is \"single_code\" or \"bulk\". Bulk coupons will require a `unique_code_template` and will generate unique codes through the `/generate` endpoint.",
                "type": "string",
                "enum": [
                  "bulk",
                  "single_code"
                ]
              },
              "unique_code_template": {
                "type": "string",
                "title": "Unique code template",
                "description": "On a bulk coupon, the template from which unique coupon codes are generated.\n- You must start the template with your coupon_code wrapped in single quotes.\n- Outside of single quotes, use a 9 for a character that you want to be a random number.\n- Outside of single quotes, use an \"x\" for a character that you want to be a random letter.\n- Outside of single quotes, use an * for a character that you want to be a random number or letter.\n- Use single quotes ' ' for characters that you want to remain static. These strings can be alphanumeric and may contain a - _ or +.\nFor example: \"'abc-'****'-def'\"\n"
              },
              "redemption_resource": {
                "title": "Redemption resource",
                "description": "Whether the discount is for all eligible charges on the account, or only a specific subscription.",
                "default": "account",
                "type": "string",
                "enum": [
                  "account",
                  "subscription"
                ]
              }
            },
            "required": [
              "code",
              "discount_type",
              "name"
            ]
          }
        ]
      },
      "CouponPricing": {
        "type": "object",
        "properties": {
          "currency": {
            "type": "string",
            "description": "3-letter ISO 4217 currency code."
          },
          "discount": {
            "type": "number",
            "format": "float",
            "description": "The fixed discount (in dollars) for the corresponding currency."
          }
        }
      },
      "CouponDiscount": {
        "type": "object",
        "description": "Details of the discount a coupon applies. Will contain a `type`\nproperty and one of the following properties: `percent`, `fixed`, `trial`.\n",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "fixed",
              "free_trial",
              "percent"
            ]
          },
          "percent": {
            "description": "This is only present when `type=percent`.",
            "type": "integer"
          },
          "currencies": {
            "type": "array",
            "description": "This is only present when `type=fixed`.",
            "items": {
              "$ref": "#/components/schemas/CouponDiscountPricing"
            }
          },
          "trial": {
            "type": "object",
            "x-class-name": "CouponDiscountTrial",
            "description": "This is only present when `type=free_trial`.",
            "properties": {
              "unit": {
                "title": "Trial unit",
                "description": "Temporal unit of the free trial",
                "type": "string",
                "enum": [
                  "day",
                  "month",
                  "week"
                ]
              },
              "length": {
                "type": "integer",
                "title": "Trial length",
                "description": "Trial length measured in the units specified by the sibling `unit` property"
              }
            }
          }
        }
      },
      "CouponDiscountPricing": {
        "type": "object",
        "properties": {
          "currency": {
            "type": "string",
            "title": "Currency",
            "description": "3-letter ISO 4217 currency code.",
            "maxLength": 3
          },
          "amount": {
            "type": "number",
            "format": "float",
            "title": "Discount Amount",
            "description": "Value of the fixed discount that this coupon applies."
          }
        }
      },
      "CouponBulkCreate": {
        "type": "object",
        "properties": {
          "number_of_unique_codes": {
            "type": "integer",
            "title": "Number of unique codes",
            "description": "The quantity of unique coupon codes to generate",
            "minimum": 1,
            "maximum": 200
          }
        }
      },
      "CouponMini": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "title": "Coupon ID",
            "readOnly": true
          },
          "object": {
            "type": "string",
            "title": "Object type",
            "readOnly": true
          },
          "code": {
            "type": "string",
            "title": "Coupon code",
            "description": "The code the customer enters to redeem the coupon."
          },
          "name": {
            "type": "string",
            "title": "Name",
            "description": "The internal name for the coupon."
          },
          "state": {
            "title": "State",
            "description": "Indicates if the coupon is redeemable, and if it is not, why.",
            "type": "string",
            "enum": [
              "expired",
              "maxed_out",
              "redeemable"
            ]
          },
          "discount": {
            "$ref": "#/components/schemas/CouponDiscount"
          },
          "coupon_type": {
            "title": "Coupon type (TODO: implement coupon generation)",
            "description": "Whether the coupon is \"single_code\" or \"bulk\". Bulk coupons will require a `unique_code_template` and will generate unique codes through the `/generate` endpoint.",
            "type": "string",
            "enum": [
              "bulk",
              "single_code"
            ]
          },
          "expired_at": {
            "type": "string",
            "title": "Expired at",
            "description": "The date and time the coupon was expired early or reached its `max_redemptions`.",
            "format": "date-time"
          }
        }
      },
      "CouponRedemption": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "title": "Coupon Redemption ID",
            "readOnly": true
          },
          "object": {
            "type": "string",
            "title": "Object type",
            "description": "Will always be `coupon`.",
            "readOnly": true
          },
          "account": {
            "type": "object",
            "title": "Account",
            "description": "The Account on which the coupon was applied.",
            "readOnly": true,
            "$ref": "#/components/schemas/AccountMini"
          },
          "subscription_id": {
            "type": "string",
            "title": "Subscription ID",
            "readOnly": true
          },
          "coupon": {
            "$ref": "#/components/schemas/Coupon"
          },
          "state": {
            "title": "Coupon Redemption state",
            "default": "active",
            "type": "string",
            "enum": [
              "active",
              "inactive"
            ]
          },
          "currency": {
            "type": "string",
            "title": "Currency",
            "description": "3-letter ISO 4217 currency code.",
            "maxLength": 3
          },
          "discounted": {
            "type": "number",
            "format": "float",
            "title": "Amount Discounted",
            "description": "The amount that was discounted upon the application of the coupon, formatted with the currency."
          },
          "created_at": {
            "type": "string",
            "title": "Created at",
            "format": "date-time",
            "readOnly": true
          },
          "updated_at": {
            "type": "string",
            "title": "Last updated at",
            "format": "date-time",
            "readOnly": true
          },
          "removed_at": {
            "type": "string",
            "title": "Removed at",
            "description": "The date and time the redemption was removed from the account (un-redeemed).",
            "format": "date-time"
          }
        }
      },
      "CouponRedemptionCreate": {
        "type": "object",
        "properties": {
          "coupon_id": {
            "type": "string",
            "title": "Coupon ID"
          },
          "currency": {
            "type": "string",
            "title": "Currency",
            "description": "3-letter ISO 4217 currency code.",
            "maxLength": 3
          },
          "subscription_id": {
            "type": "string",
            "title": "Subscription ID"
          }
        },
        "required": [
          "coupon_id"
        ]
      },
      "CouponRedemptionMini": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "title": "Coupon Redemption ID",
            "readOnly": true
          },
          "object": {
            "type": "string",
            "title": "Object type",
            "description": "Will always be `coupon`.",
            "readOnly": true
          },
          "coupon": {
            "$ref": "#/components/schemas/CouponMini"
          },
          "state": {
            "title": "Invoice state",
            "type": "string",
            "enum": [
              "active",
              "inactive"
            ]
          },
          "discounted": {
            "type": "number",
            "format": "float",
            "title": "Amount Discounted",
            "description": "The amount that was discounted upon the application of the coupon, formatted with the currency."
          },
          "created_at": {
            "type": "string",
            "title": "Created at",
            "format": "date-time",
            "readOnly": true
          }
        }
      },
      "CouponUpdate": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "title": "Name",
            "description": "The internal name for the coupon."
          },
          "max_redemptions": {
            "type": "integer",
            "title": "Max redemptions",
            "description": "A maximum number of redemptions for the coupon. The coupon will expire when it hits its maximum redemptions."
          },
          "max_redemptions_per_account": {
            "type": "integer",
            "title": "Max redemptions per account",
            "description": "Redemptions per account is the number of times a specific account can redeem the coupon. Set redemptions per account to `1` if you want to keep customers from gaming the system and getting more than one discount from the coupon campaign."
          },
          "hosted_description": {
            "type": "string",
            "title": "Hosted Payment Pages description",
            "description": "This description will show up when a customer redeems a coupon on your Hosted Payment Pages, or if you choose to show the description on your own checkout page."
          },
          "invoice_description": {
            "type": "string",
            "title": "Invoice description",
            "description": "Description of the coupon on the invoice.",
            "maxLength": 255
          },
          "redeem_by_date": {
            "type": "string",
            "title": "Redeem by",
            "description": "The date and time the coupon will expire and can no longer be redeemed. Time is always 11:59:59, the end-of-day Pacific time."
          }
        }
      },
      "CreditPayment": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "title": "Credit Payment ID",
            "maxLength": 13
          },
          "object": {
            "type": "string",
            "title": "Object type"
          },
          "uuid": {
            "type": "string",
            "title": "Recurly UUID",
            "description": "The UUID is useful for matching data with the CSV exports and building URLs into Recurly's UI.",
            "maxLength": 32
          },
          "action": {
            "title": "Action",
            "description": "The action for which the credit was created.",
            "type": "string",
            "enum": [
              "payment",
              "reduction",
              "refund",
              "write_off"
            ]
          },
          "account": {
            "$ref": "#/components/schemas/AccountMini"
          },
          "applied_to_invoice": {
            "$ref": "#/components/schemas/InvoiceMini"
          },
          "original_invoice": {
            "$ref": "#/components/schemas/InvoiceMini"
          },
          "currency": {
            "type": "string",
            "title": "Currency",
            "description": "3-letter ISO 4217 currency code.",
            "maxLength": 3
          },
          "amount": {
            "type": "number",
            "format": "float",
            "title": "Amount",
            "description": "Total credit payment amount applied to the charge invoice."
          },
          "original_credit_payment_id": {
            "type": "string",
            "title": "Original Credit Payment ID",
            "description": "For credit payments with action `refund`, this is the credit payment that was refunded.",
            "maxLength": 13
          },
          "refund_transaction": {
            "$ref": "#/components/schemas/Transaction"
          },
          "created_at": {
            "type": "string",
            "title": "Created at",
            "format": "date-time",
            "readOnly": true
          },
          "updated_at": {
            "type": "string",
            "title": "Last updated at",
            "format": "date-time",
            "readOnly": true
          },
          "voided_at": {
            "type": "string",
            "title": "Voided at",
            "format": "date-time",
            "readOnly": true
          }
        }
      },
      "CustomField": {
        "type": "object",
        "title": "Custom field",
        "properties": {
          "name": {
            "type": "string",
            "title": "Field name",
            "description": "Fields must be created in the UI before values can be assigned to them.",
            "pattern": "/^[a-z0-9_-]+$/i",
            "maxLength": 50
          },
          "value": {
            "type": "string",
            "title": "Field value",
            "description": "Any values that resemble a credit card number or security code (CVV/CVC) will be rejected.",
            "maxLength": 255
          }
        },
        "required": [
          "name",
          "value"
        ]
      },
      "CustomFields": {
        "type": "array",
        "title": "Custom fields",
        "description": "The custom fields will only be altered when they are included in a request. Sending an empty array will not remove any existing values. To remove a field send the name with a null or empty value.",
        "items": {
          "$ref": "#/components/schemas/CustomField"
        }
      },
      "CustomFieldDefinition": {
        "type": "object",
        "title": "Custom field definition",
        "properties": {
          "id": {
            "type": "string",
            "title": "Custom field definition ID",
            "readOnly": true
          },
          "object": {
            "type": "string",
            "title": "Object type",
            "readOnly": true
          },
          "related_type": {
            "title": "Related Recurly object type",
            "type": "string",
            "enum": [
              "account",
              "item",
              "plan",
              "subscription",
              "charge"
            ]
          },
          "name": {
            "type": "string",
            "title": "Name",
            "description": "Used by the API to identify the field or reading and writing. The name can only be used once per Recurly object type.",
            "pattern": "/^[a-z0-9_-]+$/i",
            "maxLength": 50
          },
          "user_access": {
            "title": "User access",
            "description": "The access control applied inside Recurly's admin UI:\n- `api_only` - No one will be able to view or edit this field's data via the admin UI.\n- `read_only` - Users with the Customers role will be able to view this field's data via the admin UI, but\n  editing will only be available via the API.\n- `write` - Users with the Customers role will be able to view and edit this field's data via the admin UI.\n- `set_only` - Users with the Customers role will be able to set this field's data via the admin console.\n",
            "type": "string",
            "enum": [
              "api_only",
              "read_only",
              "write",
              "set_only"
            ]
          },
          "display_name": {
            "type": "string",
            "title": "Display name",
            "description": "Used to label the field when viewing and editing the field in Recurly's admin UI.",
            "maxLength": 50
          },
          "tooltip": {
            "type": "string",
            "title": "Tooltip description",
            "description": "Displayed as a tooltip when editing the field in the Recurly admin UI.",
            "pattern": "/^[a-z0-9_-]+$/i",
            "maxLength": 255
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "title": "Created at",
            "readOnly": true
          },
          "updated_at": {
            "type": "string",
            "format": "date-time",
            "title": "Last updated at",
            "readOnly": true
          },
          "deleted_at": {
            "type": "string",
            "format": "date-time",
            "title": "Deleted at",
            "description": "Definitions are initially soft deleted, and once all the values are removed from the accouts or subscriptions, will be hard deleted an no longer visible.",
            "readOnly": true
          }
        }
      },
      "GeneralLedgerAccountId": {
        "type": "string",
        "title": "General Ledger Account ID",
        "description": "The ID of a general ledger account. General ledger accounts are\nonly accessible as a part of the Recurly RevRec Standard and\nRecurly RevRec Advanced features.\n",
        "maxLength": 13
      },
      "GeneralLedgerAccountCode": {
        "type": "string",
        "title": "Accounting code for the ledger account.",
        "description": "Unique code to identify the ledger account. Each code must start\nwith a letter or number. The following special characters are\nallowed: `-_.,:`\n",
        "pattern": "/^[A-Za-z0-9](( *)?[\\-A-Za-z0-9_.,:])*$/",
        "maxLength": 255
      },
      "GeneralLedgerAccountDescription": {
        "type": "string",
        "title": "Description",
        "description": "Optional description.",
        "maxLength": 255
      },
      "GeneralLedgerAccount": {
        "type": "object",
        "description": "Full general ledger account details.",
        "properties": {
          "id": {
            "type": "string",
            "title": "General Ledger Account ID",
            "description": "The ID of a general ledger account. General ledger accounts are\nonly accessible as a part of the Recurly RevRec Standard and\nRecurly RevRec Advanced features.\n",
            "maxLength": 13
          },
          "object": {
            "type": "string",
            "title": "Object type",
            "default": "general_ledger_account",
            "readOnly": true
          },
          "code": {
            "type": "string",
            "title": "Accounting code for the ledger account.",
            "description": "Unique code to identify the ledger account. Each code must start\nwith a letter or number. The following special characters are\nallowed: `-_.,:`\n",
            "pattern": "/^[A-Za-z0-9](( *)?[\\-A-Za-z0-9_.,:])*$/",
            "maxLength": 255
          },
          "description": {
            "type": "string",
            "title": "Description",
            "description": "Optional description.",
            "maxLength": 255
          },
          "account_type": {
            "type": "string",
            "enum": [
              "liability",
              "revenue"
            ]
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "title": "Created at",
            "readOnly": true
          },
          "updated_at": {
            "type": "string",
            "format": "date-time",
            "title": "Last updated at",
            "readOnly": true
          }
        }
      },
      "GeneralLedgerAccountList": {
        "type": "object",
        "properties": {
          "object": {
            "type": "string",
            "title": "Object type",
            "description": "Will always be List."
          },
          "has_more": {
            "type": "boolean",
            "description": "Indicates there are more results on subsequent pages."
          },
          "next": {
            "type": "string",
            "description": "Path to subsequent page of results."
          },
          "data": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/GeneralLedgerAccount"
            }
          }
        }
      },
      "GeneralLedgerAccountCreate": {
        "type": "object",
        "description": "Create a new liability or revenue general ledger account.",
        "properties": {
          "code": {
            "type": "string",
            "title": "Accounting code for the ledger account.",
            "description": "Unique code to identify the ledger account. Each code must start\nwith a letter or number. The following special characters are\nallowed: `-_.,:`\n",
            "pattern": "/^[A-Za-z0-9](( *)?[\\-A-Za-z0-9_.,:])*$/",
            "maxLength": 255
          },
          "description": {
            "type": "string",
            "title": "Description",
            "description": "Optional description.",
            "maxLength": 255
          },
          "account_type": {
            "type": "string",
            "enum": [
              "liability",
              "revenue"
            ]
          }
        }
      },
      "GeneralLedgerAccountUpdate": {
        "type": "object",
        "description": "Update an existing general ledger account.",
        "properties": {
          "code": {
            "type": "string",
            "title": "Accounting code for the ledger account.",
            "description": "Unique code to identify the ledger account. Each code must start\nwith a letter or number. The following special characters are\nallowed: `-_.,:`\n",
            "pattern": "/^[A-Za-z0-9](( *)?[\\-A-Za-z0-9_.,:])*$/",
            "maxLength": 255
          },
          "description": {
            "type": "string",
            "title": "Description",
            "description": "Optional description.",
            "maxLength": 255
          }
        }
      },
      "PerformanceObligationId": {
        "type": "string",
        "title": "Performance Obligation ID",
        "description": "The ID of a performance obligation. Performance obligations are\nonly accessible as a part of the Recurly RevRec Standard and\nRecurly RevRec Advanced features.\n",
        "maxLength": 13
      },
      "PerformanceObligation": {
        "type": "object",
        "description": "Performance obligation details",
        "properties": {
          "id": {
            "type": "string",
            "title": "Performance Obligation ID",
            "description": "The ID of a performance obligation. Performance obligations are\nonly accessible as a part of the Recurly RevRec Standard and\nRecurly RevRec Advanced features.\n",
            "maxLength": 13
          },
          "name": {
            "title": "Performance Obligation Name",
            "type": "string"
          },
          "created_at": {
            "title": "Created At",
            "type": "string",
            "readOnly": true,
            "format": "date-time"
          },
          "updated_at": {
            "title": "Last updated at",
            "type": "string",
            "readOnly": true,
            "format": "date-time"
          }
        }
      },
      "PerformanceObligationList": {
        "type": "object",
        "description": "List of Performance Obligations",
        "properties": {
          "object": {
            "title": "Object type",
            "type": "string"
          },
          "data": {
            "title": "Performance Obligation",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/PerformanceObligation"
            }
          }
        }
      },
      "ItemMini": {
        "type": "object",
        "title": "Item mini details",
        "description": "Just the important parts.",
        "properties": {
          "id": {
            "type": "string",
            "title": "Item ID",
            "maxLength": 13,
            "readOnly": true
          },
          "object": {
            "type": "string",
            "title": "Object type",
            "readOnly": true
          },
          "code": {
            "type": "string",
            "title": "Item code",
            "description": "Unique code to identify the item.",
            "pattern": "/^[a-z0-9_+-]+$/",
            "maxLength": 50
          },
          "state": {
            "title": "State",
            "description": "The current state of the item.",
            "readOnly": true,
            "type": "string",
            "enum": [
              "active",
              "inactive"
            ]
          },
          "name": {
            "type": "string",
            "title": "Name",
            "description": "This name describes your item and will appear on the invoice when it's purchased on a one time basis.",
            "maxLength": 255
          },
          "description": {
            "type": "string",
            "title": "Description",
            "description": "Optional, description."
          }
        }
      },
      "Item": {
        "type": "object",
        "description": "Full item details.",
        "properties": {
          "id": {
            "type": "string",
            "title": "Item ID",
            "maxLength": 13,
            "readOnly": true
          },
          "object": {
            "type": "string",
            "title": "Object type",
            "readOnly": true
          },
          "code": {
            "type": "string",
            "title": "Item code",
            "description": "Unique code to identify the item.",
            "pattern": "/^[a-z0-9_+-]+$/",
            "maxLength": 50
          },
          "state": {
            "title": "State",
            "description": "The current state of the item.",
            "readOnly": true,
            "type": "string",
            "enum": [
              "active",
              "inactive"
            ]
          },
          "name": {
            "type": "string",
            "title": "Name",
            "description": "This name describes your item and will appear on the invoice when it's purchased on a one time basis.",
            "maxLength": 255
          },
          "description": {
            "type": "string",
            "title": "Description",
            "description": "Optional, description."
          },
          "external_sku": {
            "type": "string",
            "title": "External SKU",
            "description": "Optional, stock keeping unit to link the item to other inventory systems.",
            "maxLength": 50
          },
          "accounting_code": {
            "type": "string",
            "title": "Item accounting code",
            "description": "Accounting code for invoice line items.",
            "pattern": "/^[a-z0-9_+-]+$/",
            "maxLength": 20
          },
          "revenue_schedule_type": {
            "title": "Revenue schedule type",
            "type": "string",
            "enum": [
              "at_range_end",
              "at_range_start",
              "evenly",
              "never"
            ]
          },
          "performance_obligation_id": {
            "type": "string",
            "title": "Performance Obligation ID",
            "description": "The ID of a performance obligation. Performance obligations are\nonly accessible as a part of the Recurly RevRec Standard and\nRecurly RevRec Advanced features.\n",
            "maxLength": 13
          },
          "liability_gl_account_id": {
            "type": "string",
            "title": "General Ledger Account ID",
            "description": "The ID of a general ledger account. General ledger accounts are\nonly accessible as a part of the Recurly RevRec Standard and\nRecurly RevRec Advanced features.\n",
            "maxLength": 13
          },
          "revenue_gl_account_id": {
            "type": "string",
            "title": "General Ledger Account ID",
            "description": "The ID of a general ledger account. General ledger accounts are\nonly accessible as a part of the Recurly RevRec Standard and\nRecurly RevRec Advanced features.\n",
            "maxLength": 13
          },
          "avalara_transaction_type": {
            "type": "integer",
            "title": "Avalara Transaction Type",
            "description": "Used by Avalara for Communications taxes. The transaction type in combination with the service type describe how the item is taxed. Refer to [the documentation](https://help.avalara.com/AvaTax_for_Communications/Tax_Calculation/AvaTax_for_Communications_Tax_Engine/Mapping_Resources/TM_00115_AFC_Modules_Corresponding_Transaction_Types) for more available t/s types.",
            "minimum": 0
          },
          "avalara_service_type": {
            "type": "integer",
            "title": "Avalara Service Type",
            "description": "Used by Avalara for Communications taxes. The transaction type in combination with the service type describe how the item is taxed. Refer to [the documentation](https://help.avalara.com/AvaTax_for_Communications/Tax_Calculation/AvaTax_for_Communications_Tax_Engine/Mapping_Resources/TM_00115_AFC_Modules_Corresponding_Transaction_Types) for more available t/s types.",
            "minimum": 0
          },
          "tax_code": {
            "type": "string",
            "maxLength": 50,
            "title": "Tax code",
            "description": "Optional field used by Avalara, Vertex, and Recurly's In-the-Box tax solution to determine taxation rules. You can pass in specific tax codes using any of these tax integrations. For Recurly's In-the-Box tax offering you can also choose to instead use simple values of `unknown`, `physical`, or `digital` tax codes."
          },
          "tax_exempt": {
            "type": "boolean",
            "title": "Tax exempt?",
            "description": "`true` exempts tax on the item, `false` applies tax on the item."
          },
          "custom_fields": {
            "$ref": "#/components/schemas/CustomFields"
          },
          "currencies": {
            "type": "array",
            "title": "Item Pricing",
            "items": {
              "$ref": "#/components/schemas/Pricing"
            }
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "title": "Created at",
            "readOnly": true
          },
          "updated_at": {
            "type": "string",
            "format": "date-time",
            "title": "Last updated at",
            "readOnly": true
          },
          "deleted_at": {
            "type": "string",
            "format": "date-time",
            "title": "Deleted at",
            "readOnly": true
          }
        }
      },
      "ItemCreate": {
        "type": "object",
        "properties": {
          "code": {
            "type": "string",
            "title": "Item code",
            "description": "Unique code to identify the item.",
            "pattern": "/^[a-z0-9_+-]+$/",
            "maxLength": 50
          },
          "name": {
            "type": "string",
            "title": "Name",
            "description": "This name describes your item and will appear on the invoice when it's purchased on a one time basis.",
            "maxLength": 255
          },
          "description": {
            "type": "string",
            "title": "Description",
            "description": "Optional, description."
          },
          "external_sku": {
            "type": "string",
            "title": "External SKU",
            "description": "Optional, stock keeping unit to link the item to other inventory systems.",
            "maxLength": 50
          },
          "accounting_code": {
            "type": "string",
            "title": "Item accounting code",
            "description": "Accounting code for invoice line items.",
            "pattern": "/^[a-z0-9_+-]+$/",
            "maxLength": 20
          },
          "revenue_schedule_type": {
            "title": "Revenue schedule type",
            "type": "string",
            "enum": [
              "at_range_end",
              "at_range_start",
              "evenly",
              "never"
            ]
          },
          "performance_obligation_id": {
            "type": "string",
            "title": "Performance Obligation ID",
            "description": "The ID of a performance obligation. Performance obligations are\nonly accessible as a part of the Recurly RevRec Standard and\nRecurly RevRec Advanced features.\n",
            "maxLength": 13
          },
          "liability_gl_account_id": {
            "type": "string",
            "title": "General Ledger Account ID",
            "description": "The ID of a general ledger account. General ledger accounts are\nonly accessible as a part of the Recurly RevRec Standard and\nRecurly RevRec Advanced features.\n",
            "maxLength": 13
          },
          "revenue_gl_account_id": {
            "type": "string",
            "title": "General Ledger Account ID",
            "description": "The ID of a general ledger account. General ledger accounts are\nonly accessible as a part of the Recurly RevRec Standard and\nRecurly RevRec Advanced features.\n",
            "maxLength": 13
          },
          "avalara_transaction_type": {
            "type": "integer",
            "title": "Avalara Transaction Type",
            "description": "Used by Avalara for Communications taxes. The transaction type in combination with the service type describe how the item is taxed. Refer to [the documentation](https://help.avalara.com/AvaTax_for_Communications/Tax_Calculation/AvaTax_for_Communications_Tax_Engine/Mapping_Resources/TM_00115_AFC_Modules_Corresponding_Transaction_Types) for more available t/s types.",
            "minimum": 0
          },
          "avalara_service_type": {
            "type": "integer",
            "title": "Avalara Service Type",
            "description": "Used by Avalara for Communications taxes. The transaction type in combination with the service type describe how the item is taxed. Refer to [the documentation](https://help.avalara.com/AvaTax_for_Communications/Tax_Calculation/AvaTax_for_Communications_Tax_Engine/Mapping_Resources/TM_00115_AFC_Modules_Corresponding_Transaction_Types) for more available t/s types.",
            "minimum": 0
          },
          "tax_code": {
            "type": "string",
            "maxLength": 50,
            "title": "Tax code",
            "description": "Optional field used by Avalara, Vertex, and Recurly's In-the-Box tax solution to determine taxation rules. You can pass in specific tax codes using any of these tax integrations. For Recurly's In-the-Box tax offering you can also choose to instead use simple values of `unknown`, `physical`, or `digital` tax codes."
          },
          "tax_exempt": {
            "type": "boolean",
            "title": "Tax exempt?",
            "description": "`true` exempts tax on the item, `false` applies tax on the item."
          },
          "custom_fields": {
            "$ref": "#/components/schemas/CustomFields"
          },
          "currencies": {
            "type": "array",
            "title": "Item Pricing",
            "items": {
              "$ref": "#/components/schemas/Pricing"
            }
          }
        },
        "required": [
          "code",
          "name"
        ]
      },
      "ItemUpdate": {
        "type": "object",
        "properties": {
          "code": {
            "type": "string",
            "title": "Item code",
            "description": "Unique code to identify the item.",
            "pattern": "/^[a-z0-9_+-]+$/",
            "maxLength": 50
          },
          "name": {
            "type": "string",
            "title": "Name",
            "description": "This name describes your item and will appear on the invoice when it's purchased on a one time basis.",
            "maxLength": 255
          },
          "description": {
            "type": "string",
            "title": "Description",
            "description": "Optional, description."
          },
          "external_sku": {
            "type": "string",
            "title": "External SKU",
            "description": "Optional, stock keeping unit to link the item to other inventory systems.",
            "maxLength": 50
          },
          "accounting_code": {
            "type": "string",
            "title": "Item accounting code",
            "description": "Accounting code for invoice line items.",
            "pattern": "/^[a-z0-9_+-]+$/",
            "maxLength": 20
          },
          "revenue_schedule_type": {
            "title": "Revenue schedule type",
            "type": "string",
            "enum": [
              "at_range_end",
              "at_range_start",
              "evenly",
              "never"
            ]
          },
          "performance_obligation_id": {
            "type": "string",
            "title": "Performance Obligation ID",
            "description": "The ID of a performance obligation. Performance obligations are\nonly accessible as a part of the Recurly RevRec Standard and\nRecurly RevRec Advanced features.\n",
            "maxLength": 13
          },
          "liability_gl_account_id": {
            "type": "string",
            "title": "General Ledger Account ID",
            "description": "The ID of a general ledger account. General ledger accounts are\nonly accessible as a part of the Recurly RevRec Standard and\nRecurly RevRec Advanced features.\n",
            "maxLength": 13
          },
          "revenue_gl_account_id": {
            "type": "string",
            "title": "General Ledger Account ID",
            "description": "The ID of a general ledger account. General ledger accounts are\nonly accessible as a part of the Recurly RevRec Standard and\nRecurly RevRec Advanced features.\n",
            "maxLength": 13
          },
          "avalara_transaction_type": {
            "type": "integer",
            "title": "Avalara Transaction Type",
            "description": "Used by Avalara for Communications taxes. The transaction type in combination with the service type describe how the item is taxed. Refer to [the documentation](https://help.avalara.com/AvaTax_for_Communications/Tax_Calculation/AvaTax_for_Communications_Tax_Engine/Mapping_Resources/TM_00115_AFC_Modules_Corresponding_Transaction_Types) for more available t/s types.",
            "minimum": 0
          },
          "avalara_service_type": {
            "type": "integer",
            "title": "Avalara Service Type",
            "description": "Used by Avalara for Communications taxes. The transaction type in combination with the service type describe how the item is taxed. Refer to [the documentation](https://help.avalara.com/AvaTax_for_Communications/Tax_Calculation/AvaTax_for_Communications_Tax_Engine/Mapping_Resources/TM_00115_AFC_Modules_Corresponding_Transaction_Types) for more available t/s types.",
            "minimum": 0
          },
          "tax_code": {
            "type": "string",
            "maxLength": 50,
            "title": "Tax code",
            "description": "Optional field used by Avalara, Vertex, and Recurly's In-the-Box tax solution to determine taxation rules. You can pass in specific tax codes using any of these tax integrations. For Recurly's In-the-Box tax offering you can also choose to instead use simple values of `unknown`, `physical`, or `digital` tax codes."
          },
          "tax_exempt": {
            "type": "boolean",
            "title": "Tax exempt?",
            "description": "`true` exempts tax on the item, `false` applies tax on the item."
          },
          "custom_fields": {
            "$ref": "#/components/schemas/CustomFields"
          },
          "currencies": {
            "type": "array",
            "title": "Item Pricing",
            "items": {
              "$ref": "#/components/schemas/Pricing"
            }
          }
        }
      },
      "Invoice": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "title": "Invoice ID",
            "readOnly": true
          },
          "uuid": {
            "type": "string",
            "title": "Invoice UUID",
            "readOnly": true
          },
          "object": {
            "type": "string",
            "title": "Object type",
            "readOnly": true
          },
          "type": {
            "title": "Invoice type",
            "description": "Invoices are either charge, credit, or legacy invoices.",
            "type": "string",
            "enum": [
              "charge",
              "credit",
              "legacy"
            ]
          },
          "origin": {
            "title": "Origin",
            "description": "The event that created the invoice.",
            "type": "string",
            "enum": [
              "carryforward_credit",
              "carryforward_gift_credit",
              "credit",
              "external_refund",
              "gift_card",
              "immediate_change",
              "import",
              "line_item_refund",
              "open_amount_refund",
              "prepayment",
              "purchase",
              "refund",
              "renewal",
              "termination",
              "usage_correction",
              "write_off"
            ]
          },
          "state": {
            "title": "Invoice state",
            "type": "string",
            "default": "all",
            "enum": [
              "open",
              "pending",
              "processing",
              "past_due",
              "paid",
              "closed",
              "failed",
              "voided"
            ]
          },
          "account": {
            "$ref": "#/components/schemas/AccountMini"
          },
          "billing_info_id": {
            "type": "string",
            "title": "Billing info ID",
            "description": "The `billing_info_id` is the value that represents a specific billing info for an end customer. When `billing_info_id` is used to assign billing info to the subscription, all future billing events for the subscription will bill to the specified billing info. `billing_info_id` can ONLY be used for sites utilizing the Wallet feature."
          },
          "subscription_ids": {
            "type": "array",
            "title": "Subscription IDs",
            "description": "If the invoice is charging or refunding for one or more subscriptions, these are their IDs.",
            "items": {
              "type": "string",
              "title": "Subscription ID",
              "maxLength": 13
            }
          },
          "previous_invoice_id": {
            "type": "string",
            "title": "Previous invoice ID",
            "description": "On refund invoices, this value will exist and show the invoice ID of the purchase invoice the refund was created from. This field is only populated for sites without the [Only Bill What Changed](https://docs.recurly.com/docs/only-bill-what-changed) feature enabled. Sites with Only Bill What Changed enabled should use the [related_invoices endpoint](https://recurly.com/developers/api/v2021-02-25/index.html#operation/list_related_invoices) to see purchase invoices refunded by this invoice.",
            "maxLength": 13
          },
          "number": {
            "type": "string",
            "title": "Invoice number",
            "description": "If VAT taxation and the Country Invoice Sequencing feature are enabled, invoices will have country-specific invoice numbers for invoices billed to EU countries (ex: FR1001). Non-EU invoices will continue to use the site-level invoice number sequence."
          },
          "collection_method": {
            "title": "Collection method",
            "description": "An automatic invoice means a corresponding transaction is run using the account's billing information at the same time the invoice is created. Manual invoices are created without a corresponding transaction. The merchant must enter a manual payment transaction or have the customer pay the invoice with an automatic method, like credit card, PayPal, Amazon, or ACH bank payment.",
            "default": "automatic",
            "type": "string",
            "enum": [
              "automatic",
              "manual"
            ]
          },
          "po_number": {
            "type": "string",
            "title": "Purchase order number",
            "description": "For manual invoicing, this identifies the PO number associated with the subscription.",
            "maxLength": 50
          },
          "net_terms": {
            "type": "integer",
            "title": "Net terms",
            "description": "Integer paired with `Net Terms Type` and representing the number\nof days past the current date (for `net` Net Terms Type) or days after\nthe last day of the current month (for `eom` Net Terms Type) that the\ninvoice will become past due. For `manual` collection method, an additional 24 hours is\nadded to ensure the customer has the entire last day to make payment before\nbecoming past due. For example:\n\nIf an invoice is due `net 0`, it is due 'On Receipt' and will become past due 24 hours after it's created.\nIf an invoice is due `net 30`, it will become past due at 31 days exactly.\nIf an invoice is due `eom 30`, it will become past due 31 days from the last day of the current month.\n\nFor `automatic` collection method, the additional 24 hours is not added. For example, On-Receipt is due immediately, and `net 30` will become due exactly 30 days from invoice generation, at which point Recurly will attempt collection.\nWhen `eom` Net Terms Type is passed, the value for `Net Terms` is restricted to `0, 15, 30, 45, 60, or 90`.\n\nFor more information on how net terms work with `manual` collection visit our docs page (https://docs.recurly.com/docs/manual-payments#section-collection-terms)\nor visit (https://docs.recurly.com/docs/automatic-invoicing-terms#section-collection-terms) for information about net terms using `automatic` collection.",
            "minimum": 0,
            "default": 0
          },
          "net_terms_type": {
            "type": "string",
            "title": "Net Terms Type",
            "description": "Optionally supplied string that may be either `net` or `eom` (end-of-month).\nWhen `net`, an invoice becomes past due the specified number of `Net Terms` days from the current date.\nWhen `eom` an invoice becomes past due the specified number of `Net Terms` days from the last day of the current month.\n",
            "enum": [
              "net",
              "eom"
            ],
            "default": "net"
          },
          "address": {
            "$ref": "#/components/schemas/InvoiceAddress"
          },
          "shipping_address": {
            "$ref": "#/components/schemas/ShippingAddress"
          },
          "currency": {
            "type": "string",
            "title": "Currency",
            "description": "3-letter ISO 4217 currency code.",
            "maxLength": 3
          },
          "discount": {
            "type": "number",
            "format": "float",
            "title": "Discount",
            "description": "Total discounts applied to this invoice."
          },
          "subtotal": {
            "type": "number",
            "format": "float",
            "title": "Subtotal",
            "description": "The summation of charges and credits, before discounts and taxes."
          },
          "tax": {
            "type": "number",
            "format": "float",
            "title": "Tax",
            "description": "The total tax on this invoice."
          },
          "total": {
            "type": "number",
            "format": "float",
            "title": "Total",
            "description": "The final total on this invoice. The summation of invoice charges, discounts, credits, and tax."
          },
          "refundable_amount": {
            "type": "number",
            "format": "float",
            "title": "Refundable amount",
            "description": "The refundable amount on a charge invoice. It will be null for all other invoices."
          },
          "paid": {
            "type": "number",
            "format": "float",
            "title": "Paid",
            "description": "The total amount of successful payments transaction on this invoice."
          },
          "balance": {
            "type": "number",
            "format": "float",
            "title": "Balance",
            "description": "The outstanding balance remaining on this invoice."
          },
          "tax_info": {
            "$ref": "#/components/schemas/TaxInfo"
          },
          "used_tax_service": {
            "type": "boolean",
            "title": "Used Tax Service?",
            "description": "Will be `true` when the invoice had a successful response from the tax service and `false` when the invoice was not sent to tax service due to a lack of address or enabled jurisdiction or was processed without tax due to a non-blocking error returned from the tax service."
          },
          "vat_number": {
            "type": "string",
            "title": "VAT number",
            "description": "VAT registration number for the customer on this invoice. This will come from the VAT Number field in the Billing Info or the Account Info depending on your tax settings and the invoice collection method.",
            "maxLength": 20
          },
          "vat_reverse_charge_notes": {
            "type": "string",
            "title": "VAT reverse charge notes",
            "description": "VAT Reverse Charge Notes only appear if you have EU VAT enabled or are using your own Avalara AvaTax account and the customer is in the EU, has a VAT number, and is in a different country than your own. This will default to the VAT Reverse Charge Notes text specified on the Tax Settings page in your Recurly admin, unless custom notes were created with the original subscription."
          },
          "terms_and_conditions": {
            "type": "string",
            "title": "Terms and conditions",
            "description": "This will default to the Terms and Conditions text specified on the Invoice Settings page in your Recurly admin. Specify custom notes to add or override Terms and Conditions."
          },
          "customer_notes": {
            "type": "string",
            "title": "Customer notes",
            "description": "This will default to the Customer Notes text specified on the Invoice Settings. Specify custom notes to add or override Customer Notes."
          },
          "line_items": {
            "type": "array",
            "title": "Line Items",
            "items": {
              "$ref": "#/components/schemas/LineItem"
            }
          },
          "has_more_line_items": {
            "type": "boolean",
            "title": "Has more Line Items",
            "description": "Identifies if the invoice has more line items than are returned in `line_items`. If `has_more_line_items` is `true`, then a request needs to be made to the `list_invoice_line_items` endpoint."
          },
          "transactions": {
            "type": "array",
            "title": "Transactions",
            "items": {
              "$ref": "#/components/schemas/Transaction"
            }
          },
          "credit_payments": {
            "type": "array",
            "title": "Credit payments",
            "items": {
              "$ref": "#/components/schemas/CreditPayment"
            }
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "title": "Created at",
            "readOnly": true
          },
          "updated_at": {
            "type": "string",
            "format": "date-time",
            "title": "Last updated at",
            "readOnly": true
          },
          "due_at": {
            "type": "string",
            "format": "date-time",
            "title": "Due at",
            "description": "Date invoice is due. This is the date the net terms are reached."
          },
          "closed_at": {
            "type": "string",
            "format": "date-time",
            "title": "Closed at",
            "description": "Date invoice was marked paid or failed."
          },
          "dunning_campaign_id": {
            "type": "string",
            "title": "Dunning Campaign ID",
            "description": "Unique ID to identify the dunning campaign used when dunning the invoice. For sites without multiple dunning campaigns enabled, this will always be the default dunning campaign."
          },
          "dunning_events_sent": {
            "type": "integer",
            "title": "Dunning Event Sent",
            "description": "Number of times the event was sent."
          },
          "final_dunning_event": {
            "type": "boolean",
            "title": "Final Dunning Event",
            "description": "Last communication attempt."
          },
          "business_entity_id": {
            "type": "string",
            "title": "Business Entity ID",
            "description": "Unique ID to identify the business entity assigned to the invoice. Available when the `Multiple Business Entities` feature is enabled."
          }
        }
      },
      "InvoiceCreate": {
        "type": "object",
        "properties": {
          "currency": {
            "type": "string",
            "title": "Currency",
            "description": "3-letter ISO 4217 currency code.",
            "maxLength": 3
          },
          "collection_method": {
            "title": "Collection method",
            "description": "An automatic invoice means a corresponding transaction is run using the account's billing information at the same time the invoice is created. Manual invoices are created without a corresponding transaction. The merchant must enter a manual payment transaction or have the customer pay the invoice with an automatic method, like credit card, PayPal, Amazon, or ACH bank payment.",
            "default": "automatic",
            "type": "string",
            "enum": [
              "automatic",
              "manual"
            ]
          },
          "charge_customer_notes": {
            "type": "string",
            "title": "Charge customer notes",
            "description": "This will default to the Customer Notes text specified on the Invoice Settings for charge invoices. Specify custom notes to add or override Customer Notes on charge invoices."
          },
          "credit_customer_notes": {
            "type": "string",
            "title": "Credit customer notes",
            "description": "This will default to the Customer Notes text specified on the Invoice Settings for credit invoices. Specify customer notes to add or override Customer Notes on credit invoices."
          },
          "net_terms": {
            "type": "integer",
            "title": "Net terms",
            "description": "Integer paired with `Net Terms Type` and representing the number\nof days past the current date (for `net` Net Terms Type) or days after\nthe last day of the current month (for `eom` Net Terms Type) that the\ninvoice will become past due. For `manual` collection method, an additional 24 hours is\nadded to ensure the customer has the entire last day to make payment before\nbecoming past due. For example:\n\nIf an invoice is due `net 0`, it is due 'On Receipt' and will become past due 24 hours after it's created.\nIf an invoice is due `net 30`, it will become past due at 31 days exactly.\nIf an invoice is due `eom 30`, it will become past due 31 days from the last day of the current month.\n\nFor `automatic` collection method, the additional 24 hours is not added. For example, On-Receipt is due immediately, and `net 30` will become due exactly 30 days from invoice generation, at which point Recurly will attempt collection.\nWhen `eom` Net Terms Type is passed, the value for `Net Terms` is restricted to `0, 15, 30, 45, 60, or 90`.\n\nFor more information on how net terms work with `manual` collection visit our docs page (https://docs.recurly.com/docs/manual-payments#section-collection-terms)\nor visit (https://docs.recurly.com/docs/automatic-invoicing-terms#section-collection-terms) for information about net terms using `automatic` collection.",
            "minimum": 0,
            "default": 0
          },
          "net_terms_type": {
            "type": "string",
            "title": "Net Terms Type",
            "description": "Optionally supplied string that may be either `net` or `eom` (end-of-month).\nWhen `net`, an invoice becomes past due the specified number of `Net Terms` days from the current date.\nWhen `eom` an invoice becomes past due the specified number of `Net Terms` days from the last day of the current month.\n",
            "enum": [
              "net",
              "eom"
            ],
            "default": "net"
          },
          "po_number": {
            "type": "string",
            "title": "Purchase order number",
            "description": "For manual invoicing, this identifies the PO number associated with the subscription.",
            "maxLength": 50
          },
          "terms_and_conditions": {
            "type": "string",
            "title": "Terms and conditions",
            "description": "This will default to the Terms and Conditions text specified on the Invoice Settings page in your Recurly admin. Specify custom notes to add or override Terms and Conditions."
          },
          "vat_reverse_charge_notes": {
            "type": "string",
            "title": "VAT reverse charge notes",
            "description": "VAT Reverse Charge Notes only appear if you have EU VAT enabled or are using your own Avalara AvaTax account and the customer is in the EU, has a VAT number, and is in a different country than your own. This will default to the VAT Reverse Charge Notes text specified on the Tax Settings page in your Recurly admin, unless custom notes were created with the original subscription."
          }
        },
        "required": [
          "currency"
        ]
      },
      "InvoiceCollect": {
        "type": "object",
        "properties": {
          "three_d_secure_action_result_token_id": {
            "type": "string",
            "title": "3-D Secure action result token ID",
            "description": "A token generated by Recurly.js after completing a 3-D Secure device fingerprinting or authentication challenge.",
            "maxLength": 22
          },
          "transaction_type": {
            "description": "An optional type designation for the payment gateway transaction created by this request. Supports 'moto' value, which is the acronym for mail order and telephone transactions.",
            "type": "string",
            "enum": [
              "moto"
            ]
          },
          "billing_info_id": {
            "type": "string",
            "title": "Billing Info ID",
            "description": "The `billing_info_id` is the value that represents a specific billing info for an end customer. When `billing_info_id` is used to assign billing info to the subscription, all future billing events for the subscription will bill to the specified billing info. `billing_info_id` can ONLY be used for sites utilizing the Wallet feature."
          }
        }
      },
      "InvoiceCollection": {
        "type": "object",
        "title": "Invoice collection",
        "properties": {
          "object": {
            "type": "string",
            "title": "Object type"
          },
          "charge_invoice": {
            "$ref": "#/components/schemas/Invoice"
          },
          "credit_invoices": {
            "type": "array",
            "title": "Credit invoices",
            "items": {
              "$ref": "#/components/schemas/Invoice"
            }
          }
        }
      },
      "InvoiceUpdate": {
        "type": "object",
        "properties": {
          "po_number": {
            "type": "string",
            "title": "Purchase order number",
            "description": "This identifies the PO number associated with the invoice. Not editable for credit invoices.",
            "maxLength": 50
          },
          "vat_reverse_charge_notes": {
            "type": "string",
            "title": "VAT reverse charge notes",
            "description": "VAT Reverse Charge Notes are editable only if there was a VAT reverse charge applied to the invoice."
          },
          "terms_and_conditions": {
            "type": "string",
            "title": "Terms and conditions",
            "description": "Terms and conditions are an optional note field. Not editable for credit invoices."
          },
          "customer_notes": {
            "type": "string",
            "title": "Customer notes",
            "description": "Customer notes are an optional note field."
          },
          "net_terms": {
            "type": "integer",
            "title": "Net terms",
            "description": "Integer representing the number of days after an invoice's creation that the invoice will become past due. Changing Net terms changes due_on, and the invoice could move between past due and pending.",
            "minimum": 0,
            "maximum": 999
          },
          "address": {
            "$ref": "#/components/schemas/InvoiceAddress"
          },
          "gateway_code": {
            "type": "string",
            "description": "An alphanumeric code shown per gateway on your site's payment gateways page. Set this code to ensure that a given invoice targets a given gateway."
          }
        }
      },
      "InvoiceMini": {
        "type": "object",
        "title": "Invoice mini details",
        "properties": {
          "id": {
            "type": "string",
            "title": "Invoice ID",
            "maxLength": 13
          },
          "object": {
            "type": "string",
            "title": "Object type"
          },
          "number": {
            "type": "string",
            "title": "Invoice number"
          },
          "business_entity_id": {
            "type": "string",
            "title": "Business Entity ID",
            "description": "Unique ID to identify the business entity assigned to the invoice. Available when the `Multiple Business Entities` feature is enabled."
          },
          "type": {
            "title": "Invoice type",
            "type": "string",
            "enum": [
              "charge",
              "credit",
              "legacy"
            ]
          },
          "state": {
            "title": "Invoice state",
            "type": "string",
            "default": "all",
            "enum": [
              "open",
              "pending",
              "processing",
              "past_due",
              "paid",
              "closed",
              "failed",
              "voided"
            ]
          }
        }
      },
      "InvoiceRefund": {
        "type": "object",
        "title": "Invoice refund",
        "properties": {
          "type": {
            "title": "Type",
            "description": "The type of refund. Amount and line items cannot both be specified in the request.",
            "type": "string",
            "enum": [
              "amount",
              "percentage",
              "line_items"
            ]
          },
          "amount": {
            "type": "number",
            "format": "float",
            "title": "Amount",
            "description": "The amount to be refunded. The amount will be split between the line items.\nIf `type` is \"amount\" and no amount is specified, it will default to refunding the total refundable amount on the invoice. Can only be present if `type` is \"amount\".\n"
          },
          "percentage": {
            "type": "integer",
            "title": "Percentage",
            "description": "The percentage of the remaining balance to be refunded. The percentage will be split between the line items. If `type` is \"percentage\" and no percentage is specified, it will default to refunding 100% of the refundable amount on the invoice. Can only be present if `type` is \"percentage\".",
            "minimum": 1,
            "maximum": 100
          },
          "line_items": {
            "type": "array",
            "title": "Line items",
            "description": "The line items to be refunded. This is required when `type=line_items`.",
            "items": {
              "$ref": "#/components/schemas/LineItemRefund"
            }
          },
          "refund_method": {
            "title": "Refund method",
            "description": "Indicates how the invoice should be refunded when both a credit and transaction are present on the invoice:\n- `transaction_first` â€“ Refunds the transaction first, then any amount is issued as credit back to the account. Default value when Credit Invoices feature is enabled.\n- `credit_first` â€“ Issues credit back to the account first, then refunds any remaining amount back to the transaction. Default value when Credit Invoices feature is not enabled.\n- `all_credit` â€“ Issues credit to the account for the entire amount of the refund. Only available when the Credit Invoices feature is enabled.\n- `all_transaction` â€“ Refunds the entire amount back to transactions, using transactions from previous invoices if necessary. Only available when the Credit Invoices feature is enabled.\n",
            "default": "credit_first",
            "type": "string",
            "enum": [
              "all_credit",
              "all_transaction",
              "credit_first",
              "transaction_first"
            ]
          },
          "credit_customer_notes": {
            "type": "string",
            "title": "Credit customer notes",
            "description": "Used as the Customer Notes on the credit invoice.\n\nThis field can only be include when the Credit Invoices feature is enabled.\n"
          },
          "external_refund": {
            "type": "object",
            "x-class-name": "ExternalRefund",
            "description": "Indicates that the refund was settled outside of Recurly, and a manual transaction should be created to track it in Recurly.\n\nRequired when:\n- refunding a manually collected charge invoice, and `refund_method` is not `all_credit`\n- refunding a credit invoice that refunded manually collecting invoices\n- refunding a credit invoice for a partial amount\n\nThis field can only be included when the Credit Invoices feature is enabled.\n",
            "properties": {
              "payment_method": {
                "title": "Payment Method",
                "description": "Payment method used for external refund transaction.",
                "type": "string",
                "enum": [
                  "bacs",
                  "ach",
                  "amazon",
                  "apple_pay",
                  "braintree_apple_pay",
                  "check",
                  "credit_card",
                  "eft",
                  "google_pay",
                  "money_order",
                  "other",
                  "paypal",
                  "roku",
                  "sepadirectdebit",
                  "wire_transfer"
                ]
              },
              "description": {
                "type": "string",
                "title": "Description",
                "description": "Used as the refund transactions' description.",
                "maxLength": 50
              },
              "refunded_at": {
                "type": "string",
                "format": "date-time",
                "title": "Refunded At",
                "description": "Date the external refund payment was made. Defaults to the current date-time."
              }
            },
            "required": [
              "payment_method"
            ]
          }
        },
        "required": [
          "type"
        ]
      },
      "MeasuredUnit": {
        "type": "object",
        "title": "Measured unit",
        "properties": {
          "id": {
            "type": "string",
            "title": "Item ID",
            "maxLength": 13,
            "readOnly": true
          },
          "object": {
            "type": "string",
            "title": "Object type",
            "readOnly": true
          },
          "name": {
            "type": "string",
            "title": "Name",
            "description": "Unique internal name of the measured unit on your site."
          },
          "display_name": {
            "type": "string",
            "title": "Display name",
            "description": "Display name for the measured unit. Can only contain spaces, underscores and must be alphanumeric.",
            "maxLength": 50
          },
          "state": {
            "title": "State",
            "description": "The current state of the measured unit.",
            "readOnly": true,
            "type": "string",
            "enum": [
              "active",
              "inactive"
            ]
          },
          "description": {
            "type": "string",
            "title": "Description",
            "description": "Optional internal description."
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "title": "Created at",
            "readOnly": true
          },
          "updated_at": {
            "type": "string",
            "format": "date-time",
            "title": "Last updated at",
            "readOnly": true
          },
          "deleted_at": {
            "type": "string",
            "format": "date-time",
            "title": "Deleted at",
            "readOnly": true
          }
        }
      },
      "MeasuredUnitCreate": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "title": "Name",
            "description": "Unique internal name of the measured unit on your site.",
            "maxLength": 255
          },
          "display_name": {
            "type": "string",
            "title": "Display name",
            "description": "Display name for the measured unit.",
            "pattern": "/^[\\w ]+$/",
            "maxLength": 50
          },
          "description": {
            "type": "string",
            "title": "Description",
            "description": "Optional internal description."
          }
        },
        "required": [
          "name",
          "display_name"
        ]
      },
      "MeasuredUnitUpdate": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "title": "Name",
            "description": "Unique internal name of the measured unit on your site.",
            "maxLength": 255
          },
          "display_name": {
            "type": "string",
            "title": "Display name",
            "description": "Display name for the measured unit.",
            "pattern": "/^[\\w ]+$/",
            "maxLength": 50
          },
          "description": {
            "type": "string",
            "title": "Description",
            "description": "Optional internal description."
          }
        }
      },
      "LineItem": {
        "type": "object",
        "title": "Line item",
        "properties": {
          "id": {
            "type": "string",
            "title": "Line item ID",
            "maxLength": 13
          },
          "object": {
            "type": "string",
            "title": "Object type"
          },
          "uuid": {
            "type": "string",
            "title": "UUID",
            "description": "The UUID is useful for matching data with the CSV exports and building URLs into Recurly's UI.",
            "maxLength": 32
          },
          "type": {
            "title": "Line item type",
            "description": "Charges are positive line items that debit the account. Credits are negative line items that credit the account.",
            "type": "string",
            "enum": [
              "charge",
              "credit"
            ]
          },
          "item_code": {
            "type": "string",
            "title": "Item Code",
            "description": "Unique code to identify an item. Available when the Credit Invoices feature is enabled.",
            "pattern": "/^[a-z0-9_+-]+$/",
            "maxLength": 50
          },
          "item_id": {
            "type": "string",
            "title": "Item ID",
            "description": "System-generated unique identifier for an item. Available when the Credit Invoices feature is enabled.",
            "maxLength": 13
          },
          "external_sku": {
            "type": "string",
            "title": "External SKU",
            "description": "Optional Stock Keeping Unit assigned to an item. Available when the Credit Invoices feature is enabled.",
            "maxLength": 50
          },
          "revenue_schedule_type": {
            "title": "Revenue schedule type",
            "type": "string",
            "enum": [
              "at_invoice",
              "at_range_end",
              "at_range_start",
              "evenly",
              "never"
            ]
          },
          "state": {
            "title": "Current state of the line item",
            "description": "Pending line items are charges or credits on an account that have not been applied to an invoice yet. Invoiced line items will always have an `invoice_id` value.",
            "type": "string",
            "enum": [
              "invoiced",
              "pending"
            ]
          },
          "legacy_category": {
            "title": "Legacy category",
            "description": "Category to describe the role of a line item on a legacy invoice:\n- \"charges\" refers to charges being billed for on this invoice.\n- \"credits\" refers to refund or proration credits. This portion of the invoice can be considered a credit memo.\n- \"applied_credits\" refers to previous credits applied to this invoice. See their original_line_item_id to determine where the credit first originated.\n- \"carryforwards\" can be ignored. They exist to consume any remaining credit balance. A new credit with the same amount will be created and placed back on the account.\n",
            "type": "string",
            "enum": [
              "applied_credit",
              "carryforward",
              "charge",
              "credit"
            ]
          },
          "account": {
            "$ref": "#/components/schemas/AccountMini"
          },
          "bill_for_account_id": {
            "type": "string",
            "title": "Bill For Account ID",
            "maxLength": 13,
            "description": "The UUID of the account responsible for originating the line item."
          },
          "subscription_id": {
            "type": "string",
            "title": "Subscription ID",
            "description": "If the line item is a charge or credit for a subscription, this is its ID.",
            "maxLength": 13
          },
          "plan_id": {
            "type": "string",
            "title": "Plan ID",
            "description": "If the line item is a charge or credit for a plan or add-on, this is the plan's ID.",
            "maxLength": 13
          },
          "plan_code": {
            "type": "string",
            "title": "Plan code",
            "description": "If the line item is a charge or credit for a plan or add-on, this is the plan's code.",
            "maxLength": 50
          },
          "add_on_id": {
            "type": "string",
            "title": "Add-on ID",
            "description": "If the line item is a charge or credit for an add-on this is its ID.",
            "maxLength": 13
          },
          "add_on_code": {
            "type": "string",
            "title": "Add-on code",
            "description": "If the line item is a charge or credit for an add-on, this is its code.",
            "maxLength": 50
          },
          "invoice_id": {
            "type": "string",
            "title": "Invoice ID",
            "description": "Once the line item has been invoiced this will be the invoice's ID.",
            "maxLength": 13
          },
          "invoice_number": {
            "type": "string",
            "title": "Invoice number",
            "description": "Once the line item has been invoiced this will be the invoice's number. If VAT taxation and the Country Invoice Sequencing feature are enabled, invoices will have country-specific invoice numbers for invoices billed to EU countries (ex: FR1001). Non-EU invoices will continue to use the site-level invoice number sequence."
          },
          "previous_line_item_id": {
            "type": "string",
            "title": "Previous line item ID",
            "description": "Will only have a value if the line item is a credit created from a previous credit, or if the credit was created from a charge refund.",
            "maxLength": 13
          },
          "original_line_item_invoice_id": {
            "type": "string",
            "title": "Original line item's invoice ID",
            "description": "The invoice where the credit originated. Will only have a value if the line item is a credit created from a previous credit, or if the credit was created from a charge refund.",
            "maxLength": 13
          },
          "origin": {
            "title": "Origin of line item",
            "description": "A credit created from an original charge will have the value of the charge's origin.",
            "type": "string",
            "enum": [
              "add_on",
              "add_on_trial",
              "carryforward",
              "coupon",
              "credit",
              "debit",
              "one_time",
              "plan",
              "plan_trial",
              "setup_fee",
              "prepayment"
            ]
          },
          "accounting_code": {
            "type": "string",
            "title": "Accounting code",
            "description": "Internal accounting code to help you reconcile your revenue to the correct ledger. Line items created as part of a subscription invoice will use the plan or add-on's accounting code, otherwise the value will only be present if you define an accounting code when creating the line item.",
            "maxLength": 20
          },
          "product_code": {
            "type": "string",
            "title": "Product code",
            "description": "For plan-related line items this will be the plan's code, for add-on related line items it will be the add-on's code. For item-related line items it will be the item's `external_sku`.",
            "maxLength": 50
          },
          "credit_reason_code": {
            "title": "Credit reason code",
            "description": "The reason the credit was given when line item is `type=credit`.",
            "default": "general",
            "type": "string",
            "enum": [
              "general",
              "gift_card",
              "promotional",
              "refund",
              "service",
              "write_off"
            ]
          },
          "currency": {
            "type": "string",
            "title": "Currency",
            "description": "3-letter ISO 4217 currency code.",
            "maxLength": 3
          },
          "amount": {
            "type": "number",
            "format": "float",
            "title": "Total after discounts and taxes",
            "description": "`(quantity * unit_amount) - (discount + tax)`"
          },
          "description": {
            "type": "string",
            "title": "Description",
            "description": "Description that appears on the invoice. For subscription related items this will be filled in automatically.",
            "maxLength": 255
          },
          "quantity": {
            "type": "integer",
            "title": "Quantity",
            "description": "This number will be multiplied by the unit amount to compute the subtotal before any discounts or taxes.",
            "default": 1
          },
          "quantity_decimal": {
            "type": "string",
            "title": "Quantity Decimal",
            "description": "A floating-point alternative to Quantity. If this value is present, it will be used in place of Quantity for calculations, and Quantity will be the rounded integer value of this number. This field supports up to 9 decimal places. The Decimal Quantity feature must be enabled to utilize this field."
          },
          "unit_amount": {
            "type": "number",
            "format": "float",
            "title": "Unit amount",
            "description": "Positive amount for a charge, negative amount for a credit."
          },
          "unit_amount_decimal": {
            "type": "string",
            "title": "Unit amount decimal",
            "description": "Positive amount for a charge, negative amount for a credit."
          },
          "tax_inclusive": {
            "type": "boolean",
            "title": "Tax Inclusive?",
            "description": "Determines whether or not tax is included in the unit amount. The Tax Inclusive Pricing feature (separate from the Mixed Tax Pricing feature) must be enabled to utilize this flag."
          },
          "subtotal": {
            "type": "number",
            "format": "float",
            "title": "Total before discounts and taxes",
            "description": "`quantity * unit_amount`"
          },
          "discount": {
            "type": "number",
            "format": "float",
            "title": "Discount",
            "description": "The discount applied to the line item."
          },
          "liability_gl_account_code": {
            "type": "string",
            "title": "Accounting code for the ledger account.",
            "description": "Unique code to identify the ledger account. Each code must start\nwith a letter or number. The following special characters are\nallowed: `-_.,:`\n",
            "pattern": "/^[A-Za-z0-9](( *)?[\\-A-Za-z0-9_.,:])*$/",
            "maxLength": 255
          },
          "revenue_gl_account_code": {
            "type": "string",
            "title": "Accounting code for the ledger account.",
            "description": "Unique code to identify the ledger account. Each code must start\nwith a letter or number. The following special characters are\nallowed: `-_.,:`\n",
            "pattern": "/^[A-Za-z0-9](( *)?[\\-A-Za-z0-9_.,:])*$/",
            "maxLength": 255
          },
          "performance_obligation_id": {
            "type": "string",
            "title": "Performance Obligation ID",
            "description": "The ID of a performance obligation. Performance obligations are\nonly accessible as a part of the Recurly RevRec Standard and\nRecurly RevRec Advanced features.\n",
            "maxLength": 13
          },
          "tax": {
            "type": "number",
            "format": "float",
            "title": "Tax",
            "description": "The tax amount for the line item."
          },
          "taxable": {
            "type": "boolean",
            "title": "Taxable?",
            "description": "`true` if the line item is taxable, `false` if it is not."
          },
          "tax_exempt": {
            "type": "boolean",
            "title": "Tax exempt?",
            "description": "`true` exempts tax on charges, `false` applies tax on charges. If not defined, then defaults to the Plan and Site settings. This attribute does not work for credits (negative line items). Credits are always applied post-tax. Pre-tax discounts should use the Coupons feature."
          },
          "avalara_transaction_type": {
            "type": "integer",
            "title": "Avalara Transaction Type",
            "description": "Used by Avalara for Communications taxes. The transaction type in combination with the service type describe how the line item is taxed. Refer to [the documentation](https://help.avalara.com/AvaTax_for_Communications/Tax_Calculation/AvaTax_for_Communications_Tax_Engine/Mapping_Resources/TM_00115_AFC_Modules_Corresponding_Transaction_Types) for more available t/s types.",
            "minimum": 0
          },
          "avalara_service_type": {
            "type": "integer",
            "title": "Avalara Service Type",
            "description": "Used by Avalara for Communications taxes. The transaction type in combination with the service type describe how the line item is taxed. Refer to [the documentation](https://help.avalara.com/AvaTax_for_Communications/Tax_Calculation/AvaTax_for_Communications_Tax_Engine/Mapping_Resources/TM_00115_AFC_Modules_Corresponding_Transaction_Types) for more available t/s types.",
            "minimum": 0
          },
          "tax_code": {
            "type": "string",
            "maxLength": 50,
            "title": "Tax code",
            "description": "Optional field used by Avalara, Vertex, and Recurly's In-the-Box tax solution to determine taxation rules. You can pass in specific tax codes using any of these tax integrations. For Recurly's In-the-Box tax offering you can also choose to instead use simple values of `unknown`, `physical`, or `digital` tax codes."
          },
          "tax_info": {
            "$ref": "#/components/schemas/TaxInfo"
          },
          "origin_tax_address_source": {
            "type": "string",
            "title": "Origin tax address source",
            "description": "The source of the address that will be used as the origin in determining taxes. Available only when the site is on an Elite plan. A value of \"origin\" refers to the \"Business entity tax address\". A value of \"destination\" refers to the \"Customer tax address\".",
            "default": "origin",
            "enum": [
              "origin",
              "destination"
            ]
          },
          "destination_tax_address_source": {
            "type": "string",
            "title": "Destination tax address source",
            "description": "The source of the address that will be used as the destinaion in determining taxes. Available only when the site is on an Elite plan. A value of \"destination\" refers to the \"Customer tax address\". A value of \"origin\" refers to the \"Business entity tax address\".",
            "default": "destination",
            "enum": [
              "destination",
              "origin"
            ]
          },
          "proration_rate": {
            "type": "number",
            "format": "float",
            "title": "Proration rate",
            "description": "When a line item has been prorated, this is the rate of the proration. Proration rates were made available for line items created after March 30, 2017. For line items created prior to that date, the proration rate will be `null`, even if the line item was prorated.",
            "minimum": 0,
            "maximum": 1
          },
          "refund": {
            "type": "boolean",
            "title": "Refund?"
          },
          "refunded_quantity": {
            "type": "integer",
            "title": "Refunded Quantity",
            "description": "For refund charges, the quantity being refunded. For non-refund charges, the total quantity refunded (possibly over multiple refunds)."
          },
          "refunded_quantity_decimal": {
            "type": "string",
            "title": "Refunded Quantity Decimal",
            "description": "A floating-point alternative to Refunded Quantity. For refund charges, the quantity being refunded. For non-refund charges, the total quantity refunded (possibly over multiple refunds). The Decimal Quantity feature must be enabled to utilize this field."
          },
          "credit_applied": {
            "type": "number",
            "format": "float",
            "title": "Credit Applied",
            "description": "The amount of credit from this line item that was applied to the invoice."
          },
          "shipping_address": {
            "$ref": "#/components/schemas/ShippingAddress"
          },
          "start_date": {
            "type": "string",
            "format": "date-time",
            "title": "Start date",
            "description": "If an end date is present, this is value indicates the beginning of a billing time range. If no end date is present it indicates billing for a specific date."
          },
          "end_date": {
            "type": "string",
            "format": "date-time",
            "title": "End date",
            "description": "If this date is provided, it indicates the end of a time range."
          },
          "custom_fields": {
            "$ref": "#/components/schemas/CustomFields"
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "title": "Created at",
            "description": "When the line item was created."
          },
          "updated_at": {
            "type": "string",
            "format": "date-time",
            "title": "Last updated at",
            "description": "When the line item was last changed."
          }
        }
      },
      "LineItemRefund": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "title": "Line item ID",
            "maxLength": 13
          },
          "quantity": {
            "type": "integer",
            "title": "Quantity",
            "description": "Line item quantity to be refunded. Must be less than or equal to the `quantity_remaining`. If `quantity_decimal`, `amount`, and `percentage` are not present, `quantity` is required. If `amount` or `percentage` is present, `quantity` must be absent."
          },
          "quantity_decimal": {
            "type": "string",
            "title": "Quantity Decimal",
            "description": "Decimal quantity to refund. The `quantity_decimal` will be used to refund charges that has a NOT null quantity decimal. Must be less than or equal to the `quantity_decimal_remaining`. If `quantity`, `amount`, and `percentage` are not present, `quantity_decimal` is required. If `amount` or `percentage` is present, `quantity_decimal` must be absent. The Decimal Quantity feature must be enabled to utilize this field."
          },
          "amount": {
            "type": "number",
            "format": "float",
            "description": "The specific amount to be refunded from the adjustment. Must be less than or equal to the adjustment's remaining balance. If `quantity`, `quantity_decimal` and `percentage` are not present, `amount` is required. If `quantity`, `quantity_decimal`, or `percentage` is present, `amount` must be absent."
          },
          "percentage": {
            "type": "integer",
            "description": "The percentage of the adjustment's remaining balance to refund. If `quantity`, `quantity_decimal` and `amount_in_cents` are not present, `percentage` is required. If `quantity`, `quantity_decimal` or `amount_in_cents` is present, `percentage` must be absent.",
            "minimum": 1,
            "maximum": 100
          },
          "prorate": {
            "type": "boolean",
            "title": "Prorate",
            "description": "Set to `true` if the line item should be prorated; set to `false` if not.\nThis can only be used on line items that have a start and end date.\n",
            "default": false
          }
        }
      },
      "LineItemCreate": {
        "type": "object",
        "properties": {
          "currency": {
            "type": "string",
            "title": "Currency",
            "description": "3-letter ISO 4217 currency code. If `item_code`/`item_id` is part of the request then `currency` is optional, if the site has a single default currency. `currency` is required if `item_code`/`item_id` is present, and there are multiple currencies defined on the site. If `item_code`/`item_id` is not present `currency` is required.",
            "maxLength": 3
          },
          "unit_amount": {
            "type": "number",
            "format": "float",
            "title": "Unit amount",
            "description": "A positive or negative amount with `type=charge` will result in a positive `unit_amount`.\nA positive or negative amount with `type=credit` will result in a negative `unit_amount`.\nIf `item_code`/`item_id` is present, `unit_amount` can be passed in, to override the\n`Item`'s `unit_amount`. If `item_code`/`item_id` is not present then `unit_amount` is required.\n"
          },
          "tax_inclusive": {
            "type": "boolean",
            "title": "Tax Inclusive?",
            "default": false,
            "description": "Determines whether or not tax is included in the unit amount. The Tax Inclusive Pricing feature (separate from the Mixed Tax Pricing feature) must be enabled to use this flag."
          },
          "quantity": {
            "type": "integer",
            "title": "Quantity",
            "description": "This number will be multiplied by the unit amount to compute the subtotal before any discounts or taxes.",
            "default": 1
          },
          "description": {
            "type": "string",
            "title": "Description",
            "description": "Description that appears on the invoice. If `item_code`/`item_id` is part of the request then `description` must be absent.",
            "maxLength": 255
          },
          "item_code": {
            "type": "string",
            "title": "Item Code",
            "description": "Unique code to identify an item. Available when the Credit Invoices feature is enabled.",
            "pattern": "/^[a-z0-9_+-]+$/",
            "maxLength": 50
          },
          "item_id": {
            "type": "string",
            "title": "Item ID",
            "description": "System-generated unique identifier for an item. Available when the Credit Invoices feature is enabled.",
            "maxLength": 13
          },
          "revenue_schedule_type": {
            "title": "Revenue schedule type",
            "type": "string",
            "enum": [
              "at_invoice",
              "at_range_end",
              "at_range_start",
              "evenly",
              "never"
            ]
          },
          "type": {
            "title": "Type",
            "description": "Line item type. If `item_code`/`item_id` is present then `type` should not be present. If `item_code`/`item_id` is not present then `type` is required.",
            "type": "string",
            "enum": [
              "charge",
              "credit"
            ]
          },
          "credit_reason_code": {
            "title": "Credit reason code",
            "description": "The reason the credit was given when line item is `type=credit`. When the Credit Invoices feature is enabled, the value can be set and will default to `general`. When the Credit Invoices feature is not enabled, the value will always be `null`.",
            "default": "general",
            "type": "string",
            "enum": [
              "general",
              "promotional",
              "service"
            ]
          },
          "accounting_code": {
            "type": "string",
            "title": "Accounting Code",
            "description": "Accounting Code for the `LineItem`. If `item_code`/`item_id` is part of the request then `accounting_code` must be absent.",
            "pattern": "/^[a-z0-9_+-]+$/",
            "maxLength": 20
          },
          "liability_gl_account_id": {
            "type": "string",
            "title": "General Ledger Account ID",
            "description": "The ID of a general ledger account. General ledger accounts are\nonly accessible as a part of the Recurly RevRec Standard and\nRecurly RevRec Advanced features.\n",
            "maxLength": 13
          },
          "revenue_gl_account_id": {
            "type": "string",
            "title": "General Ledger Account ID",
            "description": "The ID of a general ledger account. General ledger accounts are\nonly accessible as a part of the Recurly RevRec Standard and\nRecurly RevRec Advanced features.\n",
            "maxLength": 13
          },
          "performance_obligation_id": {
            "type": "string",
            "title": "Performance Obligation ID",
            "description": "The ID of a performance obligation. Performance obligations are\nonly accessible as a part of the Recurly RevRec Standard and\nRecurly RevRec Advanced features.\n",
            "maxLength": 13
          },
          "tax_exempt": {
            "type": "boolean",
            "title": "Tax exempt?",
            "description": "`true` exempts tax on charges, `false` applies tax on charges. If not defined, then defaults to the Plan and Site settings. This attribute does not work for credits (negative line items). Credits are always applied post-tax. Pre-tax discounts should use the Coupons feature."
          },
          "avalara_transaction_type": {
            "type": "integer",
            "title": "Avalara Transaction Type",
            "description": "Used by Avalara for Communications taxes. The transaction type in combination with the service type describe how the line item is taxed. Refer to [the documentation](https://help.avalara.com/AvaTax_for_Communications/Tax_Calculation/AvaTax_for_Communications_Tax_Engine/Mapping_Resources/TM_00115_AFC_Modules_Corresponding_Transaction_Types) for more available t/s types. If an `Item` is associated to the `LineItem`, then the `avalara_transaction_type` must be absent.",
            "minimum": 0
          },
          "avalara_service_type": {
            "type": "integer",
            "title": "Avalara Service Type",
            "description": "Used by Avalara for Communications taxes. The transaction type in combination with the service type describe how the line item is taxed. Refer to [the documentation](https://help.avalara.com/AvaTax_for_Communications/Tax_Calculation/AvaTax_for_Communications_Tax_Engine/Mapping_Resources/TM_00115_AFC_Modules_Corresponding_Transaction_Types) for more available t/s types. If an `Item` is associated to the `LineItem`, then the `avalara_service_type` must be absent.",
            "minimum": 0
          },
          "tax_code": {
            "type": "string",
            "maxLength": 50,
            "title": "Tax code",
            "description": "Optional field used by Avalara, Vertex, and Recurly's In-the-Box tax solution to determine taxation rules. You can pass in specific tax codes using any of these tax integrations. For Recurly's In-the-Box tax offering you can also choose to instead use simple values of `unknown`, `physical`, or `digital` tax codes."
          },
          "product_code": {
            "type": "string",
            "title": "Product code",
            "description": "Optional field to track a product code or SKU for the line item. This can be used to later reporting on product purchases. For Vertex tax calculations, this field will be used as the Vertex `product` field. If `item_code`/`item_id` is part of the request then `product_code` must be absent.",
            "maxLength": 50
          },
          "origin": {
            "title": "Origin",
            "description": "Origin `external_gift_card` is allowed if the Gift Cards feature is enabled on your site and `type` is `credit`. Set this value in order to track gift card credits from external gift cards (like InComm). It also skips billing information requirements.  Origin `prepayment` is only allowed if `type` is `charge` and `tax_exempt` is left blank or set to true.  This origin creates a charge and opposite credit on the account to be used for future invoices.",
            "type": "string",
            "enum": [
              "external_gift_card",
              "prepayment"
            ]
          },
          "custom_fields": {
            "$ref": "#/components/schemas/CustomFields"
          },
          "start_date": {
            "type": "string",
            "format": "date-time",
            "title": "Start date",
            "description": "If an end date is present, this is value indicates the beginning of a billing time range. If no end date is present it indicates billing for a specific date. Defaults to the current date-time."
          },
          "end_date": {
            "type": "string",
            "format": "date-time",
            "title": "End date",
            "description": "If this date is provided, it indicates the end of a time range."
          },
          "origin_tax_address_source": {
            "type": "string",
            "title": "Origin tax address source",
            "description": "The source of the address that will be used as the origin in determining taxes. Available only when the site is on an Elite plan. A value of \"origin\" refers to the \"Business entity tax address\". A value of \"destination\" refers to the \"Customer tax address\".",
            "default": "origin",
            "enum": [
              "origin",
              "destination"
            ]
          },
          "destination_tax_address_source": {
            "type": "string",
            "title": "Destination tax address source",
            "description": "The source of the address that will be used as the destinaion in determining taxes. Available only when the site is on an Elite plan. A value of \"destination\" refers to the \"Customer tax address\". A value of \"origin\" refers to the \"Business entity tax address\".",
            "default": "destination",
            "enum": [
              "destination",
              "origin"
            ]
          }
        },
        "required": [
          "currency",
          "unit_amount",
          "type"
        ]
      },
      "PlanMini": {
        "type": "object",
        "title": "Plan mini details",
        "description": "Just the important parts.",
        "properties": {
          "id": {
            "type": "string",
            "title": "Plan ID",
            "maxLength": 13,
            "readOnly": true
          },
          "object": {
            "type": "string",
            "title": "Object type",
            "readOnly": true
          },
          "code": {
            "type": "string",
            "title": "Plan code",
            "description": "Unique code to identify the plan. This is used in Hosted Payment Page URLs and in the invoice exports.",
            "pattern": "/^[a-z0-9_+-]+$/i",
            "maxLength": 50
          },
          "name": {
            "type": "string",
            "title": "Name",
            "description": "This name describes your plan and will appear on the Hosted Payment Page and the subscriber's invoice.",
            "maxLength": 255
          }
        }
      },
      "Plan": {
        "type": "object",
        "description": "Full plan details.",
        "properties": {
          "id": {
            "type": "string",
            "title": "Plan ID",
            "maxLength": 13,
            "readOnly": true
          },
          "object": {
            "type": "string",
            "title": "Object type",
            "readOnly": true
          },
          "code": {
            "type": "string",
            "title": "Plan code",
            "description": "Unique code to identify the plan. This is used in Hosted Payment Page URLs and in the invoice exports.",
            "pattern": "/^[a-z0-9_+-]+$/i",
            "maxLength": 50
          },
          "state": {
            "title": "State",
            "description": "The current state of the plan.",
            "readOnly": true,
            "type": "string",
            "enum": [
              "active",
              "inactive"
            ]
          },
          "name": {
            "type": "string",
            "title": "Name",
            "description": "This name describes your plan and will appear on the Hosted Payment Page and the subscriber's invoice.",
            "maxLength": 255
          },
          "description": {
            "type": "string",
            "title": "Description",
            "description": "Optional description, not displayed."
          },
          "interval_unit": {
            "title": "Interval unit",
            "description": "Unit for the plan's billing interval.",
            "default": "months",
            "type": "string",
            "enum": [
              "days",
              "months"
            ]
          },
          "interval_length": {
            "type": "integer",
            "title": "Interval length",
            "description": "Length of the plan's billing interval in `interval_unit`.",
            "default": 1,
            "minimum": 1
          },
          "trial_unit": {
            "title": "Trial unit",
            "description": "Units for the plan's trial period.",
            "default": "months",
            "type": "string",
            "enum": [
              "days",
              "months"
            ]
          },
          "trial_length": {
            "type": "integer",
            "title": "Trial length",
            "description": "Length of plan's trial period in `trial_units`. `0` means `no trial`.",
            "default": 0,
            "minimum": 0
          },
          "trial_requires_billing_info": {
            "type": "boolean",
            "title": "Trial Requires BillingInfo",
            "description": "Allow free trial subscriptions to be created without billing info. Should not be used if billing info is needed for initial invoice due to existing uninvoiced charges or setup fee.",
            "default": true
          },
          "total_billing_cycles": {
            "type": "integer",
            "title": "Total billing cycles",
            "description": "Automatically terminate subscriptions after a defined number of billing cycles. Number of billing cycles before the plan automatically stops renewing, defaults to `null` for continuous, automatic renewal.",
            "minimum": 0
          },
          "auto_renew": {
            "type": "boolean",
            "title": "Auto renew",
            "default": true,
            "description": "Subscriptions will automatically inherit this value once they are active. If `auto_renew` is `true`, then a subscription will automatically renew its term at renewal. If `auto_renew` is `false`, then a subscription will expire at the end of its term. `auto_renew` can be overridden on the subscription record itself."
          },
          "pricing_model": {
            "title": "Pricing Model",
            "type": "string",
            "enum": [
              "fixed",
              "ramp"
            ],
            "default": "fixed",
            "description": "A fixed pricing model has the same price for each billing period.\nA ramp pricing model defines a set of Ramp Intervals, where a subscription changes price on\na specified cadence of billing periods. The price change could be an increase or decrease.\n"
          },
          "ramp_intervals": {
            "type": "array",
            "title": "Ramp Intervals",
            "items": {
              "$ref": "#/components/schemas/PlanRampInterval"
            }
          },
          "custom_fields": {
            "$ref": "#/components/schemas/CustomFields"
          },
          "revenue_schedule_type": {
            "title": "Revenue schedule type",
            "type": "string",
            "enum": [
              "at_range_end",
              "at_range_start",
              "evenly",
              "never"
            ]
          },
          "setup_fee_revenue_schedule_type": {
            "title": "Setup fee revenue schedule type",
            "type": "string",
            "enum": [
              "at_range_end",
              "at_range_start",
              "evenly",
              "never"
            ]
          },
          "accounting_code": {
            "type": "string",
            "title": "Plan accounting code",
            "description": "Accounting code for invoice line items for the plan. If no value is provided, it defaults to plan's code.",
            "pattern": "/^[a-z0-9_+-]+$/",
            "maxLength": 20
          },
          "setup_fee_accounting_code": {
            "type": "string",
            "title": "Setup fee accounting code",
            "description": "Accounting code for invoice line items for the plan's setup fee. If no value is provided, it defaults to plan's accounting code.",
            "pattern": "/^[a-z0-9_+-]+$/",
            "maxLength": 20
          },
          "avalara_transaction_type": {
            "type": "integer",
            "title": "Avalara Transaction Type",
            "description": "Used by Avalara for Communications taxes. The transaction type in combination with the service type describe how the plan is taxed. Refer to [the documentation](https://help.avalara.com/AvaTax_for_Communications/Tax_Calculation/AvaTax_for_Communications_Tax_Engine/Mapping_Resources/TM_00115_AFC_Modules_Corresponding_Transaction_Types) for more available t/s types.",
            "minimum": 0
          },
          "avalara_service_type": {
            "type": "integer",
            "title": "Avalara Service Type",
            "description": "Used by Avalara for Communications taxes. The transaction type in combination with the service type describe how the plan is taxed. Refer to [the documentation](https://help.avalara.com/AvaTax_for_Communications/Tax_Calculation/AvaTax_for_Communications_Tax_Engine/Mapping_Resources/TM_00115_AFC_Modules_Corresponding_Transaction_Types) for more available t/s types.",
            "minimum": 0
          },
          "tax_code": {
            "type": "string",
            "maxLength": 50,
            "title": "Tax code",
            "description": "Optional field used by Avalara, Vertex, and Recurly's In-the-Box tax solution to determine taxation rules. You can pass in specific tax codes using any of these tax integrations. For Recurly's In-the-Box tax offering you can also choose to instead use simple values of `unknown`, `physical`, or `digital` tax codes."
          },
          "tax_exempt": {
            "type": "boolean",
            "title": "Tax exempt?",
            "description": "`true` exempts tax on the plan, `false` applies tax on the plan."
          },
          "currencies": {
            "type": "array",
            "title": "Pricing",
            "items": {
              "$ref": "#/components/schemas/PlanPricing"
            },
            "minItems": 1
          },
          "hosted_pages": {
            "type": "object",
            "title": "Hosted pages settings",
            "$ref": "#/components/schemas/PlanHostedPages"
          },
          "allow_any_item_on_subscriptions": {
            "type": "boolean",
            "title": "Allow any item on subscriptions",
            "description": "Used to determine whether items can be assigned as add-ons to individual subscriptions.\nIf `true`, items can be assigned as add-ons to individual subscription add-ons.\nIf `false`, only plan add-ons can be used.\n"
          },
          "dunning_campaign_id": {
            "type": "string",
            "title": "Dunning Campaign ID",
            "description": "Unique ID to identify a dunning campaign. Used to specify if a non-default dunning campaign should be assigned to this plan. For sites without multiple dunning campaigns enabled, the default dunning campaign will always be used."
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "title": "Created at",
            "readOnly": true
          },
          "updated_at": {
            "type": "string",
            "format": "date-time",
            "title": "Last updated at",
            "readOnly": true
          },
          "deleted_at": {
            "type": "string",
            "format": "date-time",
            "title": "Deleted at",
            "readOnly": true
          }
        },
        "required": [
          "code",
          "name"
        ]
      },
      "PlanCreate": {
        "type": "object",
        "properties": {
          "code": {
            "type": "string",
            "title": "Plan code",
            "description": "Unique code to identify the plan. This is used in Hosted Payment Page URLs and in the invoice exports.",
            "pattern": "/^[a-z0-9_+-]+$/i",
            "maxLength": 50
          },
          "name": {
            "type": "string",
            "title": "Name",
            "description": "This name describes your plan and will appear on the Hosted Payment Page and the subscriber's invoice.",
            "maxLength": 255
          },
          "description": {
            "type": "string",
            "title": "Description",
            "description": "Optional description, not displayed."
          },
          "accounting_code": {
            "type": "string",
            "title": "Plan accounting code",
            "description": "Accounting code for invoice line items for the plan. If no value is provided, it defaults to plan's code.",
            "pattern": "/^[a-z0-9_+-]+$/",
            "maxLength": 20
          },
          "interval_unit": {
            "title": "Interval unit",
            "description": "Unit for the plan's billing interval.",
            "default": "months",
            "type": "string",
            "enum": [
              "days",
              "months"
            ]
          },
          "interval_length": {
            "type": "integer",
            "title": "Interval length",
            "description": "Length of the plan's billing interval in `interval_unit`.",
            "default": 1,
            "minimum": 1
          },
          "trial_unit": {
            "title": "Trial unit",
            "description": "Units for the plan's trial period.",
            "default": "months",
            "type": "string",
            "enum": [
              "days",
              "months"
            ]
          },
          "trial_length": {
            "type": "integer",
            "title": "Trial length",
            "description": "Length of plan's trial period in `trial_units`. `0` means `no trial`.",
            "default": 0,
            "minimum": 0
          },
          "trial_requires_billing_info": {
            "type": "boolean",
            "title": "Trial Requires BillingInfo",
            "description": "Allow free trial subscriptions to be created without billing info. Should not be used if billing info is needed for initial invoice due to existing uninvoiced charges or setup fee.",
            "default": true
          },
          "total_billing_cycles": {
            "type": "integer",
            "title": "Total billing cycles",
            "description": "Automatically terminate plans after a defined number of billing cycles.",
            "minimum": 0
          },
          "auto_renew": {
            "type": "boolean",
            "title": "Auto renew",
            "default": true,
            "description": "Subscriptions will automatically inherit this value once they are active. If `auto_renew` is `true`, then a subscription will automatically renew its term at renewal. If `auto_renew` is `false`, then a subscription will expire at the end of its term. `auto_renew` can be overridden on the subscription record itself."
          },
          "pricing_model": {
            "title": "Pricing Model",
            "type": "string",
            "enum": [
              "fixed",
              "ramp"
            ],
            "default": "fixed",
            "description": "A fixed pricing model has the same price for each billing period.\nA ramp pricing model defines a set of Ramp Intervals, where a subscription changes price on\na specified cadence of billing periods. The price change could be an increase or decrease.\n"
          },
          "ramp_intervals": {
            "type": "array",
            "title": "Ramp Intervals",
            "items": {
              "$ref": "#/components/schemas/PlanRampInterval"
            }
          },
          "custom_fields": {
            "$ref": "#/components/schemas/CustomFields"
          },
          "revenue_schedule_type": {
            "title": "Revenue schedule type",
            "type": "string",
            "enum": [
              "at_range_end",
              "at_range_start",
              "evenly",
              "never"
            ]
          },
          "liability_gl_account_id": {
            "type": "string",
            "title": "General Ledger Account ID",
            "description": "The ID of a general ledger account. General ledger accounts are\nonly accessible as a part of the Recurly RevRec Standard and\nRecurly RevRec Advanced features.\n",
            "maxLength": 13
          },
          "revenue_gl_account_id": {
            "type": "string",
            "title": "General Ledger Account ID",
            "description": "The ID of a general ledger account. General ledger accounts are\nonly accessible as a part of the Recurly RevRec Standard and\nRecurly RevRec Advanced features.\n",
            "maxLength": 13
          },
          "performance_obligation_id": {
            "type": "string",
            "title": "Performance Obligation ID",
            "description": "The ID of a performance obligation. Performance obligations are\nonly accessible as a part of the Recurly RevRec Standard and\nRecurly RevRec Advanced features.\n",
            "maxLength": 13
          },
          "setup_fee_liability_gl_account_id": {
            "type": "string",
            "title": "General Ledger Account ID",
            "description": "The ID of a general ledger account. General ledger accounts are\nonly accessible as a part of the Recurly RevRec Standard and\nRecurly RevRec Advanced features.\n",
            "maxLength": 13
          },
          "setup_fee_revenue_gl_account_id": {
            "type": "string",
            "title": "General Ledger Account ID",
            "description": "The ID of a general ledger account. General ledger accounts are\nonly accessible as a part of the Recurly RevRec Standard and\nRecurly RevRec Advanced features.\n",
            "maxLength": 13
          },
          "setup_fee_performance_obligation_id": {
            "type": "string",
            "title": "Performance Obligation ID",
            "description": "The ID of a performance obligation. Performance obligations are\nonly accessible as a part of the Recurly RevRec Standard and\nRecurly RevRec Advanced features.\n",
            "maxLength": 13
          },
          "setup_fee_revenue_schedule_type": {
            "title": "Setup fee revenue schedule type",
            "type": "string",
            "enum": [
              "at_range_end",
              "at_range_start",
              "evenly",
              "never"
            ]
          },
          "setup_fee_accounting_code": {
            "type": "string",
            "title": "Setup fee accounting code",
            "description": "Accounting code for invoice line items for the plan's setup fee. If no value is provided, it defaults to plan's accounting code.",
            "pattern": "/^[a-z0-9_+-]+$/",
            "maxLength": 20
          },
          "avalara_transaction_type": {
            "type": "integer",
            "title": "Avalara Transaction Type",
            "description": "Used by Avalara for Communications taxes. The transaction type in combination with the service type describe how the plan is taxed. Refer to [the documentation](https://help.avalara.com/AvaTax_for_Communications/Tax_Calculation/AvaTax_for_Communications_Tax_Engine/Mapping_Resources/TM_00115_AFC_Modules_Corresponding_Transaction_Types) for more available t/s types.",
            "minimum": 0
          },
          "avalara_service_type": {
            "type": "integer",
            "title": "Avalara Service Type",
            "description": "Used by Avalara for Communications taxes. The transaction type in combination with the service type describe how the plan is taxed. Refer to [the documentation](https://help.avalara.com/AvaTax_for_Communications/Tax_Calculation/AvaTax_for_Communications_Tax_Engine/Mapping_Resources/TM_00115_AFC_Modules_Corresponding_Transaction_Types) for more available t/s types.",
            "minimum": 0
          },
          "tax_code": {
            "type": "string",
            "maxLength": 50,
            "title": "Tax code",
            "description": "Optional field used by Avalara, Vertex, and Recurly's In-the-Box tax solution to determine taxation rules. You can pass in specific tax codes using any of these tax integrations. For Recurly's In-the-Box tax offering you can also choose to instead use simple values of `unknown`, `physical`, or `digital` tax codes."
          },
          "tax_exempt": {
            "type": "boolean",
            "title": "Tax exempt?",
            "description": "`true` exempts tax on the plan, `false` applies tax on the plan."
          },
          "currencies": {
            "type": "array",
            "title": "Pricing",
            "items": {
              "$ref": "#/components/schemas/PlanPricing"
            },
            "minItems": 1
          },
          "hosted_pages": {
            "type": "object",
            "title": "Hosted pages settings",
            "$ref": "#/components/schemas/PlanHostedPages"
          },
          "add_ons": {
            "type": "array",
            "title": "Add Ons",
            "items": {
              "$ref": "#/components/schemas/AddOnCreate"
            }
          },
          "allow_any_item_on_subscriptions": {
            "type": "boolean",
            "title": "Allow any item on subscriptions",
            "default": false,
            "description": "Used to determine whether items can be assigned as add-ons to individual subscriptions.\nIf `true`, items can be assigned as add-ons to individual subscription add-ons.\nIf `false`, only plan add-ons can be used.\n"
          },
          "dunning_campaign_id": {
            "type": "string",
            "title": "Dunning Campaign ID",
            "description": "Unique ID to identify a dunning campaign. Used to specify if a non-default dunning campaign should be assigned to this plan. For sites without multiple dunning campaigns enabled, the default dunning campaign will always be used."
          }
        },
        "required": [
          "code",
          "name",
          "currencies"
        ]
      },
      "PlanHostedPages": {
        "type": "object",
        "properties": {
          "success_url": {
            "type": "string",
            "title": "Success redirect URL",
            "description": "URL to redirect to after signup on the hosted payment pages."
          },
          "cancel_url": {
            "type": "string",
            "title": "Cancel redirect URL (deprecated)",
            "description": "URL to redirect to on canceled signup on the hosted payment pages."
          },
          "bypass_confirmation": {
            "type": "boolean",
            "title": "Bypass confirmation page?",
            "description": "If `true`, the customer will be sent directly to your `success_url` after a successful signup, bypassing Recurly's hosted confirmation page."
          },
          "display_quantity": {
            "type": "boolean",
            "title": "Display quantity?",
            "description": "Determines if the quantity field is displayed on the hosted pages for the plan."
          }
        }
      },
      "PlanPricing": {
        "type": "object",
        "properties": {
          "currency": {
            "type": "string",
            "title": "Currency",
            "description": "3-letter ISO 4217 currency code.",
            "maxLength": 3
          },
          "setup_fee": {
            "type": "number",
            "format": "float",
            "title": "Setup fee",
            "description": "Amount of one-time setup fee automatically charged at the beginning of a subscription billing cycle. For subscription plans with a trial, the setup fee will be charged at the time of signup. Setup fees do not increase with the quantity of a subscription plan.",
            "minimum": 0,
            "maximum": 1000000
          },
          "unit_amount": {
            "type": "number",
            "format": "float",
            "title": "Unit price",
            "description": "This field should not be sent when the pricing model is 'ramp'.",
            "minimum": 0,
            "maximum": 1000000
          },
          "tax_inclusive": {
            "type": "boolean",
            "title": "Tax Inclusive?",
            "default": false,
            "description": "This field is deprecated. Please do not use it.",
            "deprecated": true
          }
        }
      },
      "PlanRampInterval": {
        "type": "object",
        "title": "Plan Ramp Interval",
        "properties": {
          "starting_billing_cycle": {
            "type": "integer",
            "description": "Represents the billing cycle where a ramp interval starts.",
            "default": 1
          },
          "currencies": {
            "type": "array",
            "description": "Represents the price for the ramp interval.",
            "items": {
              "$ref": "#/components/schemas/PlanRampPricing"
            }
          }
        }
      },
      "PlanUpdate": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "title": "Plan ID",
            "maxLength": 13,
            "readOnly": true
          },
          "code": {
            "type": "string",
            "title": "Plan code",
            "description": "Unique code to identify the plan. This is used in Hosted Payment Page URLs and in the invoice exports.",
            "pattern": "/^[a-z0-9_+-]+$/i",
            "maxLength": 50
          },
          "name": {
            "type": "string",
            "title": "Name",
            "description": "This name describes your plan and will appear on the Hosted Payment Page and the subscriber's invoice.",
            "maxLength": 255
          },
          "description": {
            "type": "string",
            "title": "Description",
            "description": "Optional description, not displayed."
          },
          "accounting_code": {
            "type": "string",
            "title": "Plan accounting code",
            "description": "Accounting code for invoice line items for the plan. If no value is provided, it defaults to plan's code.",
            "pattern": "/^[a-z0-9_+-]+$/",
            "maxLength": 20
          },
          "trial_unit": {
            "title": "Trial unit",
            "description": "Units for the plan's trial period.",
            "default": "months",
            "type": "string",
            "enum": [
              "days",
              "months"
            ]
          },
          "trial_length": {
            "type": "integer",
            "title": "Trial length",
            "description": "Length of plan's trial period in `trial_units`. `0` means `no trial`.",
            "default": 0,
            "minimum": 0
          },
          "trial_requires_billing_info": {
            "type": "boolean",
            "title": "Trial Requires BillingInfo",
            "description": "Allow free trial subscriptions to be created without billing info. Should not be used if billing info is needed for initial invoice due to existing uninvoiced charges or setup fee.",
            "default": true
          },
          "total_billing_cycles": {
            "type": "integer",
            "title": "Total billing cycles",
            "description": "Automatically terminate plans after a defined number of billing cycles.",
            "minimum": 0
          },
          "auto_renew": {
            "type": "boolean",
            "title": "Auto renew",
            "default": true,
            "description": "Subscriptions will automatically inherit this value once they are active. If `auto_renew` is `true`, then a subscription will automatically renew its term at renewal. If `auto_renew` is `false`, then a subscription will expire at the end of its term. `auto_renew` can be overridden on the subscription record itself."
          },
          "ramp_intervals": {
            "type": "array",
            "title": "Ramp Intervals",
            "items": {
              "$ref": "#/components/schemas/PlanRampInterval"
            }
          },
          "custom_fields": {
            "$ref": "#/components/schemas/CustomFields"
          },
          "revenue_schedule_type": {
            "title": "Revenue schedule type",
            "type": "string",
            "enum": [
              "at_range_end",
              "at_range_start",
              "evenly",
              "never"
            ]
          },
          "liability_gl_account_id": {
            "type": "string",
            "title": "General Ledger Account ID",
            "description": "The ID of a general ledger account. General ledger accounts are\nonly accessible as a part of the Recurly RevRec Standard and\nRecurly RevRec Advanced features.\n",
            "maxLength": 13
          },
          "revenue_gl_account_id": {
            "type": "string",
            "title": "General Ledger Account ID",
            "description": "The ID of a general ledger account. General ledger accounts are\nonly accessible as a part of the Recurly RevRec Standard and\nRecurly RevRec Advanced features.\n",
            "maxLength": 13
          },
          "performance_obligation_id": {
            "type": "string",
            "title": "Performance Obligation ID",
            "description": "The ID of a performance obligation. Performance obligations are\nonly accessible as a part of the Recurly RevRec Standard and\nRecurly RevRec Advanced features.\n",
            "maxLength": 13
          },
          "setup_fee_liability_gl_account_id": {
            "type": "string",
            "title": "General Ledger Account ID",
            "description": "The ID of a general ledger account. General ledger accounts are\nonly accessible as a part of the Recurly RevRec Standard and\nRecurly RevRec Advanced features.\n",
            "maxLength": 13
          },
          "setup_fee_revenue_gl_account_id": {
            "type": "string",
            "title": "General Ledger Account ID",
            "description": "The ID of a general ledger account. General ledger accounts are\nonly accessible as a part of the Recurly RevRec Standard and\nRecurly RevRec Advanced features.\n",
            "maxLength": 13
          },
          "setup_fee_performance_obligation_id": {
            "type": "string",
            "title": "Performance Obligation ID",
            "description": "The ID of a performance obligation. Performance obligations are\nonly accessible as a part of the Recurly RevRec Standard and\nRecurly RevRec Advanced features.\n",
            "maxLength": 13
          },
          "setup_fee_revenue_schedule_type": {
            "title": "Setup fee revenue schedule type",
            "type": "string",
            "enum": [
              "at_range_end",
              "at_range_start",
              "evenly",
              "never"
            ]
          },
          "setup_fee_accounting_code": {
            "type": "string",
            "title": "Setup fee accounting code",
            "description": "Accounting code for invoice line items for the plan's setup fee. If no value is provided, it defaults to plan's accounting code.",
            "pattern": "/^[a-z0-9_+-]+$/",
            "maxLength": 20
          },
          "avalara_transaction_type": {
            "type": "integer",
            "title": "Avalara Transaction Type",
            "description": "Used by Avalara for Communications taxes. The transaction type in combination with the service type describe how the plan is taxed. Refer to [the documentation](https://help.avalara.com/AvaTax_for_Communications/Tax_Calculation/AvaTax_for_Communications_Tax_Engine/Mapping_Resources/TM_00115_AFC_Modules_Corresponding_Transaction_Types) for more available t/s types.",
            "minimum": 0
          },
          "avalara_service_type": {
            "type": "integer",
            "title": "Avalara Service Type",
            "description": "Used by Avalara for Communications taxes. The transaction type in combination with the service type describe how the plan is taxed. Refer to [the documentation](https://help.avalara.com/AvaTax_for_Communications/Tax_Calculation/AvaTax_for_Communications_Tax_Engine/Mapping_Resources/TM_00115_AFC_Modules_Corresponding_Transaction_Types) for more available t/s types.",
            "minimum": 0
          },
          "tax_code": {
            "type": "string",
            "maxLength": 50,
            "title": "Tax code",
            "description": "Optional field used by Avalara, Vertex, and Recurly's In-the-Box tax solution to determine taxation rules. You can pass in specific tax codes using any of these tax integrations. For Recurly's In-the-Box tax offering you can also choose to instead use simple values of `unknown`, `physical`, or `digital` tax codes."
          },
          "tax_exempt": {
            "type": "boolean",
            "title": "Tax exempt?",
            "description": "`true` exempts tax on the plan, `false` applies tax on the plan."
          },
          "currencies": {
            "type": "array",
            "title": "Pricing",
            "description": "Optional when the pricing model is 'ramp'.",
            "items": {
              "$ref": "#/components/schemas/PlanPricing"
            },
            "minItems": 1
          },
          "hosted_pages": {
            "type": "object",
            "title": "Hosted pages settings",
            "$ref": "#/components/schemas/PlanHostedPages"
          },
          "allow_any_item_on_subscriptions": {
            "type": "boolean",
            "title": "Allow any item on subscriptions",
            "description": "Used to determine whether items can be assigned as add-ons to individual subscriptions.\nIf `true`, items can be assigned as add-ons to individual subscription add-ons.\nIf `false`, only plan add-ons can be used.\n"
          },
          "dunning_campaign_id": {
            "type": "string",
            "title": "Dunning Campaign ID",
            "description": "Unique ID to identify a dunning campaign. Used to specify if a non-default dunning campaign should be assigned to this plan. For sites without multiple dunning campaigns enabled, the default dunning campaign will always be used."
          }
        }
      },
      "AddOnPricing": {
        "type": "object",
        "properties": {
          "currency": {
            "type": "string",
            "title": "Currency",
            "description": "3-letter ISO 4217 currency code.",
            "maxLength": 3
          },
          "unit_amount": {
            "type": "number",
            "format": "float",
            "title": "Unit price",
            "minimum": 0,
            "maximum": 1000000,
            "description": "Allows up to 2 decimal places. Required unless `unit_amount_decimal` is provided."
          },
          "unit_amount_decimal": {
            "type": "string",
            "title": "Unit Amount Decimal",
            "minimum": 0,
            "maximum": 1000000,
            "description": "Allows up to 9 decimal places. Only supported when `add_on_type` = `usage`.\nIf `unit_amount_decimal` is provided, `unit_amount` cannot be provided.\n"
          },
          "tax_inclusive": {
            "type": "boolean",
            "title": "Tax Inclusive?",
            "default": false,
            "description": "This field is deprecated. Please do not use it.",
            "deprecated": true
          }
        },
        "required": [
          "currency"
        ]
      },
      "TierPricing": {
        "type": "object",
        "properties": {
          "currency": {
            "type": "string",
            "title": "Currency",
            "description": "3-letter ISO 4217 currency code.",
            "maxLength": 3
          },
          "unit_amount": {
            "type": "number",
            "format": "float",
            "title": "Unit price",
            "minimum": 0,
            "maximum": 1000000,
            "description": "Allows up to 2 decimal places. Required unless `unit_amount_decimal` is provided."
          },
          "unit_amount_decimal": {
            "type": "string",
            "title": "Unit Amount Decimal",
            "minimum": 0,
            "maximum": 1000000,
            "description": "Allows up to 9 decimal places. Only supported when `add_on_type` = `usage`.\nIf `unit_amount_decimal` is provided, `unit_amount` cannot be provided.\n"
          }
        },
        "required": [
          "currency"
        ]
      },
      "PlanRampPricing": {
        "type": "object",
        "properties": {
          "currency": {
            "type": "string",
            "title": "Currency",
            "description": "3-letter ISO 4217 currency code.",
            "maxLength": 3
          },
          "unit_amount": {
            "type": "number",
            "format": "float",
            "title": "Unit price",
            "description": "Represents the price for the Ramp Interval.",
            "minimum": 0,
            "maximum": 1000000
          }
        },
        "required": [
          "currency",
          "unit_amount"
        ]
      },
      "Pricing": {
        "type": "object",
        "properties": {
          "currency": {
            "type": "string",
            "title": "Currency",
            "description": "3-letter ISO 4217 currency code.",
            "maxLength": 3
          },
          "unit_amount": {
            "type": "number",
            "format": "float",
            "title": "Unit price",
            "minimum": 0,
            "maximum": 1000000
          },
          "tax_inclusive": {
            "type": "boolean",
            "title": "Tax Inclusive?",
            "default": false,
            "description": "This field is deprecated. Please do not use it.",
            "deprecated": true
          }
        },
        "required": [
          "currency",
          "unit_amount"
        ]
      },
      "Tier": {
        "type": "object",
        "properties": {
          "ending_quantity": {
            "type": "integer",
            "title": "Ending quantity",
            "minimum": 1,
            "maximum": 999999999,
            "description": "Ending quantity for the tier.  This represents a unit amount for unit-priced add ons. Must be left empty if it is the final tier."
          },
          "usage_percentage": {
            "type": "string",
            "title": "Usage Percentage",
            "description": "(deprecated) -- Use the percentage_tiers object instead.",
            "deprecated": true
          },
          "currencies": {
            "type": "array",
            "title": "Tier pricing",
            "items": {
              "$ref": "#/components/schemas/TierPricing"
            },
            "minItems": 1
          }
        }
      },
      "PercentageTiersByCurrency": {
        "type": "object",
        "properties": {
          "currency": {
            "type": "string",
            "title": "Currency",
            "description": "3-letter ISO 4217 currency code.",
            "maxLength": 3
          },
          "tiers": {
            "type": "array",
            "title": "Tiers",
            "items": {
              "$ref": "#/components/schemas/PercentageTier"
            },
            "minItems": 1
          }
        }
      },
      "PercentageTier": {
        "type": "object",
        "properties": {
          "ending_amount": {
            "type": "number",
            "format": "float",
            "title": "Ending amount",
            "minimum": 0.01,
            "maximum": 9999999999999.99,
            "description": "Ending amount for the tier. Allows up to 2 decimal places. Must be left empty if it is the final tier."
          },
          "usage_percentage": {
            "type": "string",
            "title": "Usage Percentage",
            "minimum": 0,
            "maximum": 100,
            "description": "The percentage taken of the monetary amount of usage tracked.\nThis can be up to 4 decimal places represented as a string.\n"
          }
        }
      },
      "ProrationSettings": {
        "type": "object",
        "title": "Proration Settings",
        "description": "Allows you to control how any resulting charges and credits will be calculated and prorated.",
        "properties": {
          "charge": {
            "type": "string",
            "title": "Charge",
            "description": "Determines how the amount charged is determined for this change",
            "default": "prorated_amount",
            "enum": [
              "full_amount",
              "prorated_amount",
              "none"
            ]
          },
          "credit": {
            "type": "string",
            "title": "Credit",
            "description": "Determines how the amount credited is determined for this change",
            "default": "prorated_amount",
            "enum": [
              "full_amount",
              "prorated_amount",
              "none"
            ]
          }
        }
      },
      "Settings": {
        "type": "object",
        "properties": {
          "billing_address_requirement": {
            "description": "- full:      Full Address (Street, City, State, Postal Code and Country)\n- streetzip: Street and Postal Code only\n- zip:       Postal Code only\n- none:      No Address\n",
            "readOnly": true,
            "type": "string",
            "enum": [
              "full",
              "none",
              "streetzip",
              "zip"
            ]
          },
          "accepted_currencies": {
            "type": "array",
            "items": {
              "type": "string",
              "description": "3-letter ISO 4217 currency code."
            },
            "readOnly": true
          },
          "default_currency": {
            "type": "string",
            "description": "The default 3-letter ISO 4217 currency code.",
            "readOnly": true
          }
        }
      },
      "ShippingAddress": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "title": "Shipping Address ID",
            "maxLength": 13,
            "readOnly": true
          },
          "object": {
            "type": "string",
            "title": "Object type",
            "readOnly": true
          },
          "account_id": {
            "type": "string",
            "title": "Account ID",
            "maxLength": 13,
            "readOnly": true
          },
          "nickname": {
            "type": "string",
            "maxLength": 255
          },
          "first_name": {
            "type": "string",
            "maxLength": 255
          },
          "last_name": {
            "type": "string",
            "maxLength": 255
          },
          "company": {
            "type": "string",
            "maxLength": 255
          },
          "email": {
            "type": "string",
            "maxLength": 255
          },
          "vat_number": {
            "type": "string",
            "maxLength": 20
          },
          "phone": {
            "type": "string",
            "maxLength": 30
          },
          "street1": {
            "type": "string",
            "maxLength": 255
          },
          "street2": {
            "type": "string",
            "maxLength": 255
          },
          "city": {
            "type": "string",
            "maxLength": 255
          },
          "region": {
            "type": "string",
            "maxLength": 255,
            "description": "State or province."
          },
          "postal_code": {
            "type": "string",
            "maxLength": 20,
            "description": "Zip or postal code."
          },
          "country": {
            "type": "string",
            "maxLength": 50,
            "description": "Country, 2-letter ISO 3166-1 alpha-2 code."
          },
          "geo_code": {
            "type": "string",
            "maxLength": 20,
            "description": "Code that represents a geographic entity (location or object). Only returned for Sling Vertex Integration"
          },
          "created_at": {
            "type": "string",
            "title": "Created at",
            "format": "date-time",
            "readOnly": true
          },
          "updated_at": {
            "type": "string",
            "title": "Updated at",
            "format": "date-time",
            "readOnly": true
          }
        }
      },
      "ShippingAddressCreate": {
        "type": "object",
        "properties": {
          "nickname": {
            "type": "string",
            "maxLength": 255
          },
          "first_name": {
            "type": "string",
            "maxLength": 255
          },
          "last_name": {
            "type": "string",
            "maxLength": 255
          },
          "company": {
            "type": "string",
            "maxLength": 255
          },
          "email": {
            "type": "string",
            "maxLength": 255
          },
          "vat_number": {
            "type": "string",
            "maxLength": 20
          },
          "phone": {
            "type": "string",
            "maxLength": 30
          },
          "street1": {
            "type": "string",
            "maxLength": 255
          },
          "street2": {
            "type": "string",
            "maxLength": 255
          },
          "city": {
            "type": "string",
            "maxLength": 255
          },
          "region": {
            "type": "string",
            "maxLength": 255,
            "description": "State or province."
          },
          "postal_code": {
            "type": "string",
            "maxLength": 20,
            "description": "Zip or postal code."
          },
          "geo_code": {
            "type": "string",
            "maxLength": 20,
            "description": "Code that represents a geographic entity (location or object). Only returned for Sling Vertex Integration"
          },
          "country": {
            "type": "string",
            "maxLength": 50,
            "description": "Country, 2-letter ISO 3166-1 alpha-2 code."
          }
        },
        "required": [
          "first_name",
          "last_name",
          "street1",
          "city",
          "postal_code",
          "country"
        ]
      },
      "ShippingAddressList": {
        "type": "object",
        "properties": {
          "object": {
            "type": "string",
            "title": "Object type",
            "description": "Will always be List."
          },
          "has_more": {
            "type": "boolean",
            "description": "Indicates there are more results on subsequent pages."
          },
          "next": {
            "type": "string",
            "description": "Path to subsequent page of results."
          },
          "data": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ShippingAddress"
            }
          }
        }
      },
      "ShippingMethod": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "title": "Shipping Method ID",
            "readOnly": true,
            "maxLength": 13
          },
          "object": {
            "type": "string",
            "title": "Object type",
            "readOnly": true
          },
          "code": {
            "type": "string",
            "title": "Code",
            "description": "The internal name used identify the shipping method.",
            "maxLength": 50
          },
          "name": {
            "type": "string",
            "title": "Name",
            "description": "The name of the shipping method displayed to customers.",
            "maxLength": 100
          },
          "accounting_code": {
            "type": "string",
            "title": "Accounting Code",
            "description": "Accounting code for shipping method.",
            "maxLength": 20
          },
          "tax_code": {
            "type": "string",
            "title": "Tax code",
            "description": "Used by Avalara, Vertex, and Recurlyâ€™s built-in tax feature. The tax\ncode values are specific to each tax system. If you are using Recurlyâ€™s\nbuilt-in taxes the values are:\n\n- `FR` â€“ Common Carrier FOB Destination\n- `FR022000` â€“ Common Carrier FOB Origin\n- `FR020400` â€“ Non Common Carrier FOB Destination\n- `FR020500` â€“ Non Common Carrier FOB Origin\n- `FR010100` â€“ Delivery by Company Vehicle Before Passage of Title\n- `FR010200` â€“ Delivery by Company Vehicle After Passage of Title\n- `NT` â€“ Non-Taxable\n",
            "maxLength": 50
          },
          "liability_gl_account_id": {
            "type": "string",
            "title": "General Ledger Account ID",
            "description": "The ID of a general ledger account. General ledger accounts are\nonly accessible as a part of the Recurly RevRec Standard and\nRecurly RevRec Advanced features.\n",
            "maxLength": 13
          },
          "revenue_gl_account_id": {
            "type": "string",
            "title": "General Ledger Account ID",
            "description": "The ID of a general ledger account. General ledger accounts are\nonly accessible as a part of the Recurly RevRec Standard and\nRecurly RevRec Advanced features.\n",
            "maxLength": 13
          },
          "performance_obligation_id": {
            "type": "string",
            "title": "Performance Obligation ID",
            "description": "The ID of a performance obligation. Performance obligations are\nonly accessible as a part of the Recurly RevRec Standard and\nRecurly RevRec Advanced features.\n",
            "maxLength": 13
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "title": "Created at",
            "readOnly": true
          },
          "updated_at": {
            "type": "string",
            "format": "date-time",
            "title": "Last updated at",
            "readOnly": true
          },
          "deleted_at": {
            "type": "string",
            "format": "date-time",
            "title": "Deleted at",
            "readOnly": true
          }
        }
      },
      "ShippingMethodMini": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "title": "Shipping Method ID",
            "readOnly": true,
            "maxLength": 13
          },
          "object": {
            "type": "string",
            "title": "Object type",
            "readOnly": true
          },
          "code": {
            "type": "string",
            "title": "Code",
            "description": "The internal name used identify the shipping method.",
            "maxLength": 50
          },
          "name": {
            "type": "string",
            "title": "Name",
            "description": "The name of the shipping method displayed to customers.",
            "maxLength": 100
          }
        }
      },
      "ShippingMethodCreate": {
        "type": "object",
        "properties": {
          "code": {
            "type": "string",
            "title": "Code",
            "description": "The internal name used identify the shipping method.",
            "pattern": "/^[a-z0-9_+-]+$/i",
            "maxLength": 50
          },
          "name": {
            "type": "string",
            "title": "Name",
            "description": "The name of the shipping method displayed to customers.",
            "maxLength": 100
          },
          "accounting_code": {
            "type": "string",
            "title": "Accounting Code",
            "description": "Accounting code for shipping method.",
            "maxLength": 20
          },
          "tax_code": {
            "type": "string",
            "title": "Tax code",
            "description": "Used by Avalara, Vertex, and Recurlyâ€™s built-in tax feature. The tax\ncode values are specific to each tax system. If you are using Recurlyâ€™s\nbuilt-in taxes the values are:\n\n- `FR` â€“ Common Carrier FOB Destination\n- `FR022000` â€“ Common Carrier FOB Origin\n- `FR020400` â€“ Non Common Carrier FOB Destination\n- `FR020500` â€“ Non Common Carrier FOB Origin\n- `FR010100` â€“ Delivery by Company Vehicle Before Passage of Title\n- `FR010200` â€“ Delivery by Company Vehicle After Passage of Title\n- `NT` â€“ Non-Taxable\n",
            "maxLength": 50
          },
          "liability_gl_account_id": {
            "type": "string",
            "title": "General Ledger Account ID",
            "description": "The ID of a general ledger account. General ledger accounts are\nonly accessible as a part of the Recurly RevRec Standard and\nRecurly RevRec Advanced features.\n",
            "maxLength": 13
          },
          "revenue_gl_account_id": {
            "type": "string",
            "title": "General Ledger Account ID",
            "description": "The ID of a general ledger account. General ledger accounts are\nonly accessible as a part of the Recurly RevRec Standard and\nRecurly RevRec Advanced features.\n",
            "maxLength": 13
          },
          "performance_obligation_id": {
            "type": "string",
            "title": "Performance Obligation ID",
            "description": "The ID of a performance obligation. Performance obligations are\nonly accessible as a part of the Recurly RevRec Standard and\nRecurly RevRec Advanced features.\n",
            "maxLength": 13
          }
        },
        "required": [
          "code",
          "name"
        ]
      },
      "ShippingMethodUpdate": {
        "type": "object",
        "properties": {
          "code": {
            "type": "string",
            "title": "Code",
            "description": "The internal name used identify the shipping method.",
            "pattern": "/^[a-z0-9_+-]+$/i",
            "maxLength": 50
          },
          "name": {
            "type": "string",
            "title": "Name",
            "description": "The name of the shipping method displayed to customers.",
            "maxLength": 100
          },
          "accounting_code": {
            "type": "string",
            "title": "Accounting Code",
            "description": "Accounting code for shipping method.",
            "maxLength": 20
          },
          "tax_code": {
            "type": "string",
            "title": "Tax code",
            "description": "Used by Avalara, Vertex, and Recurlyâ€™s built-in tax feature. The tax\ncode values are specific to each tax system. If you are using Recurlyâ€™s\nbuilt-in taxes the values are:\n\n- `FR` â€“ Common Carrier FOB Destination\n- `FR022000` â€“ Common Carrier FOB Origin\n- `FR020400` â€“ Non Common Carrier FOB Destination\n- `FR020500` â€“ Non Common Carrier FOB Origin\n- `FR010100` â€“ Delivery by Company Vehicle Before Passage of Title\n- `FR010200` â€“ Delivery by Company Vehicle After Passage of Title\n- `NT` â€“ Non-Taxable\n",
            "maxLength": 50
          },
          "liability_gl_account_id": {
            "type": "string",
            "title": "General Ledger Account ID",
            "description": "The ID of a general ledger account. General ledger accounts are\nonly accessible as a part of the Recurly RevRec Standard and\nRecurly RevRec Advanced features.\n",
            "maxLength": 13
          },
          "revenue_gl_account_id": {
            "type": "string",
            "title": "General Ledger Account ID",
            "description": "The ID of a general ledger account. General ledger accounts are\nonly accessible as a part of the Recurly RevRec Standard and\nRecurly RevRec Advanced features.\n",
            "maxLength": 13
          },
          "performance_obligation_id": {
            "type": "string",
            "title": "Performance Obligation ID",
            "description": "The ID of a performance obligation. Performance obligations are\nonly accessible as a part of the Recurly RevRec Standard and\nRecurly RevRec Advanced features.\n",
            "maxLength": 13
          }
        }
      },
      "ShippingFeeCreate": {
        "type": "object",
        "properties": {
          "method_id": {
            "type": "string",
            "title": "Method ID",
            "description": "The id of the shipping method used to deliver the purchase. If `method_id` and `method_code` are both present, `method_id` will be used.",
            "maxLength": 13
          },
          "method_code": {
            "type": "string",
            "title": "Method Code",
            "description": "The code of the shipping method used to deliver the purchase. If `method_id` and `method_code` are both present, `method_id` will be used.",
            "maxLength": 50
          },
          "amount": {
            "type": "number",
            "format": "float",
            "title": "Amount",
            "description": "This is priced in the purchase's currency.",
            "minimum": 0
          }
        }
      },
      "ShippingAddressUpdate": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "title": "Shipping Address ID",
            "maxLength": 13,
            "readOnly": true
          },
          "nickname": {
            "type": "string",
            "maxLength": 255
          },
          "first_name": {
            "type": "string",
            "maxLength": 255
          },
          "last_name": {
            "type": "string",
            "maxLength": 255
          },
          "company": {
            "type": "string",
            "maxLength": 255
          },
          "email": {
            "type": "string",
            "maxLength": 255
          },
          "vat_number": {
            "type": "string",
            "maxLength": 20
          },
          "phone": {
            "type": "string",
            "maxLength": 30
          },
          "street1": {
            "type": "string",
            "maxLength": 255
          },
          "street2": {
            "type": "string",
            "maxLength": 255
          },
          "city": {
            "type": "string",
            "maxLength": 255
          },
          "region": {
            "type": "string",
            "maxLength": 255,
            "description": "State or province."
          },
          "postal_code": {
            "type": "string",
            "maxLength": 20,
            "description": "Zip or postal code."
          },
          "country": {
            "type": "string",
            "maxLength": 50,
            "description": "Country, 2-letter ISO 3166-1 alpha-2 code."
          },
          "geo_code": {
            "type": "string",
            "maxLength": 20,
            "description": "Code that represents a geographic entity (location or object). Only returned for Sling Vertex Integration"
          }
        }
      },
      "Site": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "title": "Site ID",
            "readOnly": true,
            "maxLength": 13
          },
          "object": {
            "type": "string",
            "title": "Object type",
            "readOnly": true
          },
          "subdomain": {
            "type": "string",
            "readOnly": true,
            "maxLength": 100
          },
          "public_api_key": {
            "type": "string",
            "title": "Public API Key",
            "readOnly": true,
            "maxLength": 50,
            "description": "This value is used to configure RecurlyJS to submit tokenized billing information."
          },
          "mode": {
            "title": "Mode",
            "maxLength": 15,
            "readOnly": true,
            "type": "string",
            "enum": [
              "development",
              "production",
              "sandbox"
            ]
          },
          "address": {
            "$ref": "#/components/schemas/Address"
          },
          "settings": {
            "$ref": "#/components/schemas/Settings"
          },
          "features": {
            "type": "array",
            "title": "Features",
            "description": "A list of features enabled for the site.",
            "items": {
              "readOnly": true,
              "type": "string",
              "enum": [
                "credit_memos",
                "manual_invoicing",
                "only_bill_what_changed",
                "subscription_terms"
              ]
            }
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "title": "Created at",
            "readOnly": true
          },
          "updated_at": {
            "type": "string",
            "format": "date-time",
            "title": "Updated at",
            "readOnly": true
          },
          "deleted_at": {
            "type": "string",
            "format": "date-time",
            "title": "Deleted at",
            "readOnly": true
          }
        }
      },
      "Subscription": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "title": "Subscription ID",
            "maxLength": 13
          },
          "object": {
            "type": "string",
            "title": "Object type"
          },
          "uuid": {
            "type": "string",
            "title": "UUID",
            "description": "The UUID is useful for matching data with the CSV exports and building URLs into Recurly's UI.",
            "maxLength": 32
          },
          "account": {
            "$ref": "#/components/schemas/AccountMini"
          },
          "plan": {
            "$ref": "#/components/schemas/PlanMini"
          },
          "state": {
            "title": "State",
            "type": "string",
            "enum": [
              "active",
              "canceled",
              "expired",
              "failed",
              "future",
              "paused"
            ]
          },
          "shipping": {
            "$ref": "#/components/schemas/SubscriptionShipping"
          },
          "coupon_redemptions": {
            "type": "array",
            "title": "Coupon redemptions",
            "description": "Returns subscription level coupon redemptions that are tied to this subscription.",
            "items": {
              "$ref": "#/components/schemas/CouponRedemptionMini"
            }
          },
          "pending_change": {
            "$ref": "#/components/schemas/SubscriptionChange"
          },
          "current_period_started_at": {
            "type": "string",
            "format": "date-time",
            "title": "Current billing period started at"
          },
          "current_period_ends_at": {
            "type": "string",
            "format": "date-time",
            "title": "Current billing period ends at"
          },
          "current_term_started_at": {
            "type": "string",
            "format": "date-time",
            "title": "Current term started at",
            "description": "The start date of the term when the first billing period starts. The subscription term is the length of time that a customer will be committed to a subscription. A term can span multiple billing periods."
          },
          "current_term_ends_at": {
            "type": "string",
            "format": "date-time",
            "title": "Current term ends at",
            "description": "When the term ends. This is calculated by a plan's interval and `total_billing_cycles` in a term. Subscription changes with a `timeframe=renewal` will be applied on this date."
          },
          "trial_started_at": {
            "type": "string",
            "format": "date-time",
            "title": "Trial period started at"
          },
          "trial_ends_at": {
            "type": "string",
            "format": "date-time",
            "title": "Trial period ends at"
          },
          "remaining_billing_cycles": {
            "type": "integer",
            "title": "Remaining billing cycles",
            "description": "The remaining billing cycles in the current term."
          },
          "total_billing_cycles": {
            "type": "integer",
            "title": "Total billing cycles",
            "description": "The number of cycles/billing periods in a term. When `remaining_billing_cycles=0`, if `auto_renew=true` the subscription will renew and a new term will begin, otherwise the subscription will expire."
          },
          "renewal_billing_cycles": {
            "type": "integer",
            "title": "Renewal billing cycles",
            "description": "If `auto_renew=true`, when a term completes, `total_billing_cycles` takes this value as the length of subsequent terms. Defaults to the plan's `total_billing_cycles`."
          },
          "auto_renew": {
            "type": "boolean",
            "default": true,
            "title": "Auto renew",
            "description": "Whether the subscription renews at the end of its term."
          },
          "ramp_intervals": {
            "type": "array",
            "title": "Ramp Intervals",
            "description": "The ramp intervals representing the pricing schedule for the subscription.",
            "items": {
              "$ref": "#/components/schemas/SubscriptionRampIntervalResponse"
            }
          },
          "paused_at": {
            "type": "string",
            "format": "date-time",
            "title": "Paused at",
            "description": "Null unless subscription is paused or will pause at the end of the current billing period."
          },
          "remaining_pause_cycles": {
            "type": "integer",
            "title": "Remaining pause cycles",
            "description": "Null unless subscription is paused or will pause at the end of the current billing period."
          },
          "currency": {
            "type": "string",
            "title": "Currency",
            "description": "3-letter ISO 4217 currency code.",
            "maxLength": 3
          },
          "revenue_schedule_type": {
            "title": "Revenue schedule type",
            "type": "string",
            "enum": [
              "at_range_end",
              "at_range_start",
              "evenly",
              "never"
            ]
          },
          "unit_amount": {
            "type": "number",
            "format": "float",
            "title": "Subscription unit price"
          },
          "tax_inclusive": {
            "type": "boolean",
            "title": "Tax Inclusive?",
            "description": "Determines whether or not tax is included in the unit amount. The Tax Inclusive Pricing feature (separate from the Mixed Tax Pricing feature) must be enabled to utilize this flag."
          },
          "quantity": {
            "type": "integer",
            "title": "Subscription quantity",
            "minimum": 0
          },
          "add_ons": {
            "type": "array",
            "title": "Add-ons",
            "items": {
              "$ref": "#/components/schemas/SubscriptionAddOn"
            }
          },
          "add_ons_total": {
            "type": "number",
            "format": "float",
            "title": "Total price of add-ons",
            "minimum": 0
          },
          "subtotal": {
            "type": "number",
            "format": "float",
            "title": "Estimated total, before tax.",
            "minimum": 0
          },
          "tax": {
            "type": "number",
            "format": "float",
            "title": "Estimated tax",
            "description": "Only for merchants using Recurly's In-The-Box taxes."
          },
          "tax_info": {
            "$ref": "#/components/schemas/TaxInfo"
          },
          "total": {
            "type": "number",
            "format": "float",
            "title": "Estimated total"
          },
          "collection_method": {
            "title": "Collection method",
            "default": "automatic",
            "type": "string",
            "enum": [
              "automatic",
              "manual"
            ]
          },
          "po_number": {
            "type": "string",
            "title": "Purchase order number",
            "description": "For manual invoicing, this identifies the PO number associated with the subscription.",
            "maxLength": 50
          },
          "net_terms": {
            "type": "integer",
            "title": "Net terms",
            "description": "Integer paired with `Net Terms Type` and representing the number\nof days past the current date (for `net` Net Terms Type) or days after\nthe last day of the current month (for `eom` Net Terms Type) that the\ninvoice will become past due. For `manual` collection method, an additional 24 hours is\nadded to ensure the customer has the entire last day to make payment before\nbecoming past due. For example:\n\nIf an invoice is due `net 0`, it is due 'On Receipt' and will become past due 24 hours after it's created.\nIf an invoice is due `net 30`, it will become past due at 31 days exactly.\nIf an invoice is due `eom 30`, it will become past due 31 days from the last day of the current month.\n\nFor `automatic` collection method, the additional 24 hours is not added. For example, On-Receipt is due immediately, and `net 30` will become due exactly 30 days from invoice generation, at which point Recurly will attempt collection.\nWhen `eom` Net Terms Type is passed, the value for `Net Terms` is restricted to `0, 15, 30, 45, 60, or 90`.\n\nFor more information on how net terms work with `manual` collection visit our docs page (https://docs.recurly.com/docs/manual-payments#section-collection-terms)\nor visit (https://docs.recurly.com/docs/automatic-invoicing-terms#section-collection-terms) for information about net terms using `automatic` collection.",
            "minimum": 0,
            "default": 0
          },
          "net_terms_type": {
            "type": "string",
            "title": "Net Terms Type",
            "description": "Optionally supplied string that may be either `net` or `eom` (end-of-month).\nWhen `net`, an invoice becomes past due the specified number of `Net Terms` days from the current date.\nWhen `eom` an invoice becomes past due the specified number of `Net Terms` days from the last day of the current month.\n",
            "enum": [
              "net",
              "eom"
            ],
            "default": "net"
          },
          "terms_and_conditions": {
            "type": "string",
            "title": "Terms and conditions"
          },
          "customer_notes": {
            "type": "string",
            "title": "Customer notes"
          },
          "expiration_reason": {
            "type": "string",
            "title": "Expiration reason"
          },
          "custom_fields": {
            "$ref": "#/components/schemas/CustomFields"
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "title": "Created at"
          },
          "updated_at": {
            "type": "string",
            "format": "date-time",
            "title": "Last updated at"
          },
          "activated_at": {
            "type": "string",
            "format": "date-time",
            "title": "Activated at"
          },
          "canceled_at": {
            "type": "string",
            "format": "date-time",
            "title": "Canceled at"
          },
          "expires_at": {
            "type": "string",
            "format": "date-time",
            "title": "Expires at"
          },
          "bank_account_authorized_at": {
            "type": "string",
            "format": "date-time",
            "title": "Bank account authorized",
            "description": "Recurring subscriptions paid with ACH will have this attribute set. This timestamp is used for alerting customers to reauthorize in 3 years in accordance with NACHA rules. If a subscription becomes inactive or the billing info is no longer a bank account, this timestamp is cleared."
          },
          "gateway_code": {
            "type": "string",
            "title": "Gateway Code",
            "description": "If present, this subscription's transactions will use the payment gateway with this code.",
            "maxLength": 13
          },
          "billing_info_id": {
            "type": "string",
            "title": "Billing Info ID",
            "description": "Billing Info ID."
          },
          "active_invoice_id": {
            "type": "string",
            "title": "Active invoice ID",
            "description": "The invoice ID of the latest invoice created for an active subscription.",
            "maxLength": 13,
            "readOnly": true
          },
          "started_with_gift": {
            "type": "boolean",
            "default": false,
            "description": "Whether the subscription was started with a gift certificate.",
            "title": "Started with Gift"
          },
          "converted_at": {
            "type": "string",
            "format": "date-time",
            "description": "When the subscription was converted from a gift card.",
            "title": "Converted at"
          },
          "action_result": {
            "type": "object",
            "description": "Action result params to be used in Recurly-JS to complete a payment when using asynchronous payment methods, e.g., Boleto, iDEAL and Sofort.",
            "title": "Action result"
          }
        }
      },
      "SubscriptionAddOn": {
        "type": "object",
        "title": "Subscription Add-on",
        "description": "This links an Add-on to a specific Subscription.",
        "properties": {
          "id": {
            "type": "string",
            "title": "Subscription Add-on ID",
            "maxLength": 13
          },
          "object": {
            "type": "string",
            "title": "Object type"
          },
          "subscription_id": {
            "type": "string",
            "title": "Subscription ID",
            "maxLength": 13
          },
          "add_on": {
            "$ref": "#/components/schemas/AddOnMini"
          },
          "add_on_source": {
            "type": "string",
            "title": "Add-on source",
            "description": "Used to determine where the associated add-on data is pulled from. If this value is set to\n`plan_add_on` or left blank, then add-on data will be pulled from the plan's add-ons. If the associated\n`plan` has `allow_any_item_on_subscriptions` set to `true` and this field is set to `item`, then\nthe associated add-on data will be pulled from the site's item catalog.\n",
            "default": "plan_add_on",
            "enum": [
              "plan_add_on",
              "item"
            ]
          },
          "quantity": {
            "type": "integer",
            "title": "Add-on quantity",
            "minimum": 0
          },
          "unit_amount": {
            "type": "number",
            "format": "float",
            "title": "Add-on unit price",
            "description": "Supports up to 2 decimal places."
          },
          "unit_amount_decimal": {
            "type": "string",
            "format": "decimal",
            "title": "Add-on unit in decimal price",
            "description": "Supports up to 9 decimal places."
          },
          "revenue_schedule_type": {
            "title": "Revenue schedule type",
            "type": "string",
            "enum": [
              "at_range_end",
              "at_range_start",
              "evenly",
              "never"
            ]
          },
          "tier_type": {
            "type": "string",
            "title": "Tier type",
            "description": "The pricing model for the add-on.  For more information,\n[click here](https://docs.recurly.com/docs/billing-models#section-quantity-based). See our\n[Guide](https://recurly.com/developers/guides/item-addon-guide.html) for an overview of how\nto configure quantity-based pricing models.\n",
            "default": "flat",
            "enum": [
              "flat",
              "tiered",
              "stairstep",
              "volume"
            ]
          },
          "usage_calculation_type": {
            "type": "string",
            "description": "The type of calculation to be employed for an add-on.  Cumulative billing will sum all usage records created in the current billing cycle.  Last-in-period billing will apply only the most recent usage record in the billing period.  If no value is specified, cumulative billing will be used.",
            "enum": [
              "cumulative",
              "last_in_period"
            ]
          },
          "usage_timeframe": {
            "type": "string",
            "title": "Usage Timeframe",
            "description": "The time at which usage totals are reset for billing purposes.",
            "enum": [
              "billing_period",
              "subscription_term"
            ],
            "default": "billing_period"
          },
          "tiers": {
            "type": "array",
            "title": "Tiers",
            "items": {
              "$ref": "#/components/schemas/SubscriptionAddOnTier"
            },
            "minItems": 1,
            "description": "If tiers are provided in the request, all existing tiers on the Subscription Add-on will be\nremoved and replaced by the tiers in the request. If add_on.tier_type is tiered or volume and\nadd_on.usage_type is percentage use percentage_tiers instead. \nThere must be one tier without an `ending_quantity` value which represents the final tier.\n"
          },
          "percentage_tiers": {
            "type": "array",
            "title": "Percentage Tiers",
            "items": {
              "$ref": "#/components/schemas/SubscriptionAddOnPercentageTier"
            },
            "minItems": 1,
            "description": "If percentage tiers are provided in the request, all existing percentage tiers on the Subscription Add-on will be\nremoved and replaced by the percentage tiers in the request. Use only if add_on.tier_type is tiered or volume and\nadd_on.usage_type is percentage. There must be one tier without an `ending_amount` value which represents the final tier.\nThis feature is currently in development and requires approval and enablement, please contact support.\n"
          },
          "usage_percentage": {
            "type": "number",
            "format": "float",
            "title": "Usage Percentage",
            "description": "The percentage taken of the monetary amount of usage tracked. This can be up to 4 decimal places. A value between 0.0 and 100.0. Required if add_on_type is usage and usage_type is percentage."
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "title": "Created at"
          },
          "updated_at": {
            "type": "string",
            "format": "date-time",
            "title": "Updated at"
          },
          "expired_at": {
            "type": "string",
            "format": "date-time",
            "title": "Expired at"
          }
        }
      },
      "SubscriptionAddOnCreate": {
        "type": "object",
        "properties": {
          "code": {
            "type": "string",
            "title": "Add-on code",
            "maxLength": 50,
            "description": "If `add_on_source` is set to `plan_add_on` or left blank, then plan's add-on `code` should be used.\nIf `add_on_source` is set to `item`, then the `code` from the associated item should be used.\n"
          },
          "add_on_source": {
            "type": "string",
            "title": "Add-on source",
            "description": "Used to determine where the associated add-on data is pulled from. If this value is set to\n`plan_add_on` or left blank, then add-on data will be pulled from the plan's add-ons. If the associated\n`plan` has `allow_any_item_on_subscriptions` set to `true` and this field is set to `item`, then\nthe associated add-on data will be pulled from the site's item catalog.\n",
            "default": "plan_add_on",
            "enum": [
              "plan_add_on",
              "item"
            ]
          },
          "quantity": {
            "type": "integer",
            "title": "Quantity",
            "minimum": 0,
            "default": 1
          },
          "unit_amount": {
            "type": "number",
            "format": "float",
            "title": "Unit amount",
            "description": "Allows up to 2 decimal places. Optionally, override the add-on's default unit amount.\nIf the plan add-on's `tier_type` is `tiered`, `volume`, or `stairstep`, then `unit_amount` cannot be provided.\n",
            "minimum": 0,
            "maximum": 1000000
          },
          "unit_amount_decimal": {
            "type": "string",
            "format": "decimal",
            "title": "Unit Amount Decimal",
            "description": "Allows up to 9 decimal places.  Optionally, override the add-on's default unit amount.\nIf the plan add-on's `tier_type` is `tiered`, `volume`, or `stairstep`, then `unit_amount_decimal` cannot be provided.\nOnly supported when the plan add-on's `add_on_type` = `usage`.\nIf `unit_amount_decimal` is provided, `unit_amount` cannot be provided.\n",
            "minimum": 0,
            "maximum": 1000000
          },
          "tiers": {
            "type": "array",
            "title": "Tiers",
            "items": {
              "$ref": "#/components/schemas/SubscriptionAddOnTier"
            },
            "minItems": 1,
            "description": "If the plan add-on's `tier_type` is `flat`, then `tiers` must be absent. The `tiers` object\nmust include one to many tiers with `ending_quantity` and `unit_amount`.\nThere must be one tier without an `ending_quantity` value which represents the final tier.\nSee our [Guide](https://recurly.com/developers/guides/item-addon-guide.html)\nfor an overview of how to configure quantity-based pricing models.\n"
          },
          "percentage_tiers": {
            "type": "array",
            "title": "Percentage Tiers",
            "items": {
              "$ref": "#/components/schemas/SubscriptionAddOnPercentageTier"
            },
            "minItems": 1,
            "description": "If percentage tiers are provided in the request, all existing percentage tiers on the Subscription Add-on will be\nremoved and replaced by the percentage tiers in the request. There must be one tier without ending_amount value\nwhich represents the final tier. Use only if add_on.tier_type is tiered or volume and add_on.usage_type is\npercentage. This feature is currently in development and requires approval and enablement, please contact support.\n"
          },
          "usage_percentage": {
            "type": "number",
            "format": "float",
            "title": "Usage Percentage",
            "minimum": 0,
            "maximum": 100,
            "description": "The percentage taken of the monetary amount of usage tracked. This can be up to 4 decimal places. A value between 0.0 and 100.0. Required if `add_on_type` is usage and `usage_type` is percentage. Must be omitted otherwise. `usage_percentage` does not support tiers. See our [Guide](https://recurly.com/developers/guides/usage-based-billing-guide.html) for an overview of how to configure usage add-ons."
          },
          "revenue_schedule_type": {
            "title": "Revenue schedule type",
            "type": "string",
            "enum": [
              "at_range_end",
              "at_range_start",
              "evenly",
              "never"
            ]
          }
        },
        "required": [
          "code"
        ]
      },
      "SubscriptionAddOnUpdate": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "title": "Subscription Add-on ID.",
            "description": "When an id is provided, the existing subscription add-on attributes will\npersist unless overridden in the request.\n",
            "maxLength": 13
          },
          "code": {
            "type": "string",
            "title": "Add-on code",
            "maxLength": 50,
            "description": "If a code is provided without an id, the subscription add-on attributes\nwill be set to the current value for those attributes on the plan add-on\nunless provided in the request. If `add_on_source` is set to `plan_add_on`\nor left blank, then plan's add-on `code` should be used. If `add_on_source`\nis set to `item`, then the `code` from the associated item should be used.\n"
          },
          "add_on_source": {
            "type": "string",
            "title": "Add-on source",
            "description": "Used to determine where the associated add-on data is pulled from. If this value is set to\n`plan_add_on` or left blank, then add-on data will be pulled from the plan's add-ons. If the associated\n`plan` has `allow_any_item_on_subscriptions` set to `true` and this field is set to `item`, then\nthe associated add-on data will be pulled from the site's item catalog.\n",
            "default": "plan_add_on",
            "enum": [
              "plan_add_on",
              "item"
            ]
          },
          "quantity": {
            "type": "integer",
            "title": "Quantity",
            "minimum": 0
          },
          "unit_amount": {
            "type": "number",
            "format": "float",
            "title": "Unit amount",
            "description": "Allows up to 2 decimal places. Optionally, override the add-on's default unit amount.\nIf the plan add-on's `tier_type` is `tiered`, `volume`, or `stairstep`, then `unit_amount` cannot be provided.\n",
            "minimum": 0,
            "maximum": 1000000
          },
          "unit_amount_decimal": {
            "type": "string",
            "title": "Unit amount decimal",
            "description": "Allows up to 9 decimal places. Optionally, override the add-on's default unit amount.\nIf the plan add-on's `tier_type` is `tiered`, `volume`, or `stairstep`, then `unit_amount_decimal` cannot be provided.\nOnly supported when the plan add-on's `add_on_type` = `usage`.\nIf `unit_amount_decimal` is provided, `unit_amount` cannot be provided.\n"
          },
          "tiers": {
            "type": "array",
            "title": "Tiers",
            "items": {
              "$ref": "#/components/schemas/SubscriptionAddOnTier"
            },
            "minItems": 1,
            "description": "If the plan add-on's `tier_type` is `flat`, then `tiers` must be absent. The `tiers` object\nmust include one to many tiers with `ending_quantity` and `unit_amount`.\nThere must be one tier without an `ending_quantity` value which represents the final tier.\n"
          },
          "percentage_tiers": {
            "type": "array",
            "title": "Percentage Tiers",
            "items": {
              "$ref": "#/components/schemas/SubscriptionAddOnPercentageTier"
            },
            "minItems": 1,
            "description": "If percentage tiers are provided in the request, all existing percentage tiers on the Subscription Add-on will be\nremoved and replaced by the percentage tiers in the request. Use only if add_on.tier_type is tiered or volume and\nadd_on.usage_type is percentage. There must be one tier without an `ending_amount` value which represents the\nfinal tier. This feature is currently in development and requires approval and enablement, please contact support.\n"
          },
          "usage_percentage": {
            "type": "number",
            "format": "float",
            "title": "Usage Percentage",
            "description": "The percentage taken of the monetary amount of usage tracked. This can be up to 4 decimal places. A value between 0.0 and 100.0. Required if add_on_type is usage and usage_type is percentage."
          },
          "revenue_schedule_type": {
            "title": "Revenue schedule type",
            "type": "string",
            "enum": [
              "at_range_end",
              "at_range_start",
              "evenly",
              "never"
            ]
          }
        }
      },
      "SubscriptionAddOnTier": {
        "type": "object",
        "properties": {
          "ending_quantity": {
            "type": "integer",
            "title": "Ending quantity",
            "minimum": 1,
            "maximum": 999999999,
            "description": "Ending quantity for the tier.  This represents a unit amount for unit-priced add ons. Must be left empty if it is the final tier."
          },
          "unit_amount": {
            "type": "number",
            "format": "float",
            "title": "Unit amount",
            "minimum": 0,
            "maximum": 1000000,
            "description": "Allows up to 2 decimal places. Optionally, override the tiers' default unit amount. If add-on's `add_on_type` is `usage` and `usage_type` is `percentage`, cannot be provided."
          },
          "unit_amount_decimal": {
            "type": "string",
            "title": "Unit amount decimal",
            "description": "Allows up to 9 decimal places.  Optionally, override tiers' default unit amount.\nIf `unit_amount_decimal` is provided, `unit_amount` cannot be provided.\nIf add-on's `add_on_type` is `usage` and `usage_type` is `percentage`, cannot be provided.\n"
          },
          "usage_percentage": {
            "type": "string",
            "title": "Usage Percentage",
            "description": "(deprecated) -- Use the percentage_tiers object instead.",
            "deprecated": true
          }
        }
      },
      "SubscriptionAddOnPercentageTier": {
        "type": "object",
        "properties": {
          "ending_amount": {
            "type": "number",
            "format": "float",
            "title": "Ending amount",
            "minimum": 1,
            "maximum": 9999999999999.99,
            "description": "Ending amount for the tier. Allows up to 2 decimal places. Must be left empty if it is the final tier."
          },
          "usage_percentage": {
            "type": "string",
            "title": "Usage Percentage",
            "minimum": 0,
            "maximum": 100,
            "description": "The percentage taken of the monetary amount of usage tracked.\nThis can be up to 4 decimal places represented as a string.\n"
          }
        }
      },
      "SubscriptionCancel": {
        "type": "object",
        "properties": {
          "timeframe": {
            "title": "Timeframe",
            "description": "The timeframe parameter controls when the expiration takes place. The `bill_date` timeframe causes the subscription to expire when the subscription is scheduled to bill next. The `term_end` timeframe causes the subscription to continue to bill until the end of the subscription term, then expire.",
            "default": "term_end",
            "type": "string",
            "enum": [
              "bill_date",
              "term_end"
            ]
          }
        }
      },
      "SubscriptionChange": {
        "type": "object",
        "title": "Subscription Change",
        "properties": {
          "id": {
            "type": "string",
            "title": "Subscription Change ID",
            "description": "The ID of the Subscription Change."
          },
          "object": {
            "type": "string",
            "title": "Object type"
          },
          "subscription_id": {
            "type": "string",
            "title": "Subscription ID",
            "description": "The ID of the subscription that is going to be changed.",
            "maxLength": 13
          },
          "plan": {
            "$ref": "#/components/schemas/PlanMini"
          },
          "add_ons": {
            "type": "array",
            "title": "Add-ons",
            "description": "These add-ons will be used when the subscription renews.",
            "items": {
              "$ref": "#/components/schemas/SubscriptionAddOn"
            }
          },
          "unit_amount": {
            "type": "number",
            "format": "float",
            "title": "Unit amount"
          },
          "tax_inclusive": {
            "type": "boolean",
            "title": "Tax Inclusive?",
            "default": false,
            "description": "This field is deprecated. Please do not use it.",
            "deprecated": true
          },
          "quantity": {
            "type": "integer",
            "title": "Subscription quantity"
          },
          "shipping": {
            "$ref": "#/components/schemas/SubscriptionShipping"
          },
          "activate_at": {
            "type": "string",
            "format": "date-time",
            "title": "Activated at",
            "readOnly": true
          },
          "activated": {
            "type": "boolean",
            "title": "Activated?",
            "description": "Returns `true` if the subscription change is activated."
          },
          "revenue_schedule_type": {
            "title": "Revenue schedule type",
            "type": "string",
            "enum": [
              "at_range_end",
              "at_range_start",
              "evenly",
              "never"
            ]
          },
          "invoice_collection": {
            "title": "Invoice Collection",
            "$ref": "#/components/schemas/InvoiceCollection"
          },
          "custom_fields": {
            "$ref": "#/components/schemas/CustomFields"
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "title": "Created at",
            "readOnly": true
          },
          "updated_at": {
            "type": "string",
            "format": "date-time",
            "title": "Updated at",
            "readOnly": true
          },
          "deleted_at": {
            "type": "string",
            "format": "date-time",
            "title": "Deleted at",
            "readOnly": true
          },
          "billing_info": {
            "$ref": "#/components/schemas/SubscriptionChangeBillingInfo"
          },
          "ramp_intervals": {
            "type": "array",
            "title": "Ramp Intervals",
            "description": "The ramp intervals representing the pricing schedule for the subscription.",
            "items": {
              "$ref": "#/components/schemas/SubscriptionRampIntervalResponse"
            }
          }
        }
      },
      "SubscriptionChangeBillingInfo": {
        "type": "object",
        "description": "Accept nested attributes for three_d_secure_action_result_token_id",
        "properties": {
          "three_d_secure_action_result_token_id": {
            "type": "string",
            "title": "3-D Secure action result token ID",
            "description": "A token generated by Recurly.js after completing a 3-D Secure device fingerprinting or authentication challenge.",
            "maxLength": 22
          }
        }
      },
      "SubscriptionChangeBillingInfoCreate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/SubscriptionChangeBillingInfo"
          }
        ]
      },
      "SubscriptionChangeCreate": {
        "type": "object",
        "properties": {
          "timeframe": {
            "title": "Timeframe",
            "description": "The timeframe parameter controls when the upgrade or downgrade takes place. The subscription change can occur now, when the subscription is next billed, or when the subscription term ends. Generally, if you're performing an upgrade, you will want the change to occur immediately (now). If you're performing a downgrade, you should set the timeframe to `term_end` or `bill_date` so the change takes effect at a scheduled billing date. The `renewal` timeframe option is accepted as an alias for `term_end`.",
            "default": "now",
            "type": "string",
            "enum": [
              "bill_date",
              "now",
              "renewal",
              "term_end"
            ]
          },
          "plan_id": {
            "type": "string",
            "title": "Plan ID",
            "maxLength": 13,
            "description": "If you want to change to a new plan, you can provide the plan's code or id. If both are provided the `plan_id` will be used."
          },
          "plan_code": {
            "type": "string",
            "title": "New plan code",
            "maxLength": 50,
            "description": "If you want to change to a new plan, you can provide the plan's code or id. If both are provided the `plan_id` will be used."
          },
          "unit_amount": {
            "type": "number",
            "format": "float",
            "title": "Custom subscription price",
            "description": "Optionally, sets custom pricing for the subscription, overriding the plan's default unit amount. The subscription's current currency will be used.",
            "minimum": 0,
            "maximum": 1000000
          },
          "tax_inclusive": {
            "type": "boolean",
            "title": "Tax Inclusive?",
            "default": false,
            "description": "This field is deprecated. Please do not use it.",
            "deprecated": true
          },
          "quantity": {
            "type": "integer",
            "title": "Quantity",
            "description": "Optionally override the default quantity of 1.",
            "default": 1,
            "minimum": 0
          },
          "shipping": {
            "$ref": "#/components/schemas/SubscriptionChangeShippingCreate"
          },
          "coupon_codes": {
            "type": "array",
            "title": "Coupon codes",
            "description": "A list of coupon_codes to be redeemed on the subscription during the change. Only allowed if timeframe is now and you change something about the subscription that creates an invoice.",
            "items": {
              "type": "string"
            }
          },
          "add_ons": {
            "type": "array",
            "title": "Add-ons",
            "description": "If you provide a value for this field it will replace any\nexisting add-ons. So, when adding or modifying an add-on, you need to\ninclude the existing subscription add-ons. Unchanged add-ons can be included\njust using the subscription add-on''s ID: `{\"id\": \"abc123\"}`. If this\nvalue is omitted your existing add-ons will be unaffected. To remove all\nexisting add-ons, this value should be an empty array.'\n\nIf a subscription add-on's `code` is supplied without the `id`,\n`{\"code\": \"def456\"}`, the subscription add-on attributes will be set to the\ncurrent values of the plan add-on unless provided in the request.\n\n- If an `id` is passed, any attributes not passed in will pull from the\n  existing subscription add-on\n- If a `code` is passed, any attributes not passed in will pull from the\n  current values of the plan add-on\n- Attributes passed in as part of the request will override either of the\n  above scenarios\n",
            "items": {
              "$ref": "#/components/schemas/SubscriptionAddOnUpdate"
            }
          },
          "collection_method": {
            "title": "Collection method",
            "default": "automatic",
            "type": "string",
            "enum": [
              "automatic",
              "manual"
            ]
          },
          "revenue_schedule_type": {
            "title": "Revenue schedule type",
            "type": "string",
            "enum": [
              "at_range_end",
              "at_range_start",
              "evenly",
              "never"
            ]
          },
          "custom_fields": {
            "$ref": "#/components/schemas/CustomFields"
          },
          "po_number": {
            "type": "string",
            "title": "Purchase order number",
            "description": "For manual invoicing, this identifies the PO number associated with the subscription.",
            "maxLength": 50
          },
          "net_terms": {
            "type": "integer",
            "title": "Net terms",
            "description": "Integer normally paired with `Net Terms Type` and representing the number of days past\nthe current date (for `net` Net Terms Type) or days after the last day of the current\nmonth (for `eom` Net Terms Type) that the invoice will become past due. During a subscription\nchange, it's not necessary to provide both the `Net Terms Type` and `Net Terms` parameters.\n\nFor more information on how net terms work with `manual` collection visit our docs page (https://docs.recurly.com/docs/manual-payments#section-collection-terms)\nor visit (https://docs.recurly.com/docs/automatic-invoicing-terms#section-collection-terms) for information about net terms using `automatic` collection.",
            "minimum": 0,
            "default": 0
          },
          "net_terms_type": {
            "type": "string",
            "title": "Net Terms Type",
            "description": "Optionally supplied string that may be either `net` or `eom` (end-of-month).\nWhen `net`, an invoice becomes past due the specified number of `Net Terms` days from the current date.\nWhen `eom` an invoice becomes past due the specified number of `Net Terms` days from the last day of the current month.\n",
            "enum": [
              "net",
              "eom"
            ],
            "default": "net"
          },
          "transaction_type": {
            "description": "An optional type designation for the payment gateway transaction created by this request. Supports 'moto' value, which is the acronym for mail order and telephone transactions.",
            "type": "string",
            "enum": [
              "moto"
            ]
          },
          "billing_info": {
            "$ref": "#/components/schemas/SubscriptionChangeBillingInfoCreate"
          },
          "ramp_intervals": {
            "type": "array",
            "title": "Ramp Intervals",
            "description": "The new set of ramp intervals for the subscription.",
            "items": {
              "$ref": "#/components/schemas/SubscriptionRampInterval"
            }
          },
          "proration_settings": {
            "$ref": "#/components/schemas/ProrationSettings"
          }
        }
      },
      "SubscriptionChangeShippingCreate": {
        "type": "object",
        "title": "Shipping details that will be changed on a subscription",
        "description": "Shipping addresses are tied to a customer's account. Each account can have up to 20 different shipping addresses, and if you have enabled multiple subscriptions per account, you can associate different shipping addresses to each subscription.",
        "properties": {
          "method_id": {
            "type": "string",
            "title": "Method ID",
            "description": "The id of the shipping method used to deliver the subscription. To remove shipping set this to `null` and the `amount=0`. If `method_id` and `method_code` are both present, `method_id` will be used.",
            "maxLength": 13
          },
          "method_code": {
            "type": "string",
            "title": "Method Code",
            "description": "The code of the shipping method used to deliver the subscription. To remove shipping set this to `null` and the `amount=0`. If `method_id` and `method_code` are both present, `method_id` will be used.",
            "maxLength": 50
          },
          "amount": {
            "type": "number",
            "format": "float",
            "title": "Assigns the subscription's shipping cost. If this is greater than zero then a `method_id` or `method_code` is required."
          },
          "address_id": {
            "type": "string",
            "title": "Shipping address ID",
            "description": "Assign a shipping address from the account's existing shipping addresses. If this and address are both present, address will take precedence."
          },
          "address": {
            "$ref": "#/components/schemas/ShippingAddressCreate"
          }
        }
      },
      "SubscriptionCreate": {
        "type": "object",
        "properties": {
          "plan_code": {
            "type": "string",
            "title": "Plan code",
            "maxLength": 50,
            "description": "You must provide either a `plan_code` or `plan_id`. If both are provided the `plan_id` will be used."
          },
          "plan_id": {
            "type": "string",
            "title": "Plan ID",
            "maxLength": 13,
            "description": "You must provide either a `plan_code` or `plan_id`. If both are provided the `plan_id` will be used."
          },
          "account": {
            "$ref": "#/components/schemas/AccountCreate"
          },
          "billing_info_id": {
            "type": "string",
            "title": "Billing Info ID",
            "description": "The `billing_info_id` is the value that represents a specific billing info for an end customer. When `billing_info_id` is used to assign billing info to the subscription, all future billing events for the subscription will bill to the specified billing info. `billing_info_id` can ONLY be used for sites utilizing the Wallet feature."
          },
          "shipping": {
            "title": "Shipping address",
            "description": "Create a shipping address on the account and assign it to the subscription.",
            "$ref": "#/components/schemas/SubscriptionShippingCreate"
          },
          "collection_method": {
            "title": "Collection method",
            "default": "automatic",
            "type": "string",
            "enum": [
              "automatic",
              "manual"
            ]
          },
          "currency": {
            "type": "string",
            "title": "Currency",
            "description": "3-letter ISO 4217 currency code.",
            "maxLength": 3
          },
          "unit_amount": {
            "type": "number",
            "format": "float",
            "title": "Custom subscription pricing",
            "description": "Override the unit amount of the subscription plan by setting this value. If not provided, the subscription will inherit the price from the subscription plan for the provided currency.",
            "minimum": 0,
            "maximum": 1000000
          },
          "tax_inclusive": {
            "type": "boolean",
            "title": "Tax Inclusive?",
            "default": false,
            "description": "Determines whether or not tax is included in the unit amount. The Tax Inclusive Pricing feature (separate from the Mixed Tax Pricing feature) must be enabled to use this flag."
          },
          "quantity": {
            "type": "integer",
            "title": "Quantity",
            "description": "Optionally override the default quantity of 1.",
            "default": 1,
            "minimum": 0
          },
          "add_ons": {
            "type": "array",
            "title": "Add-ons",
            "items": {
              "$ref": "#/components/schemas/SubscriptionAddOnCreate"
            }
          },
          "coupon_codes": {
            "type": "array",
            "title": "Coupon codes",
            "description": "A list of coupon_codes to be redeemed on the subscription or account during the purchase.",
            "items": {
              "type": "string"
            }
          },
          "custom_fields": {
            "$ref": "#/components/schemas/CustomFields"
          },
          "trial_ends_at": {
            "type": "string",
            "format": "date-time",
            "title": "Trial ends at",
            "description": "If set, overrides the default trial behavior for the subscription. When the current date time or a past date time is provided the subscription will begin with no trial phase (overriding any plan default trial). When a future date time is provided the subscription will begin with a trial phase ending at the specified date time."
          },
          "starts_at": {
            "type": "string",
            "format": "date-time",
            "title": "Start date",
            "description": "If set, the subscription will begin in the future on this date. The subscription will apply the setup fee and trial period, unless the plan has no trial."
          },
          "next_bill_date": {
            "type": "string",
            "format": "date-time",
            "title": "Next bill date",
            "description": "If present, this sets the date the subscription's next billing period will start (`current_period_ends_at`). This can be used to align the subscriptionâ€™s billing to a specific day of the month. The initial invoice will be prorated for the period between the subscription's activation date and the billing period end date. Subsequent periods will be based off the plan interval. For a subscription with a trial period, this will change when the trial expires."
          },
          "total_billing_cycles": {
            "type": "integer",
            "title": "Total billing cycles",
            "description": "The number of cycles/billing periods in a term. When `remaining_billing_cycles=0`, if `auto_renew=true` the subscription will renew and a new term will begin, otherwise the subscription will expire.",
            "minimum": 1
          },
          "renewal_billing_cycles": {
            "type": "integer",
            "title": "Renewal billing cycles",
            "description": "If `auto_renew=true`, when a term completes, `total_billing_cycles` takes this value as the length of subsequent terms. Defaults to the plan's `total_billing_cycles`."
          },
          "auto_renew": {
            "type": "boolean",
            "default": true,
            "title": "Auto renew",
            "description": "Whether the subscription renews at the end of its term."
          },
          "ramp_intervals": {
            "type": "array",
            "title": "Ramp Intervals",
            "description": "The new set of ramp intervals for the subscription.",
            "items": {
              "$ref": "#/components/schemas/SubscriptionRampInterval"
            }
          },
          "revenue_schedule_type": {
            "title": "Revenue schedule type",
            "type": "string",
            "enum": [
              "at_range_end",
              "at_range_start",
              "evenly",
              "never"
            ]
          },
          "terms_and_conditions": {
            "type": "string",
            "title": "Terms and conditions",
            "description": "This will default to the Terms and Conditions text specified on the Invoice Settings page in your Recurly admin. Specify custom notes to add or override Terms and Conditions. Custom notes will stay with a subscription on all renewals."
          },
          "customer_notes": {
            "type": "string",
            "title": "Customer notes",
            "description": "This will default to the Customer Notes text specified on the Invoice Settings. Specify custom notes to add or override Customer Notes. Custom notes will stay with a subscription on all renewals."
          },
          "credit_customer_notes": {
            "type": "string",
            "title": "Credit customer notes",
            "description": "If there are pending credits on the account that will be invoiced during the subscription creation, these will be used as the Customer Notes on the credit invoice."
          },
          "po_number": {
            "type": "string",
            "title": "Purchase order number",
            "description": "For manual invoicing, this identifies the PO number associated with the subscription.",
            "maxLength": 50
          },
          "net_terms": {
            "type": "integer",
            "title": "Net terms",
            "description": "Integer paired with `Net Terms Type` and representing the number\nof days past the current date (for `net` Net Terms Type) or days after\nthe last day of the current month (for `eom` Net Terms Type) that the\ninvoice will become past due. For `manual` collection method, an additional 24 hours is\nadded to ensure the customer has the entire last day to make payment before\nbecoming past due. For example:\n\nIf an invoice is due `net 0`, it is due 'On Receipt' and will become past due 24 hours after it's created.\nIf an invoice is due `net 30`, it will become past due at 31 days exactly.\nIf an invoice is due `eom 30`, it will become past due 31 days from the last day of the current month.\n\nFor `automatic` collection method, the additional 24 hours is not added. For example, On-Receipt is due immediately, and `net 30` will become due exactly 30 days from invoice generation, at which point Recurly will attempt collection.\nWhen `eom` Net Terms Type is passed, the value for `Net Terms` is restricted to `0, 15, 30, 45, 60, or 90`.\n\nFor more information on how net terms work with `manual` collection visit our docs page (https://docs.recurly.com/docs/manual-payments#section-collection-terms)\nor visit (https://docs.recurly.com/docs/automatic-invoicing-terms#section-collection-terms) for information about net terms using `automatic` collection.",
            "minimum": 0,
            "default": 0
          },
          "net_terms_type": {
            "type": "string",
            "title": "Net Terms Type",
            "description": "Optionally supplied string that may be either `net` or `eom` (end-of-month).\nWhen `net`, an invoice becomes past due the specified number of `Net Terms` days from the current date.\nWhen `eom` an invoice becomes past due the specified number of `Net Terms` days from the last day of the current month.\n",
            "enum": [
              "net",
              "eom"
            ],
            "default": "net"
          },
          "gateway_code": {
            "type": "string",
            "title": "Gateway Code",
            "description": "If present, this subscription's transactions will use the payment gateway with this code.",
            "maxLength": 13
          },
          "transaction_type": {
            "description": "An optional type designation for the payment gateway transaction created by this request. Supports 'moto' value, which is the acronym for mail order and telephone transactions.",
            "type": "string",
            "enum": [
              "moto"
            ]
          },
          "gift_card_redemption_code": {
            "type": "string",
            "title": "Gift card Redemption Code",
            "description": "A gift card redemption code to be redeemed on the purchase invoice."
          }
        },
        "required": [
          "plan_code",
          "currency",
          "account"
        ]
      },
      "SubscriptionPurchase": {
        "type": "object",
        "properties": {
          "plan_code": {
            "type": "string",
            "title": "Plan code"
          },
          "plan_id": {
            "type": "string",
            "title": "Plan ID",
            "maxLength": 13
          },
          "unit_amount": {
            "type": "number",
            "format": "float",
            "title": "Custom subscription pricing",
            "description": "Override the unit amount of the subscription plan by setting this value. If not provided, the subscription will inherit the price from the subscription plan for the provided currency.",
            "minimum": 0,
            "maximum": 1000000
          },
          "tax_inclusive": {
            "type": "boolean",
            "title": "Tax Inclusive?",
            "default": false,
            "description": "Determines whether or not tax is included in the unit amount. The Tax Inclusive Pricing feature (separate from the Mixed Tax Pricing feature) must be enabled to use this flag."
          },
          "quantity": {
            "type": "integer",
            "title": "Quantity",
            "description": "Optionally override the default quantity of 1.",
            "default": 1,
            "minimum": 0
          },
          "add_ons": {
            "type": "array",
            "title": "Add-ons",
            "items": {
              "$ref": "#/components/schemas/SubscriptionAddOnCreate"
            }
          },
          "custom_fields": {
            "$ref": "#/components/schemas/CustomFields"
          },
          "shipping": {
            "title": "Shipping address",
            "description": "Create a shipping address on the account and assign it to the subscription.",
            "$ref": "#/components/schemas/SubscriptionShippingPurchase"
          },
          "trial_ends_at": {
            "type": "string",
            "format": "date-time",
            "title": "Trial ends at",
            "description": "If set, overrides the default trial behavior for the subscription. When the current date time or a past date time is provided the subscription will begin with no trial phase (overriding any plan default trial). When a future date time is provided the subscription will begin with a trial phase ending at the specified date time."
          },
          "starts_at": {
            "type": "string",
            "format": "date-time",
            "title": "Start date",
            "description": "If set, the subscription will begin in the future on this date. The subscription will apply the setup fee and trial period, unless the plan has no trial."
          },
          "next_bill_date": {
            "type": "string",
            "format": "date-time",
            "title": "Next bill date",
            "description": "If present, this sets the date the subscription's next billing period will start (`current_period_ends_at`). This can be used to align the subscriptionâ€™s billing to a specific day of the month. The initial invoice will be prorated for the period between the subscription's activation date and the billing period end date. Subsequent periods will be based off the plan interval. For a subscription with a trial period, this will change when the trial expires."
          },
          "total_billing_cycles": {
            "type": "integer",
            "title": "Total billing cycles",
            "description": "The number of cycles/billing periods in a term. When `remaining_billing_cycles=0`, if `auto_renew=true` the subscription will renew and a new term will begin, otherwise the subscription will expire.",
            "minimum": 1
          },
          "renewal_billing_cycles": {
            "type": "integer",
            "title": "Renewal billing cycles",
            "description": "If `auto_renew=true`, when a term completes, `total_billing_cycles` takes this value as the length of subsequent terms. Defaults to the plan's `total_billing_cycles`."
          },
          "auto_renew": {
            "type": "boolean",
            "default": true,
            "title": "Auto renew",
            "description": "Whether the subscription renews at the end of its term."
          },
          "revenue_schedule_type": {
            "title": "Revenue schedule type",
            "type": "string",
            "enum": [
              "at_range_end",
              "at_range_start",
              "evenly",
              "never"
            ]
          },
          "ramp_intervals": {
            "type": "array",
            "title": "Ramp Intervals",
            "description": "The new set of ramp intervals for the subscription.",
            "items": {
              "$ref": "#/components/schemas/SubscriptionRampInterval"
            }
          }
        },
        "required": [
          "plan_code"
        ]
      },
      "SubscriptionUpdate": {
        "type": "object",
        "properties": {
          "collection_method": {
            "title": "Change collection method",
            "type": "string",
            "enum": [
              "automatic",
              "manual"
            ]
          },
          "custom_fields": {
            "$ref": "#/components/schemas/CustomFields"
          },
          "remaining_billing_cycles": {
            "type": "integer",
            "title": "Remaining billing cycles",
            "description": "The remaining billing cycles in the current term."
          },
          "renewal_billing_cycles": {
            "type": "integer",
            "title": "Renewal billing cycles",
            "description": "If `auto_renew=true`, when a term completes, `total_billing_cycles` takes this value as the length of subsequent terms. Defaults to the plan's `total_billing_cycles`."
          },
          "auto_renew": {
            "type": "boolean",
            "default": true,
            "title": "Auto renew",
            "description": "Whether the subscription renews at the end of its term."
          },
          "next_bill_date": {
            "type": "string",
            "format": "date-time",
            "title": "Next bill date",
            "description": "If present, this sets the date the subscription's next billing period will start (`current_period_ends_at`). This can be used to align the subscriptionâ€™s billing to a specific day of the month. For a subscription in a trial period, this will change when the trial expires. This parameter is useful for postponement of a subscription to change its billing date without proration."
          },
          "revenue_schedule_type": {
            "title": "Revenue schedule type",
            "type": "string",
            "enum": [
              "at_range_end",
              "at_range_start",
              "evenly",
              "never"
            ]
          },
          "terms_and_conditions": {
            "type": "string",
            "title": "Terms and conditions",
            "description": "Specify custom notes to add or override Terms and Conditions. Custom notes will stay with a subscription on all renewals."
          },
          "customer_notes": {
            "type": "string",
            "title": "Customer notes",
            "description": "Specify custom notes to add or override Customer Notes. Custom notes will stay with a subscription on all renewals."
          },
          "po_number": {
            "type": "string",
            "title": "Purchase order number",
            "description": "For manual invoicing, this identifies the PO number associated with the subscription.",
            "maxLength": 50
          },
          "net_terms": {
            "type": "integer",
            "title": "Terms that the subscription is due on",
            "description": "Integer paired with `Net Terms Type` and representing the number\nof days past the current date (for `net` Net Terms Type) or days after\nthe last day of the current month (for `eom` Net Terms Type) that the\ninvoice will become past due. For `manual` collection method, an additional 24 hours is\nadded to ensure the customer has the entire last day to make payment before\nbecoming past due. For example:\n\nIf an invoice is due `net 0`, it is due 'On Receipt' and will become past due 24 hours after it's created.\nIf an invoice is due `net 30`, it will become past due at 31 days exactly.\nIf an invoice is due `eom 30`, it will become past due 31 days from the last day of the current month.\n\nFor `automatic` collection method, the additional 24 hours is not added. For example, On-Receipt is due immediately, and `net 30` will become due exactly 30 days from invoice generation, at which point Recurly will attempt collection.\nWhen `eom` Net Terms Type is passed, the value for `Net Terms` is restricted to `0, 15, 30, 45, 60, or 90`.\n\nFor more information on how net terms work with `manual` collection visit our docs page (https://docs.recurly.com/docs/manual-payments#section-collection-terms)\nor visit (https://docs.recurly.com/docs/automatic-invoicing-terms#section-collection-terms) for information about net terms using `automatic` collection.",
            "minimum": 0,
            "default": 0
          },
          "net_terms_type": {
            "type": "string",
            "title": "Net Terms Type",
            "description": "Optionally supplied string that may be either `net` or `eom` (end-of-month).\nWhen `net`, an invoice becomes past due the specified number of `Net Terms` days from the current date.\nWhen `eom` an invoice becomes past due the specified number of `Net Terms` days from the last day of the current month.\n",
            "enum": [
              "net",
              "eom"
            ],
            "default": "net"
          },
          "gateway_code": {
            "type": "string",
            "title": "Gateway Code",
            "description": "If present, this subscription's transactions will use the payment gateway with this code.",
            "maxLength": 13
          },
          "tax_inclusive": {
            "type": "boolean",
            "title": "Tax Inclusive?",
            "default": false,
            "description": "This field is deprecated. Please do not use it.",
            "deprecated": true
          },
          "shipping": {
            "$ref": "#/components/schemas/SubscriptionShippingUpdate"
          },
          "billing_info_id": {
            "type": "string",
            "title": "Billing Info ID",
            "description": "The `billing_info_id` is the value that represents a specific billing info for an end customer. When `billing_info_id` is used to assign billing info to the subscription, all future billing events for the subscription will bill to the specified billing info. `billing_info_id` can ONLY be used for sites utilizing the Wallet feature."
          }
        }
      },
      "SubscriptionPause": {
        "type": "object",
        "properties": {
          "remaining_pause_cycles": {
            "type": "integer",
            "title": "Remaining pause cycles",
            "description": "Number of billing cycles to pause the subscriptions. A value of 0 will cancel any pending pauses on the subscription."
          }
        },
        "required": [
          "remaining_pause_cycles"
        ]
      },
      "SubscriptionShipping": {
        "type": "object",
        "title": "Subscription shipping details",
        "properties": {
          "object": {
            "type": "string",
            "title": "Object type"
          },
          "address": {
            "$ref": "#/components/schemas/ShippingAddress"
          },
          "method": {
            "$ref": "#/components/schemas/ShippingMethodMini"
          },
          "amount": {
            "type": "number",
            "format": "float",
            "title": "Subscription's shipping cost"
          }
        }
      },
      "SubscriptionShippingCreate": {
        "type": "object",
        "title": "Subscription shipping details",
        "properties": {
          "address": {
            "$ref": "#/components/schemas/ShippingAddressCreate"
          },
          "address_id": {
            "type": "string",
            "title": "Shipping address ID",
            "description": "Assign a shipping address from the account's existing shipping addresses. If `address_id` and `address` are both present, `address` will be used.",
            "maxLength": 13
          },
          "method_id": {
            "type": "string",
            "title": "Service ID",
            "description": "The id of the shipping method used to deliver the subscription. If `method_id` and `method_code` are both present, `method_id` will be used.",
            "maxLength": 13
          },
          "method_code": {
            "type": "string",
            "title": "Service Code",
            "description": "The code of the shipping method used to deliver the subscription. If `method_id` and `method_code` are both present, `method_id` will be used.",
            "maxLength": 50
          },
          "amount": {
            "type": "number",
            "format": "float",
            "title": "Assigns the subscription's shipping cost. If this is greater than zero then a `method_id` or `method_code` is required."
          }
        }
      },
      "SubscriptionShippingUpdate": {
        "type": "object",
        "title": "Subscription shipping details",
        "properties": {
          "object": {
            "type": "string",
            "title": "Object type"
          },
          "address": {
            "$ref": "#/components/schemas/ShippingAddressCreate"
          },
          "address_id": {
            "type": "string",
            "title": "Shipping Address ID",
            "description": "Assign a shipping address from the account's existing shipping addresses.",
            "maxLength": 13
          }
        }
      },
      "SubscriptionShippingPurchase": {
        "type": "object",
        "title": "Subscription shipping details",
        "properties": {
          "method_id": {
            "type": "string",
            "title": "Service ID",
            "description": "The id of the shipping method used to deliver the subscription. If `method_id` and `method_code` are both present, `method_id` will be used.",
            "maxLength": 13
          },
          "method_code": {
            "type": "string",
            "title": "Service Code",
            "description": "The code of the shipping method used to deliver the subscription. If `method_id` and `method_code` are both present, `method_id` will be used.",
            "maxLength": 50
          },
          "amount": {
            "type": "number",
            "format": "float",
            "title": "Assigns the subscription's shipping cost. If this is greater than zero then a `method_id` or `method_code` is required."
          }
        }
      },
      "SubscriptionRampInterval": {
        "type": "object",
        "title": "Subscription Ramp Interval",
        "properties": {
          "starting_billing_cycle": {
            "type": "integer",
            "description": "Represents the billing cycle where a ramp interval starts.",
            "default": 1
          },
          "unit_amount": {
            "type": "integer",
            "description": "Represents the price for the ramp interval."
          }
        }
      },
      "SubscriptionRampIntervalResponse": {
        "type": "object",
        "title": "Subscription Ramp Interval",
        "properties": {
          "starting_billing_cycle": {
            "type": "integer",
            "description": "Represents the billing cycle where a ramp interval starts."
          },
          "remaining_billing_cycles": {
            "type": "integer",
            "description": "Represents how many billing cycles are left in a ramp interval."
          },
          "starting_on": {
            "type": "string",
            "format": "date-time",
            "title": "Date the ramp interval starts"
          },
          "ending_on": {
            "type": "string",
            "format": "date-time",
            "title": "Date the ramp interval ends"
          },
          "unit_amount": {
            "type": "number",
            "format": "float",
            "title": "Unit price",
            "description": "Represents the price for the ramp interval."
          }
        }
      },
      "TaxInfo": {
        "type": "object",
        "title": "Tax info",
        "description": "Only for merchants using Recurly's In-The-Box taxes.",
        "properties": {
          "type": {
            "type": "string",
            "title": "Type",
            "description": "Provides the tax type as \"vat\" for EU VAT, \"usst\" for U.S. Sales Tax, or the 2 letter country code for country level tax types like Canada, Australia, New Zealand, Israel, and all non-EU European countries. Not present when Avalara for Communications is enabled."
          },
          "region": {
            "type": "string",
            "title": "Region",
            "description": "Provides the tax region applied on an invoice. For U.S. Sales Tax, this will be the 2 letter state code. For EU VAT this will be the 2 letter country code. For all country level tax types, this will display the regional tax, like VAT, GST, or PST. Not present when Avalara for Communications is enabled."
          },
          "rate": {
            "type": "number",
            "format": "float",
            "title": "Rate",
            "description": "The combined tax rate. Not present when Avalara for Communications is enabled."
          },
          "tax_details": {
            "type": "array",
            "description": "Provides additional tax details for Communications taxes when Avalara for Communications is enabled or Canadian Sales Tax when there is tax applied at both the country and province levels. This will only be populated for the Invoice response when fetching a single invoice and not for the InvoiceList or LineItemList. Only populated for a single LineItem fetch when Avalara for Communications is enabled.",
            "items": {
              "$ref": "#/components/schemas/TaxDetail"
            }
          }
        }
      },
      "TaxDetail": {
        "type": "object",
        "title": "Tax detail",
        "properties": {
          "type": {
            "type": "string",
            "title": "Type",
            "description": "Provides the tax type for the region or type of Comminications tax when Avalara for Communications is enabled. For Canadian Sales Tax, this will be GST, HST, QST or PST."
          },
          "region": {
            "type": "string",
            "title": "Region",
            "description": "Provides the tax region applied on an invoice. For Canadian Sales Tax, this will be either the 2 letter province code or country code. Not present when Avalara for Communications is enabled."
          },
          "rate": {
            "type": "number",
            "format": "float",
            "title": "Rate",
            "description": "Provides the tax rate for the region."
          },
          "tax": {
            "type": "number",
            "format": "float",
            "title": "Tax",
            "description": "The total tax applied for this tax type."
          },
          "name": {
            "type": "string",
            "title": "Name",
            "description": "Provides the name of the Communications tax applied. Present only when Avalara for Communications is enabled."
          },
          "level": {
            "type": "string",
            "title": "Level",
            "description": "Provides the jurisdiction level for the Communications tax applied. Example values include city, state and federal. Present only when Avalara for Communications is enabled."
          },
          "billable": {
            "type": "boolean",
            "title": "Billable",
            "description": "Whether or not the line item is taxable. Only populated for a single LineItem fetch when Avalara for Communications is enabled."
          }
        }
      },
      "Transaction": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "title": "Transaction ID",
            "maxLength": 13
          },
          "object": {
            "type": "string",
            "title": "Object type"
          },
          "uuid": {
            "type": "string",
            "title": "Recurly UUID",
            "description": "The UUID is useful for matching data with the CSV exports and building URLs into Recurly's UI.",
            "maxLength": 32
          },
          "original_transaction_id": {
            "type": "string",
            "title": "Original Transaction ID",
            "description": "If this transaction is a refund (`type=refund`), this will be the ID of the original transaction on the invoice being refunded.",
            "maxLength": 13
          },
          "account": {
            "$ref": "#/components/schemas/AccountMini"
          },
          "invoice": {
            "$ref": "#/components/schemas/InvoiceMini"
          },
          "voided_by_invoice": {
            "$ref": "#/components/schemas/InvoiceMini"
          },
          "subscription_ids": {
            "type": "array",
            "title": "Subscription IDs",
            "description": "If the transaction is charging or refunding for one or more subscriptions, these are their IDs.",
            "items": {
              "type": "string",
              "title": "Subscription ID",
              "maxLength": 13
            }
          },
          "type": {
            "title": "Transaction type",
            "description": "- `authorization` â€“ verifies billing information and places a hold on money in the customer's account.\n- `capture` â€“ captures funds held by an authorization and completes a purchase.\n- `purchase` â€“ combines the authorization and capture in one transaction.\n- `refund` â€“ returns all or a portion of the money collected in a previous transaction to the customer.\n- `verify` â€“ a $0 or $1 transaction used to verify billing information which is immediately voided.\n",
            "type": "string",
            "enum": [
              "authorization",
              "capture",
              "purchase",
              "refund",
              "verify"
            ]
          },
          "origin": {
            "title": "Origin of transaction",
            "description": "Describes how the transaction was triggered.",
            "type": "string",
            "enum": [
              "api",
              "chargeback",
              "external_recovery",
              "force_collect",
              "hpp",
              "merchant",
              "recurly_admin",
              "recurlyjs",
              "recurring",
              "refunded_externally",
              "transparent"
            ]
          },
          "currency": {
            "type": "string",
            "title": "Currency",
            "description": "3-letter ISO 4217 currency code.",
            "maxLength": 3
          },
          "amount": {
            "type": "number",
            "format": "float",
            "title": "Amount",
            "description": "Total transaction amount sent to the payment gateway."
          },
          "status": {
            "title": "Transaction status",
            "description": "The current transaction status. Note that the status may change, e.g. a `pending` transaction may become `declined` or `success` may later become `void`.",
            "type": "string",
            "enum": [
              "chargeback",
              "declined",
              "error",
              "pending",
              "processing",
              "scheduled",
              "success",
              "void"
            ]
          },
          "success": {
            "type": "boolean",
            "title": "Success?",
            "description": "Did this transaction complete successfully?"
          },
          "backup_payment_method_used": {
            "type": "boolean",
            "title": "Backup Payment Method Used?",
            "description": "Indicates if the transaction was completed using a backup payment"
          },
          "refunded": {
            "type": "boolean",
            "title": "Refunded?",
            "description": "Indicates if part or all of this transaction was refunded."
          },
          "billing_address": {
            "$ref": "#/components/schemas/AddressWithName"
          },
          "collection_method": {
            "description": "The method by which the payment was collected.",
            "type": "string",
            "enum": [
              "automatic",
              "manual"
            ]
          },
          "payment_method": {
            "$ref": "#/components/schemas/PaymentMethod"
          },
          "ip_address_v4": {
            "type": "string",
            "title": "IP address",
            "description": "IP address provided when the billing information was collected:\n\n- When the customer enters billing information into the Recurly.js or Hosted Payment Pages, Recurly records the IP address.\n- When the merchant enters billing information using the API, the merchant may provide an IP address.\n- When the merchant enters billing information using the UI, no IP address is recorded.\n"
          },
          "ip_address_country": {
            "type": "string",
            "title": "Origin IP address country, 2-letter ISO 3166-1 alpha-2 code, if known by Recurly."
          },
          "status_code": {
            "type": "string",
            "title": "Status code"
          },
          "status_message": {
            "type": "string",
            "title": "Status message",
            "description": "For declined (`success=false`) transactions, the message displayed to the merchant."
          },
          "customer_message": {
            "type": "string",
            "title": "Customer message",
            "description": "For declined (`success=false`) transactions, the message displayed to the customer."
          },
          "customer_message_locale": {
            "type": "string",
            "title": "Language code for the message"
          },
          "payment_gateway": {
            "type": "object",
            "x-class-name": "TransactionPaymentGateway",
            "properties": {
              "id": {
                "type": "string"
              },
              "object": {
                "type": "string",
                "title": "Object type"
              },
              "type": {
                "type": "string"
              },
              "name": {
                "type": "string"
              }
            }
          },
          "gateway_message": {
            "type": "string",
            "title": "Gateway message",
            "description": "Transaction message from the payment gateway."
          },
          "gateway_reference": {
            "type": "string",
            "title": "Gateway reference",
            "description": "Transaction reference number from the payment gateway."
          },
          "gateway_approval_code": {
            "type": "string",
            "title": "Transaction approval code from the payment gateway."
          },
          "gateway_response_code": {
            "type": "string",
            "title": "For declined transactions (`success=false`), this field lists the gateway error code."
          },
          "gateway_response_time": {
            "type": "number",
            "format": "float",
            "title": "Gateway response time",
            "description": "Time, in seconds, for gateway to process the transaction."
          },
          "gateway_response_values": {
            "type": "object",
            "title": "Gateway response values",
            "description": "The values in this field will vary from gateway to gateway."
          },
          "cvv_check": {
            "title": "CVV check",
            "description": "When processed, result from checking the CVV/CVC value on the transaction.",
            "type": "string",
            "enum": [
              "D",
              "I",
              "M",
              "N",
              "P",
              "S",
              "U",
              "X"
            ]
          },
          "avs_check": {
            "title": "AVS check",
            "description": "When processed, result from checking the overall AVS on the transaction.",
            "type": "string",
            "enum": [
              "A",
              "B",
              "C",
              "D",
              "E",
              "F",
              "G",
              "H",
              "I",
              "J",
              "K",
              "L",
              "M",
              "N",
              "O",
              "P",
              "Q",
              "R",
              "S",
              "T",
              "U",
              "V",
              "W",
              "X",
              "Y",
              "Z"
            ]
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "title": "Created at"
          },
          "updated_at": {
            "type": "string",
            "format": "date-time",
            "title": "Updated at"
          },
          "voided_at": {
            "type": "string",
            "format": "date-time",
            "title": "Voided at"
          },
          "collected_at": {
            "type": "string",
            "format": "date-time",
            "title": "Collected at, or if not collected yet, the time the transaction was created."
          },
          "action_result": {
            "type": "object",
            "description": "Action result params to be used in Recurly-JS to complete a payment when using asynchronous payment methods, e.g., Boleto, iDEAL and Sofort.",
            "title": "Action result"
          },
          "vat_number": {
            "type": "string",
            "description": "VAT number for the customer on this transaction. If the customer's Billing Info country is BR or AR, then this will be their Tax Identifier. For all other countries this will come from the VAT Number field in the Billing Info.",
            "title": "VAT Number"
          },
          "fraud_info": {
            "$ref": "#/components/schemas/TransactionFraudInfo"
          }
        }
      },
      "TransactionFraudInfo": {
        "type": "object",
        "title": "Fraud information",
        "readOnly": true,
        "properties": {
          "object": {
            "type": "string",
            "title": "Object type",
            "readOnly": true
          },
          "score": {
            "type": "integer",
            "title": "Kount score",
            "minimum": 1,
            "maximum": 99
          },
          "decision": {
            "title": "Kount decision",
            "maxLength": 10,
            "type": "string",
            "enum": [
              "approve",
              "decline",
              "escalate",
              "review"
            ]
          },
          "reference": {
            "type": "string",
            "title": "Kount transaction reference ID"
          },
          "risk_rules_triggered": {
            "type": "array",
            "title": "Risk Rules Triggered",
            "description": "A list of fraud risk rules that were triggered for the transaction.",
            "items": {
              "$ref": "#/components/schemas/FraudRiskRule"
            }
          }
        }
      },
      "FraudRiskRule": {
        "type": "object",
        "properties": {
          "code": {
            "type": "string",
            "title": "The Kount rule number."
          },
          "message": {
            "type": "string",
            "title": "Description of why the rule was triggered"
          }
        }
      },
      "ExternalTransaction": {
        "type": "object",
        "properties": {
          "payment_method": {
            "type": "string",
            "title": "Payment Method",
            "description": "Payment method used for external transaction.",
            "enum": [
              "bacs",
              "ach",
              "amazon",
              "apple_pay",
              "braintree_apple_pay",
              "check",
              "credit_card",
              "eft",
              "google_pay",
              "money_order",
              "other",
              "paypal",
              "roku",
              "sepadirectdebit",
              "wire_transfer"
            ]
          },
          "description": {
            "type": "string",
            "title": "Description",
            "description": "Used as the transaction's description.",
            "maxLength": 50
          },
          "amount": {
            "type": "number",
            "format": "float",
            "title": "Amount",
            "description": "The total amount of the transcaction. Cannot excceed the invoice total."
          },
          "collected_at": {
            "type": "string",
            "format": "date-time",
            "title": "Collected At",
            "description": "Datetime that the external payment was collected. Defaults to current datetime."
          }
        }
      },
      "UniqueCouponCode": {
        "type": "object",
        "description": "A unique coupon code for a bulk coupon.",
        "properties": {
          "id": {
            "type": "string",
            "title": "Unique Coupon Code ID",
            "readOnly": true
          },
          "object": {
            "type": "string",
            "title": "Object type",
            "readOnly": true
          },
          "code": {
            "type": "string",
            "title": "Coupon code",
            "description": "The code the customer enters to redeem the coupon."
          },
          "state": {
            "title": "State",
            "description": "Indicates if the unique coupon code is redeemable or why not.",
            "type": "string",
            "enum": [
              "expired",
              "inactive",
              "maxed_out",
              "redeemable"
            ]
          },
          "bulk_coupon_id": {
            "type": "string",
            "title": "Bulk Coupon ID",
            "description": "The Coupon ID of the parent Bulk Coupon",
            "readOnly": true
          },
          "bulk_coupon_code": {
            "type": "string",
            "title": "Bulk Coupon code",
            "description": "The Coupon code of the parent Bulk Coupon"
          },
          "created_at": {
            "type": "string",
            "title": "Created at",
            "format": "date-time",
            "readOnly": true
          },
          "updated_at": {
            "type": "string",
            "title": "Updated at",
            "format": "date-time",
            "readOnly": true
          },
          "redeemed_at": {
            "type": "string",
            "title": "Redeemed at",
            "description": "The date and time the unique coupon code was redeemed.",
            "format": "date-time",
            "readOnly": true
          },
          "expired_at": {
            "type": "string",
            "title": "Expired at",
            "description": "The date and time the coupon was expired early or reached its `max_redemptions`.",
            "format": "date-time"
          }
        }
      },
      "UniqueCouponCodeList": {
        "type": "object",
        "properties": {
          "object": {
            "type": "string",
            "title": "Object type",
            "description": "Will always be List."
          },
          "has_more": {
            "type": "boolean",
            "description": "Indicates there are more results on subsequent pages."
          },
          "next": {
            "type": "string",
            "description": "Path to subsequent page of results."
          },
          "data": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/UniqueCouponCode"
            }
          }
        }
      },
      "UniqueCouponCodeParams": {
        "type": "object",
        "description": "Parameters to be passed to the `list_unique_coupon_codes` endpoint to obtain the newly generated codes.",
        "properties": {
          "limit": {
            "type": "integer",
            "title": "The number of UniqueCouponCodes that will be generated"
          },
          "order": {
            "type": "string",
            "title": "Sort order to list newly generated UniqueCouponCodes (should always be `asc`)"
          },
          "sort": {
            "type": "string",
            "title": "Sort field to list newly generated UniqueCouponCodes (should always be `created_at`)"
          },
          "begin_time": {
            "type": "string",
            "title": "Begin time query parameter",
            "description": "The date-time to be included when listing UniqueCouponCodes",
            "format": "date-time"
          }
        }
      },
      "Usage": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string"
          },
          "object": {
            "type": "string",
            "title": "Object type"
          },
          "merchant_tag": {
            "type": "string",
            "description": "Custom field for recording the id in your own system associated with the usage, so you can provide auditable usage displays to your customers using a GET on this endpoint."
          },
          "amount": {
            "type": "number",
            "format": "float",
            "description": "The amount of usage. Can be positive, negative, or 0. If the Decimal Quantity feature is enabled, this value will be rounded to nine decimal places.  Otherwise, all digits after the decimal will be stripped. If the usage-based add-on is billed with a percentage, your usage should be a monetary amount formatted in cents (e.g., $5.00 is \"500\")."
          },
          "usage_type": {
            "type": "string",
            "enum": [
              "price",
              "percentage"
            ],
            "title": "Usage Type",
            "description": "Type of usage, returns usage type if `add_on_type` is `usage`."
          },
          "tier_type": {
            "type": "string",
            "title": "Tier type",
            "description": "The pricing model for the add-on.  For more information,\n[click here](https://docs.recurly.com/docs/billing-models#section-quantity-based). See our\n[Guide](https://recurly.com/developers/guides/item-addon-guide.html) for an overview of how\nto configure quantity-based pricing models.\n",
            "default": "flat",
            "enum": [
              "flat",
              "tiered",
              "stairstep",
              "volume"
            ]
          },
          "tiers": {
            "type": "array",
            "title": "Tiers",
            "items": {
              "$ref": "#/components/schemas/SubscriptionAddOnTier"
            },
            "description": "The tiers and prices of the subscription based on the usage_timestamp. If tier_type = flat, tiers = []"
          },
          "percentage_tiers": {
            "type": "array",
            "title": "Percentage Tiers",
            "items": {
              "$ref": "#/components/schemas/SubscriptionAddOnPercentageTier"
            },
            "description": "The percentage tiers of the subscription based on the usage_timestamp. If tier_type = flat, percentage_tiers = []. This feature is currently in development and requires approval and enablement, please contact support."
          },
          "measured_unit_id": {
            "type": "string",
            "description": "The ID of the measured unit associated with the add-on the usage record is for."
          },
          "recording_timestamp": {
            "type": "string",
            "format": "date-time",
            "description": "When the usage was recorded in your system."
          },
          "usage_timestamp": {
            "type": "string",
            "format": "date-time",
            "description": "When the usage actually happened. This will define the line item dates this usage is billed under and is important for revenue recognition."
          },
          "usage_percentage": {
            "type": "number",
            "format": "float",
            "title": "Usage Percentage",
            "description": "The percentage taken of the monetary amount of usage tracked. This can be up to 4 decimal places. A value between 0.0 and 100.0."
          },
          "unit_amount": {
            "type": "number",
            "format": "float",
            "title": "Unit price"
          },
          "unit_amount_decimal": {
            "type": "string",
            "title": "Unit Amount Decimal",
            "minimum": 0,
            "maximum": 1000000,
            "description": "Unit price that can optionally support a sub-cent value."
          },
          "billed_at": {
            "type": "string",
            "format": "date-time",
            "description": "When the usage record was billed on an invoice."
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "description": "When the usage record was created in Recurly."
          },
          "updated_at": {
            "type": "string",
            "format": "date-time",
            "description": "When the usage record was billed on an invoice."
          }
        }
      },
      "UsageCreate": {
        "type": "object",
        "properties": {
          "merchant_tag": {
            "type": "string",
            "description": "Custom field for recording the id in your own system associated with the usage, so you can provide auditable usage displays to your customers using a GET on this endpoint."
          },
          "amount": {
            "type": "number",
            "format": "float",
            "description": "The amount of usage. Can be positive, negative, or 0. If the Decimal Quantity feature is enabled, this value will be rounded to nine decimal places.  Otherwise, all digits after the decimal will be stripped. If the usage-based add-on is billed with a percentage, your usage should be a monetary amount formatted in cents (e.g., $5.00 is \"500\")."
          },
          "recording_timestamp": {
            "type": "string",
            "format": "date-time",
            "description": "When the usage was recorded in your system."
          },
          "usage_timestamp": {
            "type": "string",
            "format": "date-time",
            "description": "When the usage actually happened. This will define the line item dates this usage is billed under and is important for revenue recognition."
          }
        }
      },
      "UsageList": {
        "type": "object",
        "properties": {
          "object": {
            "type": "string",
            "title": "Object type",
            "description": "Will always be List."
          },
          "has_more": {
            "type": "boolean",
            "description": "Indicates there are more results on subsequent pages."
          },
          "next": {
            "type": "string",
            "description": "Path to subsequent page of results."
          },
          "data": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Usage"
            }
          }
        }
      },
      "User": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "readOnly": true
          },
          "object": {
            "type": "string",
            "title": "Object type",
            "readOnly": true
          },
          "email": {
            "type": "string",
            "format": "email"
          },
          "first_name": {
            "type": "string"
          },
          "last_name": {
            "type": "string"
          },
          "time_zone": {
            "type": "string"
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "readOnly": true
          },
          "deleted_at": {
            "type": "string",
            "format": "date-time",
            "readOnly": true
          }
        }
      },
      "PurchaseCreate": {
        "type": "object",
        "description": "A purchase is only a request data type and is not persistent in Recurly, an InvoiceCollection will be the returned type.",
        "properties": {
          "currency": {
            "type": "string",
            "title": "Currency",
            "description": "3-letter ISO 4217 currency code.",
            "maxLength": 3
          },
          "account": {
            "$ref": "#/components/schemas/AccountPurchase"
          },
          "billing_info_id": {
            "type": "string",
            "description": "The `billing_info_id` is the value that represents a specific billing info for an end customer. When `billing_info_id` is used to assign billing info to the subscription, all future billing events for the subscription will bill to the specified billing info. `billing_info_id` can ONLY be used for sites utilizing the Wallet feature."
          },
          "collection_method": {
            "title": "Collection method",
            "description": "Must be set to manual in order to preview a purchase for an Account that does not have payment information associated with the Billing Info.",
            "default": "automatic",
            "type": "string",
            "enum": [
              "automatic",
              "manual"
            ]
          },
          "po_number": {
            "type": "string",
            "title": "Purchase order number",
            "description": "For manual invoicing, this identifies the PO number associated with the subscription.",
            "maxLength": 50
          },
          "net_terms": {
            "type": "integer",
            "title": "Net terms",
            "description": "Integer paired with `Net Terms Type` and representing the number\nof days past the current date (for `net` Net Terms Type) or days after\nthe last day of the current month (for `eom` Net Terms Type) that the\ninvoice will become past due. For `manual` collection method, an additional 24 hours is\nadded to ensure the customer has the entire last day to make payment before\nbecoming past due. For example:\n\nIf an invoice is due `net 0`, it is due 'On Receipt' and will become past due 24 hours after it's created.\nIf an invoice is due `net 30`, it will become past due at 31 days exactly.\nIf an invoice is due `eom 30`, it will become past due 31 days from the last day of the current month.\n\nFor `automatic` collection method, the additional 24 hours is not added. For example, On-Receipt is due immediately, and `net 30` will become due exactly 30 days from invoice generation, at which point Recurly will attempt collection.\nWhen `eom` Net Terms Type is passed, the value for `Net Terms` is restricted to `0, 15, 30, 45, 60, or 90`.\n\nFor more information on how net terms work with `manual` collection visit our docs page (https://docs.recurly.com/docs/manual-payments#section-collection-terms)\nor visit (https://docs.recurly.com/docs/automatic-invoicing-terms#section-collection-terms) for information about net terms using `automatic` collection.",
            "minimum": 0,
            "default": 0
          },
          "net_terms_type": {
            "type": "string",
            "title": "Net Terms Type",
            "description": "Optionally supplied string that may be either `net` or `eom` (end-of-month).\nWhen `net`, an invoice becomes past due the specified number of `Net Terms` days from the current date.\nWhen `eom` an invoice becomes past due the specified number of `Net Terms` days from the last day of the current month.\n",
            "enum": [
              "net",
              "eom"
            ],
            "default": "net"
          },
          "terms_and_conditions": {
            "type": "string",
            "title": "Terms and conditions",
            "description": "Terms and conditions to be put on the purchase invoice."
          },
          "customer_notes": {
            "type": "string",
            "title": "Customer notes"
          },
          "vat_reverse_charge_notes": {
            "type": "string",
            "title": "VAT reverse charge notes",
            "description": "VAT reverse charge notes for cross border European tax settlement."
          },
          "credit_customer_notes": {
            "type": "string",
            "title": "Credit customer notes",
            "description": "Notes to be put on the credit invoice resulting from credits in the purchase, if any."
          },
          "gateway_code": {
            "type": "string",
            "title": "Gateway Code",
            "description": "The default payment gateway identifier to be used for the purchase transaction.  This will also be applied as the default for any subscriptions included in the purchase request.",
            "maxLength": 13
          },
          "shipping": {
            "type": "object",
            "x-class-name": "ShippingPurchase",
            "properties": {
              "address_id": {
                "type": "string",
                "title": "Shipping address ID",
                "description": "Assign a shipping address from the account's existing shipping addresses. If this and `address` are both present, `address` will take precedence.",
                "maxLength": 13
              },
              "address": {
                "$ref": "#/components/schemas/ShippingAddressCreate"
              },
              "fees": {
                "type": "array",
                "title": "Shipping fees",
                "description": "A list of shipping fees to be created as charges with the purchase.",
                "items": {
                  "$ref": "#/components/schemas/ShippingFeeCreate"
                }
              }
            }
          },
          "line_items": {
            "type": "array",
            "title": "Line items",
            "description": "A list of one time charges or credits to be created with the purchase.",
            "items": {
              "$ref": "#/components/schemas/LineItemCreate"
            }
          },
          "subscriptions": {
            "type": "array",
            "title": "Subscriptions",
            "description": "A list of subscriptions to be created with the purchase.",
            "items": {
              "$ref": "#/components/schemas/SubscriptionPurchase"
            }
          },
          "coupon_codes": {
            "type": "array",
            "title": "Coupon codes",
            "description": "A list of coupon_codes to be redeemed on the subscription or account during the purchase.",
            "items": {
              "type": "string"
            }
          },
          "gift_card_redemption_code": {
            "type": "string",
            "title": "Gift card redemption code",
            "description": "A gift card redemption code to be redeemed on the purchase invoice."
          },
          "transaction_type": {
            "description": "An optional type designation for the payment gateway transaction created by this request. Supports 'moto' value, which is the acronym for mail order and telephone transactions.",
            "type": "string",
            "enum": [
              "moto"
            ]
          }
        },
        "required": [
          "currency",
          "account"
        ]
      },
      "DunningCampaign": {
        "type": "object",
        "description": "Settings for a dunning campaign.",
        "properties": {
          "id": {
            "type": "string"
          },
          "object": {
            "type": "string",
            "title": "Object type"
          },
          "code": {
            "type": "string",
            "description": "Campaign code."
          },
          "name": {
            "type": "string",
            "description": "Campaign name."
          },
          "description": {
            "type": "string",
            "description": "Campaign description."
          },
          "default_campaign": {
            "type": "boolean",
            "description": "Whether or not this is the default campaign for accounts or plans without an assigned dunning campaign."
          },
          "dunning_cycles": {
            "type": "array",
            "description": "Dunning Cycle settings.",
            "items": {
              "$ref": "#/components/schemas/DunningCycle"
            }
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "description": "When the current campaign was created in Recurly."
          },
          "updated_at": {
            "type": "string",
            "format": "date-time",
            "description": "When the current campaign was updated in Recurly."
          },
          "deleted_at": {
            "type": "string",
            "format": "date-time",
            "description": "When the current campaign was deleted in Recurly."
          }
        }
      },
      "DunningCampaignList": {
        "type": "object",
        "properties": {
          "object": {
            "type": "string",
            "title": "Object type",
            "description": "Will always be List."
          },
          "has_more": {
            "type": "boolean",
            "description": "Indicates there are more results on subsequent pages."
          },
          "next": {
            "type": "string",
            "description": "Path to subsequent page of results."
          },
          "data": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/DunningCampaign"
            }
          }
        }
      },
      "DunningCycle": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "description": "The type of invoice this cycle applies to.",
            "enum": [
              "automatic",
              "manual",
              "trial"
            ]
          },
          "applies_to_manual_trial": {
            "type": "boolean",
            "description": "Whether the dunning settings will be applied to manual trials. Only applies to trial cycles."
          },
          "first_communication_interval": {
            "type": "integer",
            "description": "The number of days after a transaction failure before the first dunning email is sent."
          },
          "send_immediately_on_hard_decline": {
            "type": "boolean",
            "description": "Whether or not to send an extra email immediately to customers whose initial payment attempt fails with either a hard decline or invalid billing info."
          },
          "intervals": {
            "type": "array",
            "description": "Dunning intervals.",
            "items": {
              "$ref": "#/components/schemas/DunningInterval"
            }
          },
          "expire_subscription": {
            "type": "boolean",
            "description": "Whether the subscription(s) should be cancelled at the end of the dunning cycle."
          },
          "fail_invoice": {
            "type": "boolean",
            "description": "Whether the invoice should be failed at the end of the dunning cycle."
          },
          "total_dunning_days": {
            "type": "integer",
            "description": "The number of days between the first dunning email being sent and the end of the dunning cycle."
          },
          "total_recycling_days": {
            "type": "integer",
            "description": "The number of days between a transaction failure and the end of the dunning cycle."
          },
          "version": {
            "type": "integer",
            "description": "Current campaign version."
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "description": "When the current settings were created in Recurly."
          },
          "updated_at": {
            "type": "string",
            "format": "date-time",
            "description": "When the current settings were updated in Recurly."
          }
        }
      },
      "DunningInterval": {
        "properties": {
          "days": {
            "type": "integer",
            "description": "Number of days before sending the next email."
          },
          "email_template": {
            "type": "string",
            "description": "Email template being used."
          }
        }
      },
      "DunningCampaignsBulkUpdate": {
        "properties": {
          "plan_codes": {
            "type": "array",
            "maxItems": 200,
            "description": "List of `plan_codes` associated with the Plans for which the dunning campaign should be updated. Required unless `plan_ids` is present.",
            "items": {
              "type": "string"
            }
          },
          "plan_ids": {
            "type": "array",
            "maxItems": 200,
            "description": "List of `plan_ids` associated with the Plans for which the dunning campaign should be updated. Required unless `plan_codes` is present.",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "DunningCampaignsBulkUpdateResponse": {
        "properties": {
          "object": {
            "type": "string",
            "title": "Object type",
            "readOnly": true
          },
          "plans": {
            "type": "array",
            "title": "Plans",
            "description": "An array containing all of the `Plan` resources that have been updated.",
            "maxItems": 200,
            "items": {
              "$ref": "#/components/schemas/Plan"
            }
          }
        }
      },
      "Entitlements": {
        "type": "object",
        "description": "A list of privileges granted to a customer through the purchase of a plan or item.",
        "properties": {
          "object": {
            "type": "string",
            "title": "Object Type"
          },
          "has_more": {
            "type": "boolean",
            "description": "Indicates there are more results on subsequent pages."
          },
          "next": {
            "type": "string",
            "description": "Path to subsequent page of results."
          },
          "data": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Entitlement"
            }
          }
        }
      },
      "Entitlement": {
        "type": "object",
        "properties": {
          "object": {
            "type": "string",
            "description": "Entitlement"
          },
          "customer_permission": {
            "$ref": "#/components/schemas/CustomerPermission"
          },
          "granted_by": {
            "type": "array",
            "description": "Subscription or item that granted the customer permission.",
            "items": {
              "$ref": "#/components/schemas/GrantedBy"
            }
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "description": "Time object was created."
          },
          "updated_at": {
            "type": "string",
            "format": "date-time",
            "description": "Time the object was last updated"
          }
        }
      },
      "ExternalPaymentPhase": {
        "type": "object",
        "description": "Details of payments in the lifecycle of a subscription from an external resource that is not managed by the Recurly platform, e.g. App Store or Google Play Store.",
        "properties": {
          "id": {
            "type": "string",
            "title": "External payment phase ID",
            "description": "System-generated unique identifier for an external payment phase ID, e.g. `e28zov4fw0v2`."
          },
          "object": {
            "type": "string",
            "title": "Object type"
          },
          "started_at": {
            "type": "string",
            "format": "date-time",
            "title": "Started At"
          },
          "ends_at": {
            "type": "string",
            "format": "date-time",
            "title": "Ends At"
          },
          "starting_billing_period_index": {
            "type": "integer",
            "title": "Starting Billing Period Index"
          },
          "ending_billing_period_index": {
            "type": "integer",
            "title": "Ending Billing Period Index"
          },
          "offer_type": {
            "type": "string",
            "title": "Offer Type",
            "description": "Type of discount offer given, e.g. \"FREE_TRIAL\""
          },
          "offer_name": {
            "type": "string",
            "title": "Offer Name",
            "description": "Name of the discount offer given, e.g. \"introductory\""
          },
          "period_count": {
            "type": "integer",
            "title": "Period Count",
            "description": "Number of billing periods"
          },
          "period_length": {
            "type": "string",
            "title": "Period Length",
            "description": "Billing cycle length"
          },
          "amount": {
            "type": "string",
            "format": "decimal",
            "title": "Amount",
            "minimum": 0,
            "description": "Allows up to 9 decimal places"
          },
          "currency": {
            "type": "string",
            "title": "Currency",
            "description": "3-letter ISO 4217 currency code.",
            "maxLength": 3
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "title": "Created at",
            "description": "When the external subscription was created in Recurly."
          },
          "updated_at": {
            "type": "string",
            "format": "date-time",
            "title": "Updated at",
            "description": "When the external subscription was updated in Recurly."
          }
        }
      },
      "ExternalPaymentPhaseList": {
        "type": "object",
        "properties": {
          "object": {
            "type": "string",
            "title": "Object type",
            "description": "Will always be List."
          },
          "has_more": {
            "type": "boolean",
            "description": "Indicates there are more results on subsequent pages."
          },
          "next": {
            "type": "string",
            "description": "Path to subsequent page of results."
          },
          "data": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ExternalPaymentPhase"
            }
          }
        }
      },
      "ExternalProduct": {
        "type": "object",
        "description": "Product from an external resource such as Apple App Store or Google Play Store.",
        "properties": {
          "id": {
            "type": "string",
            "title": "External product ID.",
            "description": "System-generated unique identifier for an external product ID, e.g. `e28zov4fw0v2`."
          },
          "object": {
            "type": "string",
            "title": "Object type"
          },
          "name": {
            "type": "string",
            "title": "Name",
            "description": "Name to identify the external product in Recurly."
          },
          "plan": {
            "$ref": "#/components/schemas/PlanMini"
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "description": "When the external product was created in Recurly."
          },
          "updated_at": {
            "type": "string",
            "format": "date-time",
            "description": "When the external product was updated in Recurly."
          },
          "external_product_references": {
            "type": "array",
            "title": "External Product References",
            "description": "List of external product references of the external product.",
            "items": {
              "$ref": "#/components/schemas/ExternalProductReferenceMini"
            }
          }
        }
      },
      "ExternalProductList": {
        "type": "object",
        "properties": {
          "object": {
            "type": "string",
            "title": "Object type",
            "description": "Will always be List."
          },
          "has_more": {
            "type": "boolean",
            "description": "Indicates there are more results on subsequent pages."
          },
          "next": {
            "type": "string",
            "description": "Path to subsequent page of results."
          },
          "data": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ExternalProduct"
            }
          }
        }
      },
      "ExternalProductCreate": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "External product name."
          },
          "plan_id": {
            "type": "string",
            "description": "Recurly plan UUID."
          },
          "external_product_references": {
            "type": "array",
            "title": "External Product References",
            "description": "List of external product references of the external product.",
            "items": {
              "$ref": "#/components/schemas/ExternalProductReferenceBase"
            }
          }
        },
        "required": [
          "name"
        ]
      },
      "ExternalProductUpdate": {
        "type": "object",
        "properties": {
          "plan_id": {
            "type": "string",
            "description": "Recurly plan UUID."
          }
        },
        "required": [
          "plan_id"
        ]
      },
      "ExternalProductReferenceBase": {
        "type": "object",
        "properties": {
          "reference_code": {
            "type": "string",
            "description": "A code which associates the external product to a corresponding object or resource in an external platform like the Apple App Store or Google Play Store.",
            "maxLength": 255
          },
          "external_connection_type": {
            "type": "string",
            "enum": [
              "apple_app_store",
              "google_play_store"
            ]
          }
        }
      },
      "ExternalProductReferenceCollection": {
        "type": "object",
        "properties": {
          "object": {
            "type": "string",
            "title": "Object type",
            "description": "Will always be List."
          },
          "has_more": {
            "type": "boolean",
            "description": "Indicates there are more results on subsequent pages."
          },
          "next": {
            "type": "string",
            "description": "Path to subsequent page of results."
          },
          "data": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ExternalProductReferenceMini"
            }
          }
        }
      },
      "ExternalProductReferenceCreate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ExternalProductReferenceBase"
          }
        ],
        "required": [
          "reference_code",
          "external_connection_type"
        ]
      },
      "ExternalProductReferenceUpdate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ExternalProductReferenceBase"
          }
        ]
      },
      "ExternalAccountList": {
        "type": "object",
        "properties": {
          "object": {
            "type": "string",
            "title": "Object type",
            "description": "Will always be List."
          },
          "has_more": {
            "type": "boolean",
            "description": "Indicates there are more results on subsequent pages."
          },
          "next": {
            "type": "string",
            "description": "Path to subsequent page of results."
          },
          "data": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ExternalAccount"
            }
          }
        }
      },
      "ExternalAccountCreate": {
        "type": "object",
        "properties": {
          "external_account_code": {
            "type": "string",
            "description": "Represents the account code for the external account."
          },
          "external_connection_type": {
            "type": "string",
            "description": "Represents the connection type. `AppleAppStore` or `GooglePlayStore`"
          }
        },
        "required": [
          "external_account_code",
          "external_connection_type"
        ]
      },
      "ExternalAccountUpdate": {
        "type": "object",
        "properties": {
          "external_account_code": {
            "type": "string",
            "description": "Represents the account code for the external account."
          },
          "external_connection_type": {
            "type": "string",
            "description": "Represents the connection type. `AppleAppStore` or `GooglePlayStore`"
          }
        }
      },
      "ExternalAccount": {
        "type": "object",
        "title": "External Account",
        "properties": {
          "object": {
            "type": "string",
            "default": "external_account"
          },
          "id": {
            "type": "string",
            "description": "UUID of the external_account ."
          },
          "external_account_code": {
            "type": "string",
            "description": "Represents the account code for the external account."
          },
          "external_connection_type": {
            "type": "string",
            "description": "Represents the connection type. `AppleAppStore` or `GooglePlayStore`"
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "description": "Created at",
            "readOnly": true
          },
          "updated_at": {
            "type": "string",
            "format": "date-time",
            "description": "Last updated at",
            "readOnly": true
          }
        }
      },
      "ExternalProductReferenceMini": {
        "type": "object",
        "title": "External Product Reference details",
        "description": "External Product Reference details",
        "properties": {
          "id": {
            "type": "string",
            "title": "External Product ID",
            "description": "System-generated unique identifier for an external product ID, e.g. `e28zov4fw0v2`."
          },
          "object": {
            "type": "string",
            "title": "object"
          },
          "reference_code": {
            "type": "string",
            "title": "reference_code",
            "description": "A code which associates the external product to a corresponding object or resource in an external platform like the Apple App Store or Google Play Store."
          },
          "external_connection_type": {
            "type": "string",
            "title": "external_connection_type",
            "description": "Source connection platform."
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "description": "When the external product was created in Recurly."
          },
          "updated_at": {
            "type": "string",
            "format": "date-time",
            "description": "When the external product was updated in Recurly."
          }
        }
      },
      "ExternalSubscription": {
        "type": "object",
        "description": "Subscription from an external resource such as Apple App Store or Google Play Store.",
        "properties": {
          "id": {
            "type": "string",
            "title": "External subscription ID",
            "description": "System-generated unique identifier for an external subscription ID, e.g. `e28zov4fw0v2`."
          },
          "object": {
            "type": "string",
            "title": "Object type"
          },
          "account": {
            "$ref": "#/components/schemas/AccountMini"
          },
          "external_product_reference": {
            "$ref": "#/components/schemas/ExternalProductReferenceMini"
          },
          "external_payment_phases": {
            "type": "array",
            "title": "External payment phases",
            "description": "The phases of the external subscription payment lifecycle.",
            "items": {
              "$ref": "#/components/schemas/ExternalPaymentPhase"
            }
          },
          "external_id": {
            "type": "string",
            "title": "External Id",
            "description": "The id of the subscription in the external systems., I.e. Apple App Store or Google Play Store."
          },
          "uuid": {
            "type": "string",
            "title": "Uuid",
            "description": "Universally Unique Identifier created automatically."
          },
          "last_purchased": {
            "type": "string",
            "format": "date-time",
            "title": "Last purchased",
            "description": "When a new billing event occurred on the external subscription in conjunction with a recent billing period, reactivation or upgrade/downgrade."
          },
          "auto_renew": {
            "type": "boolean",
            "title": "Auto-renew",
            "description": "An indication of whether or not the external subscription will auto-renew at the expiration date.",
            "default": false
          },
          "in_grace_period": {
            "type": "boolean",
            "title": "In grace period",
            "description": "An indication of whether or not the external subscription is in a grace period.",
            "default": false
          },
          "app_identifier": {
            "type": "string",
            "title": "App identifier",
            "description": "Identifier of the app that generated the external subscription."
          },
          "quantity": {
            "type": "integer",
            "title": "Quantity",
            "description": "An indication of the quantity of a subscribed item's quantity.",
            "default": 1,
            "minimum": 0
          },
          "state": {
            "type": "string",
            "description": "External subscriptions can be active, canceled, expired, past_due, voided, revoked, or paused.",
            "default": "active"
          },
          "activated_at": {
            "type": "string",
            "format": "date-time",
            "title": "Activated at",
            "description": "When the external subscription was activated in the external platform."
          },
          "canceled_at": {
            "type": "string",
            "format": "date-time",
            "title": "Canceled at",
            "description": "When the external subscription was canceled in the external platform."
          },
          "expires_at": {
            "type": "string",
            "format": "date-time",
            "title": "Expires at",
            "description": "When the external subscription expires in the external platform."
          },
          "trial_started_at": {
            "type": "string",
            "format": "date-time",
            "title": "Trial started at",
            "description": "When the external subscription trial period started in the external platform."
          },
          "trial_ends_at": {
            "type": "string",
            "format": "date-time",
            "title": "Trial ends at",
            "description": "When the external subscription trial period ends in the external platform."
          },
          "test": {
            "type": "boolean",
            "title": "Test",
            "description": "An indication of whether or not the external subscription was purchased in a sandbox environment.",
            "default": false
          },
          "imported": {
            "type": "boolean",
            "title": "Imported",
            "description": "An indication of whether or not the external subscription was created by a historical data import.",
            "default": false
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "title": "Created at",
            "description": "When the external subscription was created in Recurly."
          },
          "updated_at": {
            "type": "string",
            "format": "date-time",
            "title": "Updated at",
            "description": "When the external subscription was updated in Recurly."
          }
        }
      },
      "ExternalSubscriptionList": {
        "type": "object",
        "properties": {
          "object": {
            "type": "string",
            "title": "Object type",
            "description": "Will always be List."
          },
          "has_more": {
            "type": "boolean",
            "description": "Indicates there are more results on subsequent pages."
          },
          "next": {
            "type": "string",
            "description": "Path to subsequent page of results."
          },
          "data": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ExternalSubscription"
            }
          }
        }
      },
      "ExternalInvoice": {
        "type": "object",
        "description": "Invoice from an external resource such as Apple App Store or Google Play Store.",
        "properties": {
          "id": {
            "type": "string",
            "title": "External invoice ID",
            "description": "System-generated unique identifier for an external invoice ID, e.g. `e28zov4fw0v2`."
          },
          "object": {
            "type": "string",
            "title": "Object type"
          },
          "account": {
            "$ref": "#/components/schemas/AccountMini"
          },
          "external_subscription": {
            "$ref": "#/components/schemas/ExternalSubscription"
          },
          "external_id": {
            "type": "string",
            "description": "An identifier which associates the external invoice to a corresponding object in an external platform."
          },
          "state": {
            "type": "string",
            "enum": [
              "paid"
            ]
          },
          "total": {
            "type": "string",
            "format": "decimal",
            "title": "Total"
          },
          "currency": {
            "type": "string",
            "title": "Currency",
            "description": "3-letter ISO 4217 currency code."
          },
          "line_items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ExternalCharge"
            }
          },
          "purchased_at": {
            "type": "string",
            "format": "date-time",
            "description": "When the invoice was created in the external platform."
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "description": "When the external invoice was created in Recurly."
          },
          "updated_at": {
            "type": "string",
            "format": "date-time",
            "title": "Updated at",
            "description": "When the external invoice was updated in Recurly."
          }
        }
      },
      "ExternalInvoiceList": {
        "type": "object",
        "properties": {
          "object": {
            "type": "string",
            "title": "Object type",
            "description": "Will always be List."
          },
          "has_more": {
            "type": "boolean",
            "description": "Indicates there are more results on subsequent pages."
          },
          "next": {
            "type": "string",
            "description": "Path to subsequent page of results."
          },
          "data": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ExternalInvoice"
            }
          }
        }
      },
      "ExternalCharge": {
        "type": "object",
        "description": "Charge from an external resource such as Apple App Store or Google Play Store.",
        "properties": {
          "id": {
            "type": "string",
            "title": "External invoice ID",
            "description": "System-generated unique identifier for an external charge ID, e.g. `e28zov4fw0v2`."
          },
          "object": {
            "type": "string",
            "title": "Object type"
          },
          "account": {
            "$ref": "#/components/schemas/AccountMini"
          },
          "currency": {
            "type": "string",
            "title": "Currency",
            "description": "3-letter ISO 4217 currency code."
          },
          "unit_amount": {
            "type": "string",
            "format": "decimal",
            "title": "Unit Amount"
          },
          "quantity": {
            "type": "integer"
          },
          "description": {
            "type": "string"
          },
          "external_product_reference": {
            "$ref": "#/components/schemas/ExternalProductReferenceMini"
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "title": "Created at",
            "description": "When the external charge was created in Recurly."
          },
          "updated_at": {
            "type": "string",
            "format": "date-time",
            "title": "Updated at",
            "description": "When the external charge was updated in Recurly."
          }
        }
      },
      "CustomerPermission": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Customer permission ID."
          },
          "code": {
            "type": "string",
            "description": "Customer permission code."
          },
          "name": {
            "type": "string",
            "description": "Customer permission name."
          },
          "description": {
            "type": "string",
            "description": "Description of customer permission."
          },
          "object": {
            "type": "string",
            "description": "It will always be \"customer_permission\"."
          }
        }
      },
      "GrantedBy": {
        "type": "object",
        "description": "The subscription or external subscription that grants customer permissions.",
        "properties": {
          "object": {
            "type": "string",
            "title": "Object Type"
          },
          "id": {
            "type": "string",
            "description": "The ID of the subscription or external subscription that grants the permission to the account."
          }
        }
      },
      "InvoiceTemplateList": {
        "type": "object",
        "properties": {
          "object": {
            "type": "string",
            "title": "Object type",
            "description": "Will always be List."
          },
          "has_more": {
            "type": "boolean",
            "description": "Indicates there are more results on subsequent pages."
          },
          "next": {
            "type": "string",
            "description": "Path to subsequent page of results."
          },
          "data": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/InvoiceTemplate"
            }
          }
        }
      },
      "InvoiceTemplate": {
        "type": "object",
        "description": "Settings for an invoice template.",
        "properties": {
          "id": {
            "type": "string"
          },
          "code": {
            "type": "string",
            "description": "Invoice template code."
          },
          "name": {
            "type": "string",
            "description": "Invoice template name."
          },
          "description": {
            "type": "string",
            "description": "Invoice template description."
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "description": "When the invoice template was created in Recurly."
          },
          "updated_at": {
            "type": "string",
            "format": "date-time",
            "description": "When the invoice template was updated in Recurly."
          }
        }
      },
      "PaymentMethod": {
        "properties": {
          "object": {
            "type": "string",
            "enum": [
              "bacs",
              "amazon",
              "amazon_billing_agreement",
              "apple_pay",
              "bank_account_info",
              "braintree_apple_pay",
              "check",
              "credit_card",
              "eft",
              "gateway_token",
              "google_pay",
              "iban_bank_account",
              "money_order",
              "other",
              "paypal",
              "paypal_billing_agreement",
              "roku",
              "sepadirectdebit",
              "venmo",
              "wire_transfer",
              "braintree_v_zero",
              "boleto",
              "cash_app"
            ]
          },
          "card_type": {
            "description": "Visa, MasterCard, American Express, Discover, JCB, etc.",
            "type": "string",
            "enum": [
              "American Express",
              "Dankort",
              "Diners Club",
              "Discover",
              "ELO",
              "Forbrugsforeningen",
              "Hipercard",
              "JCB",
              "Laser",
              "Maestro",
              "MasterCard",
              "Test Card",
              "Union Pay",
              "Unknown",
              "Visa",
              "Tarjeta Naranja"
            ]
          },
          "first_six": {
            "type": "string",
            "description": "Credit card number's first six digits.",
            "maxLength": 6
          },
          "last_four": {
            "type": "string",
            "description": "Credit card number's last four digits. Will refer to bank account if payment method is ACH.",
            "maxLength": 4
          },
          "last_two": {
            "type": "string",
            "description": "The IBAN bank account's last two digits.",
            "maxLength": 2
          },
          "exp_month": {
            "type": "integer",
            "description": "Expiration month.",
            "maxLength": 2
          },
          "exp_year": {
            "type": "integer",
            "description": "Expiration year.",
            "maxLength": 4
          },
          "gateway_token": {
            "type": "string",
            "description": "A token used in place of a credit card in order to perform transactions.",
            "maxLength": 50
          },
          "cc_bin_country": {
            "type": "string",
            "description": "The 2-letter ISO 3166-1 alpha-2 country code associated with the credit card BIN, if known by Recurly. Available on the BillingInfo object only. Available when the BIN country lookup feature is enabled."
          },
          "gateway_code": {
            "type": "string",
            "description": "An identifier for a specific payment gateway.",
            "maxLength": 13
          },
          "gateway_attributes": {
            "type": "object",
            "description": "Gateway specific attributes associated with this PaymentMethod",
            "x-class-name": "GatewayAttributes",
            "properties": {
              "account_reference": {
                "type": "string",
                "description": "Used by Adyen and Braintree gateways. For Adyen the Shopper Reference value used when the external token was created. For Braintree the PayPal PayerID is populated in the response.",
                "maxLength": 264
              }
            }
          },
          "card_network_preference": {
            "description": "Represents the card network preference associated with the billing info for dual badged cards. Must be a supported card network.",
            "type": "string",
            "enum": [
              "Bancontact",
              "CartesBancaires",
              "Dankort",
              "MasterCard",
              "Visa"
            ]
          },
          "billing_agreement_id": {
            "type": "string",
            "description": "Billing Agreement identifier. Only present for Amazon or Paypal payment methods."
          },
          "name_on_account": {
            "type": "string",
            "description": "The name associated with the bank account."
          },
          "account_type": {
            "description": "The bank account type. Only present for ACH payment methods.",
            "type": "string",
            "enum": [
              "checking",
              "savings"
            ]
          },
          "routing_number": {
            "type": "string",
            "description": "The bank account's routing number. Only present for ACH payment methods."
          },
          "routing_number_bank": {
            "type": "string",
            "description": "The bank name of this routing number."
          },
          "username": {
            "type": "string",
            "description": "Username of the associated payment method. Currently only associated with Venmo."
          }
        }
      },
      "BusinessEntityList": {
        "type": "object",
        "properties": {
          "object": {
            "type": "string",
            "title": "Object type",
            "description": "Will always be List."
          },
          "has_more": {
            "type": "boolean",
            "description": "Indicates there are more results on subsequent pages."
          },
          "next": {
            "type": "string",
            "description": "Path to subsequent page of results."
          },
          "data": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/BusinessEntity"
            }
          }
        }
      },
      "BusinessEntity": {
        "type": "object",
        "description": "Business entity details",
        "properties": {
          "id": {
            "title": "Business entity ID",
            "type": "string",
            "maxLength": 13,
            "readOnly": true
          },
          "object": {
            "title": "Object type",
            "type": "string",
            "readOnly": true
          },
          "code": {
            "title": "Business entity code",
            "type": "string",
            "maxLength": 50,
            "description": "The entity code of the business entity."
          },
          "name": {
            "type": "string",
            "title": "Name",
            "description": "This name describes your business entity and will appear on the invoice.",
            "maxLength": 255
          },
          "invoice_display_address": {
            "title": "Invoice display address",
            "description": "Address information for the business entity that will appear on the invoice.",
            "$ref": "#/components/schemas/Address"
          },
          "tax_address": {
            "title": "Tax address",
            "description": "Address information for the business entity that will be used for calculating taxes.",
            "$ref": "#/components/schemas/Address"
          },
          "origin_tax_address_source": {
            "type": "string",
            "title": "Origin tax address source",
            "description": "The source of the address that will be used as the origin in determining taxes. Available only when the site is on an Elite plan. A value of \"origin\" refers to the \"Business entity tax address\". A value of \"destination\" refers to the \"Customer tax address\".",
            "default": "origin",
            "enum": [
              "origin",
              "destination"
            ]
          },
          "destination_tax_address_source": {
            "type": "string",
            "title": "Destination tax address source",
            "description": "The source of the address that will be used as the destinaion in determining taxes. Available only when the site is on an Elite plan. A value of \"destination\" refers to the \"Customer tax address\". A value of \"origin\" refers to the \"Business entity tax address\".",
            "default": "destination",
            "enum": [
              "destination",
              "origin"
            ]
          },
          "default_vat_number": {
            "type": "string",
            "title": "Default VAT number",
            "description": "VAT number for the customer used on the invoice.",
            "maxLength": 20
          },
          "default_registration_number": {
            "type": "string",
            "title": "Default registration number",
            "description": "Registration number for the customer used on the invoice.",
            "maxLength": 30
          },
          "subscriber_location_countries": {
            "type": "array",
            "title": "Subscriber location countries",
            "description": "List of countries for which the business entity will be used.",
            "items": {
              "type": "string",
              "title": "Country code"
            }
          },
          "default_liability_gl_account_id": {
            "type": "string",
            "title": "General Ledger Account ID",
            "description": "The ID of a general ledger account. General ledger accounts are\nonly accessible as a part of the Recurly RevRec Standard and\nRecurly RevRec Advanced features.\n",
            "maxLength": 13
          },
          "default_revenue_gl_account_id": {
            "type": "string",
            "title": "General Ledger Account ID",
            "description": "The ID of a general ledger account. General ledger accounts are\nonly accessible as a part of the Recurly RevRec Standard and\nRecurly RevRec Advanced features.\n",
            "maxLength": 13
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "title": "Created at",
            "readOnly": true
          },
          "updated_at": {
            "type": "string",
            "format": "date-time",
            "title": "Last updated at",
            "readOnly": true
          }
        }
      },
      "GiftCardList": {
        "type": "object",
        "properties": {
          "object": {
            "type": "string",
            "title": "Object type",
            "description": "Will always be List."
          },
          "has_more": {
            "type": "boolean",
            "description": "Indicates there are more results on subsequent pages."
          },
          "next": {
            "type": "string",
            "description": "Path to subsequent page of results."
          },
          "data": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/GiftCard"
            }
          }
        }
      },
      "GiftCard": {
        "type": "object",
        "description": "Gift card details",
        "properties": {
          "id": {
            "title": "Gift card ID",
            "type": "string",
            "maxLength": 13,
            "readOnly": true
          },
          "object": {
            "title": "Object type",
            "type": "string",
            "readOnly": true
          },
          "gifter_account_id": {
            "title": "Gifter account ID",
            "type": "string",
            "maxLength": 13,
            "description": "The ID of the account that purchased the gift card."
          },
          "recipient_account_id": {
            "title": "Recipient account ID",
            "type": "string",
            "maxLength": 13,
            "description": "The ID of the account that redeemed the gift card redemption code.  Does not have a value until gift card is redeemed."
          },
          "purchase_invoice_id": {
            "title": "Purchase invoice ID",
            "type": "string",
            "maxLength": 13,
            "description": "The ID of the invoice for the gift card purchase made by the gifter."
          },
          "redemption_invoice_id": {
            "title": "Redemption invoice ID",
            "type": "string",
            "maxLength": 13,
            "description": "The ID of the invoice for the gift card redemption made by the recipient.  Does not have a value until gift card is redeemed."
          },
          "redemption_code": {
            "title": "Redemption code",
            "type": "string",
            "description": "The unique redemption code for the gift card, generated by Recurly. Will be 16 characters, alphanumeric, displayed uppercase, but accepted in any case at redemption. Used by the recipient account to create a credit in the amount of the `unit_amount` on their account."
          },
          "balance": {
            "title": "Remaining balance",
            "type": "number",
            "format": "float",
            "description": "The remaining credit on the recipient account associated with this gift card. Only has a value once the gift card has been redeemed. Can be used to create gift card balance displays for your customers."
          },
          "product_code": {
            "title": "Product code",
            "type": "string",
            "description": "The product code or SKU of the gift card product."
          },
          "unit_amount": {
            "title": "Purchase unit amount",
            "type": "number",
            "format": "float",
            "description": "The amount of the gift card, which is the amount of the charge to the gifter account and the amount of credit that is applied to the recipient account upon successful redemption."
          },
          "currency": {
            "title": "Currency",
            "type": "string",
            "description": "3-letter ISO 4217 currency code.",
            "maxLength": 3
          },
          "delivery": {
            "title": "Delivery details",
            "description": "The delivery details for the gift card.",
            "readOnly": true,
            "$ref": "#/components/schemas/GiftCardDelivery"
          },
          "performance_obligation_id": {
            "type": "string",
            "title": "Performance Obligation ID",
            "description": "The ID of a performance obligation. Performance obligations are\nonly accessible as a part of the Recurly RevRec Standard and\nRecurly RevRec Advanced features.\n",
            "maxLength": 13
          },
          "liability_gl_account_id": {
            "type": "string",
            "title": "General Ledger Account ID",
            "description": "The ID of a general ledger account. General ledger accounts are\nonly accessible as a part of the Recurly RevRec Standard and\nRecurly RevRec Advanced features.\n",
            "maxLength": 13
          },
          "revenue_gl_account_id": {
            "type": "string",
            "title": "General Ledger Account ID",
            "description": "The ID of a general ledger account. General ledger accounts are\nonly accessible as a part of the Recurly RevRec Standard and\nRecurly RevRec Advanced features.\n",
            "maxLength": 13
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "title": "Created at",
            "readOnly": true
          },
          "updated_at": {
            "type": "string",
            "format": "date-time",
            "title": "Last updated at",
            "readOnly": true
          },
          "delivered_at": {
            "type": "string",
            "format": "date-time",
            "title": "Delivered at",
            "readOnly": true,
            "description": "When the gift card was sent to the recipient by Recurly via email, if method was email and the \"Gift Card Delivery\" email template was enabled. This will be empty for post delivery or email delivery where the email template was disabled."
          },
          "redeemed_at": {
            "type": "string",
            "format": "date-time",
            "title": "Redeemed at",
            "readOnly": true,
            "description": "When the gift card was redeemed by the recipient."
          },
          "canceled_at": {
            "type": "string",
            "format": "date-time",
            "title": "Canceled at",
            "readOnly": true,
            "description": "When the gift card was canceled."
          }
        }
      },
      "GiftCardCreate": {
        "type": "object",
        "description": "Gift card details",
        "properties": {
          "product_code": {
            "title": "Product code",
            "type": "string",
            "description": "The product code or SKU of the gift card product."
          },
          "unit_amount": {
            "title": "Purchase unit amount",
            "type": "number",
            "format": "float",
            "description": "The amount of the gift card, which is the amount of the charge to the gifter account and the amount of credit that is applied to the recipient account upon successful redemption."
          },
          "currency": {
            "title": "Currency",
            "type": "string",
            "description": "3-letter ISO 4217 currency code.",
            "maxLength": 3
          },
          "delivery": {
            "title": "Delivery details",
            "description": "The delivery details for the gift card.",
            "readOnly": true,
            "$ref": "#/components/schemas/GiftCardDeliveryCreate"
          },
          "gifter_account": {
            "title": "Gifter account details",
            "description": "Block of account details for the gifter. This references an existing account_code.",
            "readOnly": true,
            "$ref": "#/components/schemas/AccountPurchase"
          }
        },
        "required": [
          "product_code",
          "unit_amount",
          "currency",
          "delivery",
          "gifter_account"
        ]
      },
      "GiftCardDeliveryCreate": {
        "type": "object",
        "description": "Gift card delivery details",
        "properties": {
          "method": {
            "title": "Delivery method",
            "description": "Whether the delivery method is email or postal service.",
            "type": "string",
            "enum": [
              "email",
              "post"
            ]
          },
          "email_address": {
            "title": "Recipient email address",
            "type": "string",
            "description": "The email address of the recipient. Required if `method` is `email`."
          },
          "deliver_at": {
            "type": "string",
            "format": "date-time",
            "title": "Deliver at",
            "readOnly": true,
            "description": "When the gift card should be delivered to the recipient. If null, the gift card will be delivered immediately. If a datetime is provided, the delivery will be in an hourly window, rounding down. For example, 6:23 pm will be in the 6:00 pm hourly batch."
          },
          "first_name": {
            "title": "Recipient first name",
            "type": "string",
            "description": "The first name of the recipient."
          },
          "last_name": {
            "title": "Recipient last name",
            "type": "string",
            "description": "The last name of the recipient."
          },
          "recipient_address": {
            "title": "Recipient address",
            "description": "Address information for the recipient. Required if `method` is `post`.",
            "$ref": "#/components/schemas/Address"
          },
          "gifter_name": {
            "title": "Gifter name",
            "type": "string",
            "description": "The name of the gifter for the purpose of a message displayed to the recipient."
          },
          "personal_message": {
            "title": "Personal message",
            "type": "string",
            "maxLength": 255,
            "description": "The personal message from the gifter to the recipient."
          }
        },
        "required": [
          "method"
        ]
      },
      "GiftCardDelivery": {
        "type": "object",
        "description": "Gift card delivery details",
        "properties": {
          "method": {
            "title": "Delivery method",
            "description": "Whether the delivery method is email or postal service.",
            "type": "string",
            "enum": [
              "email",
              "post"
            ]
          },
          "email_address": {
            "title": "Recipient email address",
            "type": "string",
            "description": "The email address of the recipient."
          },
          "deliver_at": {
            "type": "string",
            "format": "date-time",
            "title": "Deliver at",
            "readOnly": true,
            "description": "When the gift card should be delivered to the recipient. If null, the gift card will be delivered immediately. If a datetime is provided, the delivery will be in an hourly window, rounding down. For example, 6:23 pm will be in the 6:00 pm hourly batch."
          },
          "first_name": {
            "title": "Recipient first name",
            "type": "string",
            "description": "The first name of the recipient."
          },
          "last_name": {
            "title": "Recipient last name",
            "type": "string",
            "description": "The last name of the recipient."
          },
          "recipient_address": {
            "title": "Recipient address",
            "description": "Address information for the recipient.",
            "$ref": "#/components/schemas/Address"
          },
          "gifter_name": {
            "title": "Gifter name",
            "type": "string",
            "description": "The name of the gifter for the purpose of a message displayed to the recipient."
          },
          "personal_message": {
            "title": "Personal message",
            "type": "string",
            "maxLength": 255,
            "description": "The personal message from the gifter to the recipient."
          }
        }
      },
      "GiftCardRedeem": {
        "type": "object",
        "description": "The information necessary to redeem a gift card.",
        "properties": {
          "recipient_account": {
            "title": "Recipient account",
            "description": "The account for the recipient of the gift card.",
            "$ref": "#/components/schemas/AccountReference"
          }
        },
        "required": [
          "recipient_account"
        ]
      },
      "Error": {
        "type": "object",
        "properties": {
          "type": {
            "title": "Type",
            "type": "string",
            "enum": [
              "bad_request",
              "immutable_subscription",
              "internal_server_error",
              "invalid_api_key",
              "invalid_api_version",
              "invalid_content_type",
              "invalid_permissions",
              "invalid_token",
              "missing_feature",
              "not_found",
              "rate_limited",
              "service_not_available",
              "simultaneous_request",
              "tax_service_error",
              "transaction",
              "unauthorized",
              "unavailable_in_api_version",
              "unknown_api_version",
              "validation"
            ]
          },
          "message": {
            "type": "string",
            "title": "Message"
          },
          "params": {
            "type": "array",
            "title": "Parameter specific errors",
            "items": {
              "type": "object",
              "properties": {
                "param": {
                  "type": "string"
                }
              }
            }
          }
        }
      },
      "ErrorMayHaveTransaction": {
        "allOf": [
          {
            "$ref": "#/components/schemas/Error"
          },
          {
            "type": "object",
            "properties": {
              "transaction_error": {
                "type": "object",
                "x-class-name": "TransactionError",
                "title": "Transaction error details",
                "description": "This is only included on errors with `type=transaction`.",
                "properties": {
                  "object": {
                    "type": "string",
                    "title": "Object type"
                  },
                  "transaction_id": {
                    "type": "string",
                    "title": "Transaction ID",
                    "maxLength": 13
                  },
                  "category": {
                    "title": "Category",
                    "type": "string",
                    "enum": [
                      "three_d_secure_required",
                      "three_d_secure_action_required",
                      "amazon",
                      "api_error",
                      "approved",
                      "communication",
                      "configuration",
                      "duplicate",
                      "fraud",
                      "hard",
                      "invalid",
                      "not_enabled",
                      "not_supported",
                      "recurly",
                      "referral",
                      "skles",
                      "soft",
                      "unknown"
                    ]
                  },
                  "code": {
                    "title": "Code",
                    "type": "string",
                    "enum": [
                      "ach_cancel",
                      "ach_chargeback",
                      "ach_credit_return",
                      "ach_exception",
                      "ach_return",
                      "ach_transactions_not_supported",
                      "ach_validation_exception",
                      "amazon_amount_exceeded",
                      "amazon_declined_review",
                      "amazon_invalid_authorization_status",
                      "amazon_invalid_close_attempt",
                      "amazon_invalid_create_order_reference",
                      "amazon_invalid_order_status",
                      "amazon_not_authorized",
                      "amazon_order_not_modifiable",
                      "amazon_transaction_count_exceeded",
                      "api_error",
                      "approved",
                      "approved_fraud_review",
                      "authorization_already_captured",
                      "authorization_amount_depleted",
                      "authorization_expired",
                      "batch_processing_error",
                      "billing_agreement_already_accepted",
                      "billing_agreement_not_accepted",
                      "billing_agreement_not_found",
                      "billing_agreement_replaced",
                      "call_issuer",
                      "call_issuer_update_cardholder_data",
                      "cancelled",
                      "cannot_refund_unsettled_transactions",
                      "card_not_activated",
                      "card_type_not_accepted",
                      "cardholder_requested_stop",
                      "contact_gateway",
                      "contract_not_found",
                      "currency_not_supported",
                      "customer_canceled_transaction",
                      "cvv_required",
                      "declined",
                      "declined_card_number",
                      "declined_exception",
                      "declined_expiration_date",
                      "declined_missing_data",
                      "declined_saveable",
                      "declined_security_code",
                      "deposit_referenced_chargeback",
                      "direct_debit_type_not_accepted",
                      "duplicate_transaction",
                      "exceeds_daily_limit",
                      "exceeds_max_amount",
                      "expired_card",
                      "finbot_disconnect",
                      "finbot_unavailable",
                      "fraud_address",
                      "fraud_address_recurly",
                      "fraud_advanced_verification",
                      "fraud_gateway",
                      "fraud_generic",
                      "fraud_ip_address",
                      "fraud_manual_decision",
                      "fraud_risk_check",
                      "fraud_security_code",
                      "fraud_stolen_card",
                      "fraud_too_many_attempts",
                      "fraud_velocity",
                      "gateway_account_setup_incomplete",
                      "gateway_error",
                      "gateway_rate_limited",
                      "gateway_timeout",
                      "gateway_token_not_found",
                      "gateway_unavailable",
                      "gateway_validation_exception",
                      "insufficient_funds",
                      "invalid_account_number",
                      "invalid_amount",
                      "invalid_billing_agreement_status",
                      "invalid_card_number",
                      "invalid_data",
                      "invalid_email",
                      "invalid_gateway_access_token",
                      "invalid_gateway_configuration",
                      "invalid_issuer",
                      "invalid_login",
                      "invalid_merchant_type",
                      "invalid_name",
                      "invalid_payment_method",
                      "invalid_payment_method_hard",
                      "invalid_transaction",
                      "issuer_unavailable",
                      "lifecycle_decline",
                      "merch_max_transaction_limit_exceeded",
                      "moneybot_disconnect",
                      "moneybot_unavailable",
                      "no_billing_information",
                      "no_gateway",
                      "no_gateway_found_for_transaction_amount",
                      "partial_approval",
                      "partial_credits_not_supported",
                      "payer_authentication_rejected",
                      "payment_cannot_void_authorization",
                      "payment_not_accepted",
                      "paypal_account_issue",
                      "paypal_cannot_pay_self",
                      "paypal_declined_use_alternate",
                      "paypal_expired_reference_id",
                      "paypal_hard_decline",
                      "paypal_invalid_billing_agreement",
                      "paypal_primary_declined",
                      "processor_not_available",
                      "processor_unavailable",
                      "recurly_credentials_not_found",
                      "recurly_error",
                      "recurly_failed_to_get_token",
                      "recurly_token_mismatch",
                      "recurly_token_not_found",
                      "reference_transactions_not_enabled",
                      "restricted_card",
                      "restricted_card_chargeback",
                      "rjs_token_expired",
                      "roku_invalid_card_number",
                      "roku_invalid_cib",
                      "roku_invalid_payment_method",
                      "roku_zip_code_mismatch",
                      "simultaneous",
                      "ssl_error",
                      "temporary_hold",
                      "three_d_secure_action_required",
                      "three_d_secure_action_result_token_mismatch",
                      "three_d_secure_authentication",
                      "three_d_secure_connection_error",
                      "three_d_secure_credential_error",
                      "three_d_secure_not_supported",
                      "too_busy",
                      "too_many_attempts",
                      "total_credit_exceeds_capture",
                      "transaction_already_refunded",
                      "transaction_already_voided",
                      "transaction_cannot_be_authorized",
                      "transaction_cannot_be_refunded",
                      "transaction_cannot_be_refunded_currently",
                      "transaction_cannot_be_voided",
                      "transaction_failed_to_settle",
                      "transaction_not_found",
                      "transaction_service_v2_disconnect",
                      "transaction_service_v2_unavailable",
                      "transaction_settled",
                      "transaction_stale_at_gateway",
                      "try_again",
                      "unknown",
                      "unmapped_partner_error",
                      "vaultly_service_unavailable",
                      "zero_dollar_auth_not_supported"
                    ]
                  },
                  "decline_code": {
                    "title": "Decline code",
                    "type": "string",
                    "enum": [
                      "account_closed",
                      "call_issuer",
                      "card_not_activated",
                      "card_not_supported",
                      "cardholder_requested_stop",
                      "do_not_honor",
                      "do_not_try_again",
                      "exceeds_daily_limit",
                      "generic_decline",
                      "expired_card",
                      "fraudulent",
                      "insufficient_funds",
                      "incorrect_address",
                      "incorrect_security_code",
                      "invalid_amount",
                      "invalid_number",
                      "invalid_transaction",
                      "issuer_unavailable",
                      "lifecycle_decline",
                      "lost_card",
                      "pickup_card",
                      "policy_decline",
                      "restricted_card",
                      "restricted_card_chargeback",
                      "security_decline",
                      "stolen_card",
                      "try_again",
                      "update_cardholder_data",
                      "requires_3d_secure"
                    ]
                  },
                  "message": {
                    "type": "string",
                    "title": "Customer message"
                  },
                  "merchant_advice": {
                    "type": "string",
                    "title": "Merchant message"
                  },
                  "three_d_secure_action_token_id": {
                    "type": "string",
                    "title": "3-D Secure action token id",
                    "description": "Returned when 3-D Secure authentication is required for a transaction. Pass this value to Recurly.js so it can continue the challenge flow.",
                    "maxLength": 22
                  },
                  "fraud_info": {
                    "$ref": "#/components/schemas/TransactionFraudInfo"
                  }
                }
              }
            }
          }
        ]
      },
      "ExportDates": {
        "type": "object",
        "properties": {
          "object": {
            "type": "string",
            "title": "Object type",
            "readOnly": true
          },
          "dates": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "title": "An array of dates that have available exports."
          }
        }
      },
      "ExportFiles": {
        "type": "object",
        "properties": {
          "object": {
            "type": "string",
            "title": "Object type",
            "readOnly": true
          },
          "files": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ExportFile"
            }
          }
        }
      },
      "ExportFile": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "title": "Filename",
            "description": "Name of the export file."
          },
          "md5sum": {
            "type": "string",
            "title": "MD5 hash of the export file",
            "description": "MD5 hash of the export file."
          },
          "href": {
            "type": "string",
            "title": "A link to the export file",
            "description": "A presigned link to download the export file."
          }
        }
      }
    }
  }
}
